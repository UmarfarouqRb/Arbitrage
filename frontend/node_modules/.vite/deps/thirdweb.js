import {
  sendAndConfirmTransaction
} from "./chunk-D37BV44T.js";
import {
  bytesToBigInt,
  bytesToBool,
  bytesToNumber,
  bytesToString,
  deploySmartAccount,
  fromBytes,
  verifyHash
} from "./chunk-IAVKT4R5.js";
import {
  eth_estimateGas
} from "./chunk-4NRRJ4OJ.js";
import {
  eth_getTransactionCount
} from "./chunk-Z2TUQVRI.js";
import {
  serializeTransaction
} from "./chunk-H5CTIYC6.js";
import {
  eth_getStorageAt
} from "./chunk-5RBYW3HS.js";
import {
  eth_getLogs,
  getBuyWithCryptoHistory,
  getBuyWithCryptoQuote,
  getBuyWithCryptoStatus,
  getContractEvents,
  isBaseTransactionOptions,
  recoverAddress,
  sign,
  simulateTransaction,
  watchContractEvents
} from "./chunk-762SSTVH.js";
import {
  eth_getBalance
} from "./chunk-J4J2OXWX.js";
import "./chunk-AL7AZVTW.js";
import "./chunk-4RVIPJGG.js";
import {
  parseEventLogs,
  prepareEvent
} from "./chunk-NZT66TIZ.js";
import {
  sendTransaction
} from "./chunk-IBXM4QFM.js";
import {
  sendBatchTransaction
} from "./chunk-7BPFXS23.js";
import {
  decodeData,
  from3 as from
} from "./chunk-BJQMBSW7.js";
import "./chunk-OG5JFRF2.js";
import {
  prepareContractCall
} from "./chunk-7UCB3KUJ.js";
import {
  getSignPayload
} from "./chunk-FXH2AAXJ.js";
import "./chunk-CTU5HEBU.js";
import {
  prepareTransaction
} from "./chunk-FHM7BLOT.js";
import "./chunk-6XWBNOXA.js";
import {
  decimals
} from "./chunk-VKS2YKCV.js";
import "./chunk-YSFX7F34.js";
import {
  NATIVE_TOKEN_ADDRESS,
  ZERO_ADDRESS
} from "./chunk-YCZ3YGMG.js";
import {
  eth_blockNumber,
  eth_getTransactionReceipt,
  waitForReceipt,
  watchBlockNumber
} from "./chunk-RPLD6P3C.js";
import "./chunk-QWTK625L.js";
import "./chunk-ZTSTPI2U.js";
import {
  eth_sendRawTransaction
} from "./chunk-CMXLKATA.js";
import {
  insight_exports
} from "./chunk-D6LRDCET.js";
import "./chunk-2CB4UDOU.js";
import "./chunk-IW3I3RWX.js";
import "./chunk-T5PDFO3A.js";
import "./chunk-JJI46KRT.js";
import {
  Value_exports
} from "./chunk-VSQQKPXM.js";
import "./chunk-IY55ZBZE.js";
import {
  fromHex as fromHex2
} from "./chunk-DJGOETSH.js";
import {
  keccak256 as keccak2562
} from "./chunk-ZQ2FYVGC.js";
import "./chunk-DUYIIKDP.js";
import {
  toSerializableTransaction
} from "./chunk-QCGN5F3I.js";
import "./chunk-237EVM5Y.js";
import {
  eth_getCode
} from "./chunk-EJZW7PV4.js";
import {
  eth_call,
  readContract
} from "./chunk-SZMJC6C4.js";
import {
  estimateGasCost
} from "./chunk-AZY2ZIIF.js";
import {
  estimateGas,
  eth_gasPrice,
  eth_getBlockByNumber,
  eth_maxPriorityFeePerGas,
  getGasPrice,
  resolveContractAbi
} from "./chunk-J6NIOEGA.js";
import {
  parseAbiItem
} from "./chunk-BREECRX7.js";
import "./chunk-PN6DQXIK.js";
import "./chunk-PANVS3XX.js";
import {
  resolvePromisedValue
} from "./chunk-L4NN5UUQ.js";
import "./chunk-5AWZZDTC.js";
import "./chunk-EBPJZRGO.js";
import "./chunk-S4ZD6P6T.js";
import {
  formatBlock,
  formatTransaction
} from "./chunk-YGHTSOJ2.js";
import "./chunk-OM2KKZMP.js";
import {
  stringify as stringify2
} from "./chunk-LPC2L23M.js";
import "./chunk-QMDVOU32.js";
import {
  concatHex
} from "./chunk-WYQK3L5J.js";
import {
  encode
} from "./chunk-QFKZXB2I.js";
import {
  getRpcClient
} from "./chunk-X7CG3L2Z.js";
import {
  fromGwei,
  toEther,
  toTokens,
  toUnits,
  toWei
} from "./chunk-DVNKWNZO.js";
import "./chunk-PNK6QTI4.js";
import {
  Transfer_exports,
  bridge_exports
} from "./chunk-4LCPASHY.js";
import "./chunk-LMLG7BHP.js";
import {
  stringify
} from "./chunk-2CIJO3V3.js";
import {
  getContract
} from "./chunk-UZAMIWMY.js";
import {
  Hash,
  aexists,
  aoutput,
  createView,
  getAddress,
  isAddress,
  keccak256,
  rotr,
  toBytes as toBytes2,
  wrapConstructor
} from "./chunk-6SVI5C4W.js";
import {
  boolToBytes,
  hexToBytes,
  numberToBytes,
  stringToBytes,
  toBytes
} from "./chunk-ESTOX3EM.js";
import {
  boolToHex,
  fromHex,
  hexToBigInt,
  hexToBool,
  hexToNumber,
  hexToString,
  hexToUint8Array,
  isHex,
  numberToHex,
  padHex,
  stringToHex,
  toHex,
  uint8ArrayToHex
} from "./chunk-CCP6WQOA.js";
import "./chunk-HR2UIEMV.js";
import "./chunk-DNHPYDC5.js";
import {
  defineChain,
  getCachedChain
} from "./chunk-Z2MF3EIF.js";
import "./chunk-G24WGTAU.js";
import {
  getClientFetch,
  isJWT
} from "./chunk-TU6UWWTV.js";
import "./chunk-3OXDSLPJ.js";
import {
  getThirdwebBaseUrl
} from "./chunk-TVKFAMBW.js";
import {
  LruMap
} from "./chunk-PPP72TBL.js";
import {
  __export
} from "./chunk-OS7ZSSJM.js";

// node_modules/thirdweb/node_modules/@noble/hashes/esm/_md.js
function setBigUint64(view, byteOffset, value, isLE) {
  if (typeof view.setBigUint64 === "function")
    return view.setBigUint64(byteOffset, value, isLE);
  const _32n = BigInt(32);
  const _u32_max = BigInt(4294967295);
  const wh = Number(value >> _32n & _u32_max);
  const wl = Number(value & _u32_max);
  const h = isLE ? 4 : 0;
  const l = isLE ? 0 : 4;
  view.setUint32(byteOffset + h, wh, isLE);
  view.setUint32(byteOffset + l, wl, isLE);
}
function Chi(a, b, c) {
  return a & b ^ ~a & c;
}
function Maj(a, b, c) {
  return a & b ^ a & c ^ b & c;
}
var HashMD = class extends Hash {
  constructor(blockLen, outputLen, padOffset, isLE) {
    super();
    this.finished = false;
    this.length = 0;
    this.pos = 0;
    this.destroyed = false;
    this.blockLen = blockLen;
    this.outputLen = outputLen;
    this.padOffset = padOffset;
    this.isLE = isLE;
    this.buffer = new Uint8Array(blockLen);
    this.view = createView(this.buffer);
  }
  update(data) {
    aexists(this);
    const { view, buffer, blockLen } = this;
    data = toBytes2(data);
    const len = data.length;
    for (let pos = 0; pos < len; ) {
      const take = Math.min(blockLen - this.pos, len - pos);
      if (take === blockLen) {
        const dataView = createView(data);
        for (; blockLen <= len - pos; pos += blockLen)
          this.process(dataView, pos);
        continue;
      }
      buffer.set(data.subarray(pos, pos + take), this.pos);
      this.pos += take;
      pos += take;
      if (this.pos === blockLen) {
        this.process(view, 0);
        this.pos = 0;
      }
    }
    this.length += data.length;
    this.roundClean();
    return this;
  }
  digestInto(out) {
    aexists(this);
    aoutput(out, this);
    this.finished = true;
    const { buffer, view, blockLen, isLE } = this;
    let { pos } = this;
    buffer[pos++] = 128;
    this.buffer.subarray(pos).fill(0);
    if (this.padOffset > blockLen - pos) {
      this.process(view, 0);
      pos = 0;
    }
    for (let i = pos; i < blockLen; i++)
      buffer[i] = 0;
    setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);
    this.process(view, 0);
    const oview = createView(out);
    const len = this.outputLen;
    if (len % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const outLen = len / 4;
    const state = this.get();
    if (outLen > state.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let i = 0; i < outLen; i++)
      oview.setUint32(4 * i, state[i], isLE);
  }
  digest() {
    const { buffer, outputLen } = this;
    this.digestInto(buffer);
    const res = buffer.slice(0, outputLen);
    this.destroy();
    return res;
  }
  _cloneInto(to) {
    to || (to = new this.constructor());
    to.set(...this.get());
    const { blockLen, buffer, length, finished, destroyed, pos } = this;
    to.length = length;
    to.pos = pos;
    to.finished = finished;
    to.destroyed = destroyed;
    if (length % blockLen)
      to.buffer.set(buffer);
    return to;
  }
};

// node_modules/thirdweb/node_modules/@noble/hashes/esm/sha256.js
var SHA256_K = new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]);
var SHA256_IV = new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]);
var SHA256_W = new Uint32Array(64);
var SHA256 = class extends HashMD {
  constructor(outputLen = 32) {
    super(64, outputLen, 8, false);
    this.A = SHA256_IV[0] | 0;
    this.B = SHA256_IV[1] | 0;
    this.C = SHA256_IV[2] | 0;
    this.D = SHA256_IV[3] | 0;
    this.E = SHA256_IV[4] | 0;
    this.F = SHA256_IV[5] | 0;
    this.G = SHA256_IV[6] | 0;
    this.H = SHA256_IV[7] | 0;
  }
  get() {
    const { A, B, C, D, E, F, G, H } = this;
    return [A, B, C, D, E, F, G, H];
  }
  // prettier-ignore
  set(A, B, C, D, E, F, G, H) {
    this.A = A | 0;
    this.B = B | 0;
    this.C = C | 0;
    this.D = D | 0;
    this.E = E | 0;
    this.F = F | 0;
    this.G = G | 0;
    this.H = H | 0;
  }
  process(view, offset) {
    for (let i = 0; i < 16; i++, offset += 4)
      SHA256_W[i] = view.getUint32(offset, false);
    for (let i = 16; i < 64; i++) {
      const W15 = SHA256_W[i - 15];
      const W2 = SHA256_W[i - 2];
      const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ W15 >>> 3;
      const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ W2 >>> 10;
      SHA256_W[i] = s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16] | 0;
    }
    let { A, B, C, D, E, F, G, H } = this;
    for (let i = 0; i < 64; i++) {
      const sigma1 = rotr(E, 6) ^ rotr(E, 11) ^ rotr(E, 25);
      const T1 = H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i] | 0;
      const sigma0 = rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22);
      const T2 = sigma0 + Maj(A, B, C) | 0;
      H = G;
      G = F;
      F = E;
      E = D + T1 | 0;
      D = C;
      C = B;
      B = A;
      A = T1 + T2 | 0;
    }
    A = A + this.A | 0;
    B = B + this.B | 0;
    C = C + this.C | 0;
    D = D + this.D | 0;
    E = E + this.E | 0;
    F = F + this.F | 0;
    G = G + this.G | 0;
    H = H + this.H | 0;
    this.set(A, B, C, D, E, F, G, H);
  }
  roundClean() {
    SHA256_W.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0);
    this.buffer.fill(0);
  }
};
var SHA224 = class extends SHA256 {
  constructor() {
    super(28);
    this.A = 3238371032 | 0;
    this.B = 914150663 | 0;
    this.C = 812702999 | 0;
    this.D = 4144912697 | 0;
    this.E = 4290775857 | 0;
    this.F = 1750603025 | 0;
    this.G = 1694076839 | 0;
    this.H = 3204075428 | 0;
  }
};
var sha256 = wrapConstructor(() => new SHA256());
var sha224 = wrapConstructor(() => new SHA224());

// node_modules/thirdweb/dist/esm/utils/hashing/sha256.js
function sha2562(value, to) {
  const bytes = sha256(isHex(value, { strict: false }) ? hexToUint8Array(value) : value);
  if (to === "bytes") {
    return bytes;
  }
  return uint8ArrayToHex(bytes);
}

// node_modules/thirdweb/dist/esm/utils/client-id.js
var cache = new LruMap(4096);
function computeClientIdFromSecretKey(secretKey) {
  if (cache.has(secretKey)) {
    return cache.get(secretKey);
  }
  const cId = sha2562(stringToBytes(secretKey)).slice(2, 34);
  cache.set(secretKey, cId);
  return cId;
}

// node_modules/thirdweb/dist/esm/client/client.js
function createThirdwebClient(options) {
  const { clientId, secretKey, ...rest } = options;
  let realClientId = clientId;
  if (secretKey) {
    if (isJWT(secretKey)) {
      if (!clientId) {
        throw new Error("clientId must be provided when using a JWT secretKey");
      }
    } else {
      realClientId = clientId ?? computeClientIdFromSecretKey(secretKey);
    }
  }
  if (!realClientId) {
    throw new Error("clientId or secretKey must be provided");
  }
  return {
    ...rest,
    clientId: realClientId,
    secretKey
  };
}

// node_modules/thirdweb/dist/esm/engine/index.js
var engine_exports = {};
__export(engine_exports, {
  createServerWallet: () => createServerWallet,
  getServerWallets: () => getServerWallets,
  getTransactionStatus: () => getTransactionStatus,
  searchTransactions: () => searchTransactions2,
  serverWallet: () => serverWallet,
  waitForTransactionHash: () => waitForTransactionHash
});

// node_modules/@thirdweb-dev/engine/dist/esm/client/core/bodySerializer.js
var jsonBodySerializer = {
  bodySerializer: (body) => JSON.stringify(body, (_key, value) => typeof value === "bigint" ? value.toString() : value)
};

// node_modules/@thirdweb-dev/engine/dist/esm/client/core/params.js
var extraPrefixesMap = {
  $body_: "body",
  $headers_: "headers",
  $path_: "path",
  $query_: "query"
};
var extraPrefixes = Object.entries(extraPrefixesMap);

// node_modules/@thirdweb-dev/engine/dist/esm/client/core/auth.js
var getAuthToken = async (auth, callback) => {
  const token = typeof callback === "function" ? await callback(auth) : callback;
  if (!token) {
    return;
  }
  if (auth.scheme === "bearer") {
    return `Bearer ${token}`;
  }
  if (auth.scheme === "basic") {
    return `Basic ${btoa(token)}`;
  }
  return token;
};

// node_modules/@thirdweb-dev/engine/dist/esm/client/core/pathSerializer.js
var separatorArrayExplode = (style) => {
  switch (style) {
    case "label":
      return ".";
    case "matrix":
      return ";";
    case "simple":
      return ",";
    default:
      return "&";
  }
};
var separatorArrayNoExplode = (style) => {
  switch (style) {
    case "form":
      return ",";
    case "pipeDelimited":
      return "|";
    case "spaceDelimited":
      return "%20";
    default:
      return ",";
  }
};
var separatorObjectExplode = (style) => {
  switch (style) {
    case "label":
      return ".";
    case "matrix":
      return ";";
    case "simple":
      return ",";
    default:
      return "&";
  }
};
var serializeArrayParam = ({ allowReserved, explode, name, style, value }) => {
  if (!explode) {
    const joinedValues2 = (allowReserved ? value : value.map((v) => encodeURIComponent(v))).join(separatorArrayNoExplode(style));
    switch (style) {
      case "label":
        return `.${joinedValues2}`;
      case "matrix":
        return `;${name}=${joinedValues2}`;
      case "simple":
        return joinedValues2;
      default:
        return `${name}=${joinedValues2}`;
    }
  }
  const separator = separatorArrayExplode(style);
  const joinedValues = value.map((v) => {
    if (style === "label" || style === "simple") {
      return allowReserved ? v : encodeURIComponent(v);
    }
    return serializePrimitiveParam({
      allowReserved,
      name,
      value: v
    });
  }).join(separator);
  return style === "label" || style === "matrix" ? separator + joinedValues : joinedValues;
};
var serializePrimitiveParam = ({ allowReserved, name, value }) => {
  if (value === void 0 || value === null) {
    return "";
  }
  if (typeof value === "object") {
    throw new Error("Deeply-nested arrays/objects arenâ€™t supported. Provide your own `querySerializer()` to handle these.");
  }
  return `${name}=${allowReserved ? value : encodeURIComponent(value)}`;
};
var serializeObjectParam = ({ allowReserved, explode, name, style, value, valueOnly }) => {
  if (value instanceof Date) {
    return valueOnly ? value.toISOString() : `${name}=${value.toISOString()}`;
  }
  if (style !== "deepObject" && !explode) {
    let values = [];
    Object.entries(value).forEach(([key, v]) => {
      values = [
        ...values,
        key,
        allowReserved ? v : encodeURIComponent(v)
      ];
    });
    const joinedValues2 = values.join(",");
    switch (style) {
      case "form":
        return `${name}=${joinedValues2}`;
      case "label":
        return `.${joinedValues2}`;
      case "matrix":
        return `;${name}=${joinedValues2}`;
      default:
        return joinedValues2;
    }
  }
  const separator = separatorObjectExplode(style);
  const joinedValues = Object.entries(value).map(([key, v]) => serializePrimitiveParam({
    allowReserved,
    name: style === "deepObject" ? `${name}[${key}]` : key,
    value: v
  })).join(separator);
  return style === "label" || style === "matrix" ? separator + joinedValues : joinedValues;
};

// node_modules/@thirdweb-dev/engine/dist/esm/client/client/utils.js
var PATH_PARAM_RE = /\{[^{}]+\}/g;
var defaultPathSerializer = ({ path, url: _url }) => {
  let url = _url;
  const matches = _url.match(PATH_PARAM_RE);
  if (matches) {
    for (const match of matches) {
      let explode = false;
      let name = match.substring(1, match.length - 1);
      let style = "simple";
      if (name.endsWith("*")) {
        explode = true;
        name = name.substring(0, name.length - 1);
      }
      if (name.startsWith(".")) {
        name = name.substring(1);
        style = "label";
      } else if (name.startsWith(";")) {
        name = name.substring(1);
        style = "matrix";
      }
      const value = path[name];
      if (value === void 0 || value === null) {
        continue;
      }
      if (Array.isArray(value)) {
        url = url.replace(match, serializeArrayParam({ explode, name, style, value }));
        continue;
      }
      if (typeof value === "object") {
        url = url.replace(match, serializeObjectParam({
          explode,
          name,
          style,
          value,
          valueOnly: true
        }));
        continue;
      }
      if (style === "matrix") {
        url = url.replace(match, `;${serializePrimitiveParam({
          name,
          value
        })}`);
        continue;
      }
      const replaceValue = encodeURIComponent(style === "label" ? `.${value}` : value);
      url = url.replace(match, replaceValue);
    }
  }
  return url;
};
var createQuerySerializer = ({ allowReserved, array, object } = {}) => {
  const querySerializer = (queryParams) => {
    const search = [];
    if (queryParams && typeof queryParams === "object") {
      for (const name in queryParams) {
        const value = queryParams[name];
        if (value === void 0 || value === null) {
          continue;
        }
        if (Array.isArray(value)) {
          const serializedArray = serializeArrayParam({
            allowReserved,
            explode: true,
            name,
            style: "form",
            value,
            ...array
          });
          if (serializedArray)
            search.push(serializedArray);
        } else if (typeof value === "object") {
          const serializedObject = serializeObjectParam({
            allowReserved,
            explode: true,
            name,
            style: "deepObject",
            value,
            ...object
          });
          if (serializedObject)
            search.push(serializedObject);
        } else {
          const serializedPrimitive = serializePrimitiveParam({
            allowReserved,
            name,
            value
          });
          if (serializedPrimitive)
            search.push(serializedPrimitive);
        }
      }
    }
    return search.join("&");
  };
  return querySerializer;
};
var getParseAs = (contentType) => {
  var _a;
  if (!contentType) {
    return "stream";
  }
  const cleanContent = (_a = contentType.split(";")[0]) == null ? void 0 : _a.trim();
  if (!cleanContent) {
    return;
  }
  if (cleanContent.startsWith("application/json") || cleanContent.endsWith("+json")) {
    return "json";
  }
  if (cleanContent === "multipart/form-data") {
    return "formData";
  }
  if (["application/", "audio/", "image/", "video/"].some((type) => cleanContent.startsWith(type))) {
    return "blob";
  }
  if (cleanContent.startsWith("text/")) {
    return "text";
  }
  return;
};
var setAuthParams = async ({ security, ...options }) => {
  for (const auth of security) {
    const token = await getAuthToken(auth, options.auth);
    if (!token) {
      continue;
    }
    const name = auth.name ?? "Authorization";
    switch (auth.in) {
      case "query":
        if (!options.query) {
          options.query = {};
        }
        options.query[name] = token;
        break;
      case "cookie":
        options.headers.append("Cookie", `${name}=${token}`);
        break;
      case "header":
      default:
        options.headers.set(name, token);
        break;
    }
    return;
  }
};
var buildUrl = (options) => {
  const url = getUrl({
    baseUrl: options.baseUrl,
    path: options.path,
    query: options.query,
    querySerializer: typeof options.querySerializer === "function" ? options.querySerializer : createQuerySerializer(options.querySerializer),
    url: options.url
  });
  return url;
};
var getUrl = ({ baseUrl, path, query, querySerializer, url: _url }) => {
  const pathUrl = _url.startsWith("/") ? _url : `/${_url}`;
  let url = (baseUrl ?? "") + pathUrl;
  if (path) {
    url = defaultPathSerializer({ path, url });
  }
  let search = query ? querySerializer(query) : "";
  if (search.startsWith("?")) {
    search = search.substring(1);
  }
  if (search) {
    url += `?${search}`;
  }
  return url;
};
var mergeConfigs = (a, b) => {
  var _a;
  const config = { ...a, ...b };
  if ((_a = config.baseUrl) == null ? void 0 : _a.endsWith("/")) {
    config.baseUrl = config.baseUrl.substring(0, config.baseUrl.length - 1);
  }
  config.headers = mergeHeaders(a.headers, b.headers);
  return config;
};
var mergeHeaders = (...headers) => {
  const mergedHeaders = new Headers();
  for (const header of headers) {
    if (!header || typeof header !== "object") {
      continue;
    }
    const iterator = header instanceof Headers ? header.entries() : Object.entries(header);
    for (const [key, value] of iterator) {
      if (value === null) {
        mergedHeaders.delete(key);
      } else if (Array.isArray(value)) {
        for (const v of value) {
          mergedHeaders.append(key, v);
        }
      } else if (value !== void 0) {
        mergedHeaders.set(key, typeof value === "object" ? JSON.stringify(value) : value);
      }
    }
  }
  return mergedHeaders;
};
var Interceptors = class {
  constructor() {
    Object.defineProperty(this, "_fns", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this._fns = [];
  }
  clear() {
    this._fns = [];
  }
  getInterceptorIndex(id) {
    if (typeof id === "number") {
      return this._fns[id] ? id : -1;
    } else {
      return this._fns.indexOf(id);
    }
  }
  exists(id) {
    const index = this.getInterceptorIndex(id);
    return !!this._fns[index];
  }
  eject(id) {
    const index = this.getInterceptorIndex(id);
    if (this._fns[index]) {
      this._fns[index] = null;
    }
  }
  update(id, fn) {
    const index = this.getInterceptorIndex(id);
    if (this._fns[index]) {
      this._fns[index] = fn;
      return id;
    } else {
      return false;
    }
  }
  use(fn) {
    this._fns = [...this._fns, fn];
    return this._fns.length - 1;
  }
};
var createInterceptors = () => ({
  error: new Interceptors(),
  request: new Interceptors(),
  response: new Interceptors()
});
var defaultQuerySerializer = createQuerySerializer({
  allowReserved: false,
  array: {
    explode: true,
    style: "form"
  },
  object: {
    explode: true,
    style: "deepObject"
  }
});
var defaultHeaders = {
  "Content-Type": "application/json"
};
var createConfig = (override = {}) => ({
  ...jsonBodySerializer,
  headers: defaultHeaders,
  parseAs: "auto",
  querySerializer: defaultQuerySerializer,
  ...override
});

// node_modules/@thirdweb-dev/engine/dist/esm/client/client/client.js
var createClient = (config = {}) => {
  let _config = mergeConfigs(createConfig(), config);
  const getConfig = () => ({ ..._config });
  const setConfig = (config2) => {
    _config = mergeConfigs(_config, config2);
    return getConfig();
  };
  const interceptors = createInterceptors();
  const request = async (options) => {
    const opts = {
      ..._config,
      ...options,
      fetch: options.fetch ?? _config.fetch ?? globalThis.fetch,
      headers: mergeHeaders(_config.headers, options.headers)
    };
    if (opts.security) {
      await setAuthParams({
        ...opts,
        security: opts.security
      });
    }
    if (opts.body && opts.bodySerializer) {
      opts.body = opts.bodySerializer(opts.body);
    }
    if (opts.body === void 0 || opts.body === "") {
      opts.headers.delete("Content-Type");
    }
    const url = buildUrl(opts);
    const requestInit = {
      redirect: "follow",
      ...opts
    };
    let request2 = new Request(url, requestInit);
    for (const fn of interceptors.request._fns) {
      if (fn) {
        request2 = await fn(request2, opts);
      }
    }
    const _fetch = opts.fetch;
    let response = await _fetch(request2);
    for (const fn of interceptors.response._fns) {
      if (fn) {
        response = await fn(response, request2, opts);
      }
    }
    const result = {
      request: request2,
      response
    };
    if (response.ok) {
      if (response.status === 204 || response.headers.get("Content-Length") === "0") {
        return opts.responseStyle === "data" ? {} : {
          data: {},
          ...result
        };
      }
      const parseAs = (opts.parseAs === "auto" ? getParseAs(response.headers.get("Content-Type")) : opts.parseAs) ?? "json";
      let data;
      switch (parseAs) {
        case "arrayBuffer":
        case "blob":
        case "formData":
        case "json":
        case "text":
          data = await response[parseAs]();
          break;
        case "stream":
          return opts.responseStyle === "data" ? response.body : {
            data: response.body,
            ...result
          };
      }
      if (parseAs === "json") {
        if (opts.responseValidator) {
          await opts.responseValidator(data);
        }
        if (opts.responseTransformer) {
          data = await opts.responseTransformer(data);
        }
      }
      return opts.responseStyle === "data" ? data : {
        data,
        ...result
      };
    }
    let error = await response.text();
    try {
      error = JSON.parse(error);
    } catch {
    }
    let finalError = error;
    for (const fn of interceptors.error._fns) {
      if (fn) {
        finalError = await fn(error, response, request2, opts);
      }
    }
    finalError = finalError || {};
    if (opts.throwOnError) {
      throw finalError;
    }
    return opts.responseStyle === "data" ? void 0 : {
      error: finalError,
      ...result
    };
  };
  return {
    buildUrl,
    connect: (options) => request({ ...options, method: "CONNECT" }),
    delete: (options) => request({ ...options, method: "DELETE" }),
    get: (options) => request({ ...options, method: "GET" }),
    getConfig,
    head: (options) => request({ ...options, method: "HEAD" }),
    interceptors,
    options: (options) => request({ ...options, method: "OPTIONS" }),
    patch: (options) => request({ ...options, method: "PATCH" }),
    post: (options) => request({ ...options, method: "POST" }),
    put: (options) => request({ ...options, method: "PUT" }),
    request,
    setConfig,
    trace: (options) => request({ ...options, method: "TRACE" })
  };
};

// node_modules/@thirdweb-dev/engine/dist/esm/client/client.gen.js
var client = createClient(createConfig({
  baseUrl: "https://engine.thirdweb.com"
}));

// node_modules/@thirdweb-dev/engine/dist/esm/client/sdk.gen.js
var sendTransaction2 = (options) => {
  return (options.client ?? client).post({
    security: [
      {
        name: "x-secret-key",
        type: "apiKey"
      }
    ],
    url: "/v1/write/transaction",
    ...options,
    headers: {
      "Content-Type": "application/json",
      ...options.headers
    }
  });
};
var signMessage = (options) => {
  return (options.client ?? client).post({
    security: [
      {
        name: "x-secret-key",
        type: "apiKey"
      }
    ],
    url: "/v1/sign/message",
    ...options,
    headers: {
      "Content-Type": "application/json",
      ...options.headers
    }
  });
};
var signTypedData = (options) => {
  return (options.client ?? client).post({
    security: [
      {
        name: "x-secret-key",
        type: "apiKey"
      }
    ],
    url: "/v1/sign/typed-data",
    ...options,
    headers: {
      "Content-Type": "application/json",
      ...options.headers
    }
  });
};
var listAccounts = (options) => {
  return ((options == null ? void 0 : options.client) ?? client).get({
    security: [
      {
        name: "x-secret-key",
        type: "apiKey"
      }
    ],
    url: "/v1/accounts",
    ...options
  });
};
var createAccount = (options) => {
  return ((options == null ? void 0 : options.client) ?? client).post({
    security: [
      {
        name: "x-secret-key",
        type: "apiKey"
      }
    ],
    url: "/v1/accounts",
    ...options,
    headers: {
      "Content-Type": "application/json",
      ...options == null ? void 0 : options.headers
    }
  });
};
var searchTransactions = (options) => {
  return ((options == null ? void 0 : options.client) ?? client).post({
    security: [
      {
        name: "x-secret-key",
        type: "apiKey"
      }
    ],
    url: "/v1/transactions/search",
    ...options,
    headers: {
      "Content-Type": "application/json",
      ...options == null ? void 0 : options.headers
    }
  });
};

// node_modules/@thirdweb-dev/engine/dist/esm/configure.js
function isSuccessResponse(res) {
  return "result" in res;
}

// node_modules/thirdweb/dist/esm/engine/create-server-wallet.js
async function createServerWallet(params) {
  var _a;
  const { client: client2, label } = params;
  const result = await createAccount({
    baseUrl: getThirdwebBaseUrl("engineCloud"),
    body: {
      label
    },
    bodySerializer: stringify2,
    fetch: getClientFetch(client2)
  });
  if (result.error) {
    throw new Error(`Error creating server wallet with label ${label}: ${stringify2(result.error)}`);
  }
  const data = (_a = result.data) == null ? void 0 : _a.result;
  if (!data) {
    throw new Error(`No server wallet created with label ${label}`);
  }
  return data;
}

// node_modules/thirdweb/dist/esm/engine/get-status.js
async function getTransactionStatus(args) {
  var _a, _b, _c;
  const { client: client2, transactionId } = args;
  const searchResult = await searchTransactions({
    baseUrl: getThirdwebBaseUrl("engineCloud"),
    body: {
      filters: [
        {
          field: "id",
          operation: "OR",
          values: [transactionId]
        }
      ]
    },
    bodySerializer: stringify,
    fetch: getClientFetch(client2)
  });
  if (searchResult.error) {
    throw new Error(`Error searching for transaction ${transactionId}: ${stringify(searchResult.error)}`);
  }
  const data = (_c = (_b = (_a = searchResult.data) == null ? void 0 : _a.result) == null ? void 0 : _b.transactions) == null ? void 0 : _c[0];
  if (!data) {
    throw new Error(`Transaction ${transactionId} not found`);
  }
  const executionResult = data.executionResult;
  return {
    ...executionResult,
    cancelledAt: data.cancelledAt,
    chain: getCachedChain(Number(data.chainId)),
    confirmedAt: data.confirmedAt,
    createdAt: data.createdAt,
    from: data.from ?? void 0,
    id: data.id
  };
}

// node_modules/thirdweb/dist/esm/engine/list-server-wallets.js
async function getServerWallets(params) {
  var _a;
  const { client: client2 } = params;
  const result = await listAccounts({
    baseUrl: getThirdwebBaseUrl("engineCloud"),
    bodySerializer: stringify2,
    fetch: getClientFetch(client2),
    query: {
      limit: params.limit,
      page: params.page
    }
  });
  if (result.error) {
    throw new Error(`Error listing server wallets: ${stringify2(result.error)}`);
  }
  const data = (_a = result.data) == null ? void 0 : _a.result;
  if (!data) {
    throw new Error("No server wallets found");
  }
  return data;
}

// node_modules/thirdweb/dist/esm/engine/search-transactions.js
async function searchTransactions2(args) {
  var _a;
  const { client: client2, filters, pageSize = 100, page = 1 } = args;
  const searchResult = await searchTransactions({
    baseUrl: getThirdwebBaseUrl("engineCloud"),
    body: {
      filters,
      limit: pageSize,
      page
    },
    bodySerializer: stringify,
    fetch: getClientFetch(client2)
  });
  if (searchResult.error) {
    throw new Error(`Error searching for transaction with filters ${stringify(filters)}: ${stringify(searchResult.error)}`);
  }
  const data = (_a = searchResult.data) == null ? void 0 : _a.result;
  if (!data) {
    throw new Error(`No transactions found with filters ${stringify(filters)}`);
  }
  return data;
}

// node_modules/thirdweb/dist/esm/engine/wait-for-tx-hash.js
async function waitForTransactionHash(args) {
  const startTime = Date.now();
  const TIMEOUT_IN_MS = args.timeoutInSeconds ? args.timeoutInSeconds * 1e3 : 5 * 60 * 1e3;
  while (Date.now() - startTime < TIMEOUT_IN_MS) {
    const executionResult = await getTransactionStatus(args);
    const status = executionResult.status;
    switch (status) {
      case "FAILED": {
        throw new Error(`Transaction failed: ${stringify2(executionResult.error) || "Unknown error"}`);
      }
      case "CONFIRMED": {
        const onchainStatus = executionResult && "onchainStatus" in executionResult ? executionResult.onchainStatus : null;
        if (onchainStatus === "REVERTED") {
          const revertData = "revertData" in executionResult ? executionResult.revertData : void 0;
          throw new Error(`Transaction reverted: ${(revertData == null ? void 0 : revertData.errorName) || "unknown error"} ${(revertData == null ? void 0 : revertData.errorArgs) ? stringify2(revertData.errorArgs) : ""} - ${executionResult.transactionHash ? executionResult.transactionHash : ""}`);
        }
        return {
          chain: executionResult.chain,
          client: args.client,
          transactionHash: executionResult.transactionHash
        };
      }
      default: {
        await new Promise((resolve) => setTimeout(resolve, 1e3));
      }
    }
  }
  throw new Error(`Transaction timed out after ${TIMEOUT_IN_MS / 1e3} seconds`);
}

// node_modules/thirdweb/dist/esm/engine/server-wallet.js
function serverWallet(options) {
  const { client: client2, vaultAccessToken, address, chain, executionOptions } = options;
  const headers = vaultAccessToken ? {
    "x-vault-access-token": vaultAccessToken
  } : {};
  const getExecutionOptionsWithChainId = (chainId) => {
    if (!executionOptions) {
      return {
        chainId,
        from: address,
        type: "auto"
      };
    }
    switch (executionOptions.type) {
      case "auto":
        return {
          chainId,
          from: address,
          type: "auto"
        };
      case "ERC4337":
        return {
          ...executionOptions,
          chainId,
          type: "ERC4337"
        };
      case "EOA":
        return {
          chainId,
          from: address,
          type: "EOA"
        };
      case "EIP7702":
        return {
          ...executionOptions,
          chainId,
          type: "EIP7702"
        };
    }
  };
  const getSigningOptions = (chainId) => {
    if (!chainId) {
      return {
        from: address,
        type: "EOA"
      };
    }
    if (!executionOptions) {
      return {
        chainId,
        from: address,
        type: "auto"
      };
    }
    switch (executionOptions.type) {
      case "ERC4337": {
        return {
          chainId,
          ...executionOptions,
          type: "ERC4337"
        };
      }
      case "auto": {
        return {
          chainId,
          from: address,
          type: "auto"
        };
      }
      case "EIP7702":
      case "EOA": {
        return {
          chainId,
          from: address,
          type: "EOA"
        };
      }
    }
  };
  const enqueueTx = async (transaction) => {
    var _a, _b, _c;
    if (transaction.length === 0) {
      throw new Error("No transactions to enqueue");
    }
    const firstTransaction = transaction[0];
    if (!firstTransaction) {
      throw new Error("No transactions to enqueue");
    }
    const chainId = firstTransaction.chainId;
    for (let i = 1; i < transaction.length; i++) {
      if (((_a = transaction[i]) == null ? void 0 : _a.chainId) !== chainId) {
        throw new Error(`All transactions in batch must be on the same chain. Expected ${chainId}, got ${(_b = transaction[i]) == null ? void 0 : _b.chainId} at index ${i}`);
      }
    }
    const body = {
      executionOptions: getExecutionOptionsWithChainId(chainId),
      params: transaction.map((t) => {
        var _a2;
        return {
          data: t.data,
          to: t.to,
          gasLimit: t.gas ? Number(t.gas) : void 0,
          value: (_a2 = t.value) == null ? void 0 : _a2.toString()
        };
      })
    };
    const result = await sendTransaction2({
      baseUrl: getThirdwebBaseUrl("engineCloud"),
      body,
      bodySerializer: stringify,
      fetch: getClientFetch(client2),
      headers
    });
    if (result.error) {
      throw new Error(`Error sending transaction: ${stringify(result.error)}`);
    }
    const data = (_c = result.data) == null ? void 0 : _c.result;
    if (!data) {
      throw new Error("No data returned from engine");
    }
    return data.transactions.map((t) => t.id);
  };
  const getAddress2 = () => {
    if ((executionOptions == null ? void 0 : executionOptions.type) === "ERC4337" && executionOptions.smartAccountAddress) {
      return executionOptions.smartAccountAddress;
    }
    return address;
  };
  return {
    address: getAddress2(),
    enqueueBatchTransaction: async (args) => {
      const serializedTransactions = [];
      for (const transaction of args.transactions) {
        const [to, data, value] = await Promise.all([
          transaction.to ? resolvePromisedValue(transaction.to) : null,
          encode(transaction),
          transaction.value ? resolvePromisedValue(transaction.value) : null
        ]);
        serializedTransactions.push({
          chainId: transaction.chain.id,
          data,
          to: to ?? void 0,
          value: value ?? void 0
        });
      }
      const transactionIds = await enqueueTx(serializedTransactions);
      const transactionId = transactionIds[0];
      if (!transactionId) {
        throw new Error("No transactionId returned from engine");
      }
      return { transactionId };
    },
    enqueueTransaction: async (args) => {
      let serializedTransaction;
      if (args.simulate) {
        serializedTransaction = await toSerializableTransaction({
          transaction: args.transaction
        });
      } else {
        const [to, data, value] = await Promise.all([
          args.transaction.to ? resolvePromisedValue(args.transaction.to) : null,
          encode(args.transaction),
          args.transaction.value ? resolvePromisedValue(args.transaction.value) : null
        ]);
        serializedTransaction = {
          chainId: args.transaction.chain.id,
          data,
          to: to ?? void 0,
          value: value ?? void 0
        };
      }
      const transactionIds = await enqueueTx([serializedTransaction]);
      const transactionId = transactionIds[0];
      if (!transactionId) {
        throw new Error("No transactionId returned from engine");
      }
      return { transactionId };
    },
    sendBatchTransaction: async (transactions) => {
      const transactionIds = await enqueueTx(transactions);
      const transactionId = transactionIds[0];
      if (!transactionId) {
        throw new Error("No transactionId returned from engine");
      }
      return waitForTransactionHash({
        client: client2,
        transactionId
      });
    },
    sendTransaction: async (transaction) => {
      const transactionIds = await enqueueTx([transaction]);
      const transactionId = transactionIds[0];
      if (!transactionId) {
        throw new Error("No transactionId returned from engine");
      }
      return waitForTransactionHash({
        client: client2,
        transactionId
      });
    },
    signMessage: async (data) => {
      var _a;
      const { message, chainId } = data;
      let engineMessage;
      let isBytes = false;
      if (typeof message === "string") {
        engineMessage = message;
      } else {
        engineMessage = toHex(message.raw);
        isBytes = true;
      }
      const signingChainId = chainId || (chain == null ? void 0 : chain.id);
      if (!signingChainId) {
        throw new Error("Chain ID is required for signing messages");
      }
      const signResult = await signMessage({
        baseUrl: getThirdwebBaseUrl("engineCloud"),
        body: {
          params: [
            {
              format: isBytes ? "hex" : "text",
              message: engineMessage
            }
          ],
          signingOptions: getSigningOptions(signingChainId)
        },
        bodySerializer: stringify,
        fetch: getClientFetch(client2),
        headers
      });
      if (signResult.error) {
        throw new Error(`Error signing message: ${stringify(signResult.error)}`);
      }
      const signatureResult = (_a = signResult.data) == null ? void 0 : _a.result[0];
      if (signatureResult && isSuccessResponse(signatureResult)) {
        return signatureResult.result.signature;
      }
      throw new Error(`Failed to sign message: ${stringify(signatureResult == null ? void 0 : signatureResult.error) || "Unknown error"}`);
    },
    signTypedData: async (typedData) => {
      var _a;
      const signingChainId = chain == null ? void 0 : chain.id;
      if (!signingChainId) {
        throw new Error("Chain ID is required for signing messages");
      }
      const signResult = await signTypedData({
        baseUrl: getThirdwebBaseUrl("engineCloud"),
        body: {
          // biome-ignore lint/suspicious/noExplicitAny: TODO: fix ts / hey-api type clash
          params: [typedData],
          signingOptions: getSigningOptions(signingChainId)
        },
        bodySerializer: stringify,
        fetch: getClientFetch(client2),
        headers
      });
      if (signResult.error) {
        throw new Error(`Error signing message: ${stringify(signResult.error)}`);
      }
      const signatureResult = (_a = signResult.data) == null ? void 0 : _a.result[0];
      if (signatureResult && isSuccessResponse(signatureResult)) {
        return signatureResult.result.signature;
      }
      throw new Error(`Failed to sign message: ${stringify(signatureResult == null ? void 0 : signatureResult.error) || "Unknown error"}`);
    }
  };
}

// node_modules/thirdweb/dist/esm/rpc/actions/eth_getBlockByHash.js
async function eth_getBlockByHash(request, params) {
  const includeTransactions = params.includeTransactions ?? false;
  const block = await request({
    method: "eth_getBlockByHash",
    params: [params.blockHash, includeTransactions]
  });
  if (!block) {
    throw new Error("Block not found");
  }
  return formatBlock(block);
}

// node_modules/thirdweb/dist/esm/rpc/actions/eth_getTransactionByHash.js
async function eth_getTransactionByHash(request, params) {
  const receipt = await request({
    method: "eth_getTransactionByHash",
    params: [params.hash]
  });
  if (!receipt) {
    throw new Error("Transaction not found.");
  }
  return formatTransaction(receipt);
}

// node_modules/thirdweb/dist/esm/wallets/in-app/core/users/getUser.js
async function getUser({ client: client2, walletAddress, email, phone, id, externalWalletAddress, ecosystem }) {
  if (!client2.secretKey) {
    throw new Error("A secret key is required to query for users. If you're making this request from the server, please add a secret key to your client.");
  }
  const url = new URL(`${getThirdwebBaseUrl("inAppWallet")}/api/2023-11-30/embedded-wallet/user-details`);
  if (walletAddress) {
    url.searchParams.set("queryBy", "walletAddress");
    url.searchParams.set("walletAddress", walletAddress);
  } else if (email) {
    url.searchParams.set("queryBy", "email");
    url.searchParams.set("email", email);
  } else if (phone) {
    url.searchParams.set("queryBy", "phone");
    url.searchParams.set("phone", phone);
  } else if (id) {
    url.searchParams.set("queryBy", "id");
    url.searchParams.set("id", id);
  } else if (externalWalletAddress) {
    url.searchParams.set("queryBy", "externalWalletAddress");
    url.searchParams.set("externalWalletAddress", externalWalletAddress);
  } else {
    throw new Error("Please provide a walletAddress, email, phone, id, or externalWalletAddress to query for users.");
  }
  const clientFetch = getClientFetch(client2, ecosystem);
  const res = await clientFetch(url.toString());
  if (!res.ok) {
    const error = await res.text().catch(() => "Unknown error");
    throw new Error(`Failed to get profiles. ${res.status} ${res.statusText}: ${error}`);
  }
  const data = await res.json();
  return data.map((item) => ({
    createdAt: item.createdAt,
    email: item.email,
    phone: item.phone,
    profiles: item.linkedAccounts.map((profile) => {
      return {
        details: profile.details,
        type: profile.type === "siwe" ? "wallet" : profile.type
      };
    }),
    smartAccountAddress: item.smartAccountAddress,
    userId: item.userId,
    walletAddress: item.walletAddress
  }))[0] || null;
}

// node_modules/thirdweb/dist/esm/pay/buyWithCrypto/getTransfer.js
async function getBuyWithCryptoTransfer(params) {
  try {
    const tokenContract = getContract({
      address: params.tokenAddress,
      chain: getCachedChain(params.chainId),
      client: params.client
    });
    const tokenDecimals = tokenContract.address.toLowerCase() === NATIVE_TOKEN_ADDRESS ? 18 : await decimals({
      contract: tokenContract
    });
    const amount = Value_exports.from(params.amount, tokenDecimals);
    const quote = await Transfer_exports.prepare({
      amount,
      chainId: params.chainId,
      client: params.client,
      feePayer: params.feePayer,
      paymentLinkId: params.paymentLinkId,
      purchaseData: params.purchaseData,
      receiver: params.toAddress,
      sender: params.fromAddress,
      tokenAddress: params.tokenAddress
    });
    const firstStep = quote.steps[0];
    if (!firstStep) {
      throw new Error("This quote is incompatible with getBuyWithCryptoTransfer. Please use Bridge.Transfer.prepare instead.");
    }
    const approvalTxs = firstStep.transactions.filter((tx2) => tx2.action === "approval");
    if (approvalTxs.length > 1) {
      throw new Error("This quote is incompatible with getBuyWithCryptoTransfer. Please use Bridge.Transfer.prepare instead.");
    }
    const approvalTx = approvalTxs[0];
    let approvalData;
    if (approvalTx) {
      const abiFunction = from([
        "function approve(address spender, uint256 amount)"
      ]);
      const [spender, amount2] = decodeData(abiFunction, approvalTx.data);
      approvalData = {
        amountWei: amount2.toString(),
        chainId: firstStep.originToken.chainId,
        spenderAddress: spender,
        tokenAddress: firstStep.originToken.address
      };
    }
    const txs = firstStep.transactions.filter((tx2) => tx2.action !== "approval");
    if (txs.length > 1) {
      throw new Error("This quote is incompatible with getBuyWithCryptoTransfer. Please use Bridge.Transfer.prepare instead.");
    }
    const tx = txs[0];
    if (!tx) {
      throw new Error("This quote is incompatible with getBuyWithCryptoTransfer. Please use Bridge.Transfer.prepare instead.");
    }
    const transfer = {
      approvalData,
      client: params.client,
      estimatedGasCostUSDCents: 0,
      fromAddress: params.fromAddress,
      paymentToken: {
        amount: Value_exports.format(quote.originAmount, firstStep.originToken.decimals).toString(),
        amountUSDCents: Number(Value_exports.format(quote.originAmount, firstStep.originToken.decimals)) * (firstStep.originToken.prices.USD || 0) * 100,
        amountWei: quote.originAmount.toString(),
        token: {
          chainId: firstStep.originToken.chainId,
          decimals: firstStep.originToken.decimals,
          name: firstStep.originToken.name,
          priceUSDCents: (firstStep.originToken.prices.USD || 0) * 100,
          symbol: firstStep.originToken.symbol,
          tokenAddress: firstStep.originToken.address
        }
      },
      processingFee: {
        amount: params.feePayer === "sender" ? Value_exports.format(quote.originAmount - quote.destinationAmount, firstStep.originToken.decimals).toString() : "0",
        amountUSDCents: params.feePayer === "sender" ? Number(Value_exports.format(quote.originAmount - quote.destinationAmount, firstStep.originToken.decimals)) * (firstStep.originToken.prices.USD || 0) * 100 : 0,
        amountWei: params.feePayer === "sender" ? (quote.originAmount - quote.destinationAmount).toString() : "0",
        token: {
          chainId: firstStep.originToken.chainId,
          decimals: firstStep.originToken.decimals,
          name: firstStep.originToken.name,
          priceUSDCents: (firstStep.originToken.prices.USD || 0) * 100,
          symbol: firstStep.originToken.symbol,
          tokenAddress: firstStep.originToken.address
        }
      },
      toAddress: params.toAddress,
      transactionRequest: {
        ...tx,
        extraGas: 50000n
        // extra gas buffer
      }
    };
    return transfer;
  } catch (error) {
    console.error("Error getting buy with crypto transfer", error);
    throw error;
  }
}

// node_modules/thirdweb/dist/esm/transaction/actions/sign-transaction.js
function signTransaction({ transaction, privateKey }) {
  const serializedTransaction = serializeTransaction({ transaction });
  const signature = sign({
    payload: keccak2562(serializedTransaction),
    privateKey
  });
  return serializeTransaction({
    transaction: { ...transaction, ...signature }
  });
}

// node_modules/thirdweb/dist/esm/transaction/resolve-method.js
function resolveMethod(method) {
  return async (contract) => {
    var _a;
    if (typeof method === "string" && method.startsWith("function ")) {
      return parseAbiItem(method);
    }
    const resolvedAbi = ((_a = contract.abi) == null ? void 0 : _a.length) ? contract.abi : await resolveContractAbi(contract);
    const abiFunction = resolvedAbi.find((item) => {
      if (item.type !== "function") {
        return false;
      }
      return item.name === method;
    });
    if (!abiFunction) {
      throw new Error(`could not find function with name "${method}" in abi`);
    }
    return abiFunction;
  };
}

// node_modules/thirdweb/dist/esm/auth/verify-typed-data.js
async function verifyTypedData({ address, signature, client: client2, chain, accountFactory, message, domain, primaryType, types }) {
  const messageHash = getSignPayload({
    domain,
    message,
    primaryType,
    types
  });
  if (!isHex(signature)) {
    return false;
  }
  try {
    const recoveredAddress = recoverAddress({
      payload: messageHash,
      signature: fromHex2(signature)
    });
    if (recoveredAddress.toLowerCase() === address.toLowerCase()) {
      return true;
    }
  } catch {
  }
  return verifyHash({
    accountFactory,
    address,
    chain,
    client: client2,
    hash: messageHash,
    signature
  });
}

// node_modules/thirdweb/dist/esm/transaction/actions/eip7702/authorization.js
async function signAuthorization(options) {
  const { account, request } = options;
  if (typeof account.signAuthorization === "undefined") {
    throw new Error("This account type does not yet support signing EIP-7702 authorizations");
  }
  return account.signAuthorization(request);
}
export {
  ZERO_ADDRESS as ADDRESS_ZERO,
  bridge_exports as Bridge,
  engine_exports as Engine,
  insight_exports as Insight,
  NATIVE_TOKEN_ADDRESS,
  ZERO_ADDRESS,
  boolToBytes,
  boolToHex,
  bytesToBigInt,
  bytesToBool,
  bytesToNumber,
  bytesToString,
  concatHex,
  createThirdwebClient,
  defineChain,
  deploySmartAccount,
  encode,
  estimateGas,
  estimateGasCost,
  eth_blockNumber,
  eth_call,
  eth_estimateGas,
  eth_gasPrice,
  eth_getBalance,
  eth_getBlockByHash,
  eth_getBlockByNumber,
  eth_getCode,
  eth_getLogs,
  eth_getStorageAt,
  eth_getTransactionByHash,
  eth_getTransactionCount,
  eth_getTransactionReceipt,
  eth_maxPriorityFeePerGas,
  eth_sendRawTransaction,
  fromBytes,
  fromGwei,
  fromHex,
  getAddress,
  getBuyWithCryptoHistory,
  getBuyWithCryptoQuote,
  getBuyWithCryptoStatus,
  getBuyWithCryptoTransfer,
  getContract,
  getContractEvents,
  getGasPrice,
  getRpcClient,
  getUser,
  hexToBigInt,
  hexToBool,
  hexToBytes,
  hexToNumber,
  hexToString,
  hexToUint8Array,
  isAddress,
  isBaseTransactionOptions,
  isHex,
  keccak256,
  numberToBytes,
  numberToHex,
  padHex,
  parseEventLogs,
  prepareContractCall,
  prepareEvent,
  prepareTransaction,
  readContract,
  resolveMethod,
  sendAndConfirmTransaction,
  sendBatchTransaction,
  sendTransaction,
  serializeTransaction,
  sha2562 as sha256,
  signAuthorization,
  signTransaction,
  simulateTransaction,
  stringToBytes,
  stringToHex,
  toBytes,
  toEther,
  toHex,
  toSerializableTransaction,
  toTokens,
  toUnits,
  toWei,
  uint8ArrayToHex,
  verifyTypedData,
  waitForReceipt,
  watchBlockNumber,
  watchContractEvents
};
//# sourceMappingURL=thirdweb.js.map
