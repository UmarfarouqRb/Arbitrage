import {
  getSavedConnectParamsFromStorage,
  saveConnectParamsToStorage
} from "./chunk-NCVQ56IM.js";
import {
  DEFAULT_PROJECT_ID,
  NAMESPACE
} from "./chunk-67YIWUOQ.js";
import {
  formatWalletConnectUrl,
  getWalletInfo
} from "./chunk-BZYSZHWD.js";
import {
  normalizeChainId
} from "./chunk-MQ4Q2WYP.js";
import {
  getDefaultAppMetadata
} from "./chunk-5GPJCQB3.js";
import "./chunk-QDEEV5NE.js";
import {
  parseTypedData
} from "./chunk-DKDKI4EI.js";
import {
  trackTransaction
} from "./chunk-PN6DQXIK.js";
import "./chunk-PANVS3XX.js";
import {
  getTypesForEIP712Domain,
  serializeTypedData,
  validateTypedData
} from "./chunk-YGHTSOJ2.js";
import "./chunk-OM2KKZMP.js";
import {
  SwitchChainError,
  UserRejectedRequestError
} from "./chunk-LPC2L23M.js";
import "./chunk-QMDVOU32.js";
import {
  stringify
} from "./chunk-2CIJO3V3.js";
import {
  getAddress
} from "./chunk-6SVI5C4W.js";
import "./chunk-ESTOX3EM.js";
import {
  numberToHex,
  stringToHex,
  uint8ArrayToHex
} from "./chunk-CCP6WQOA.js";
import "./chunk-HR2UIEMV.js";
import {
  getCachedChain,
  getRpcUrlForChain
} from "./chunk-Z2MF3EIF.js";
import "./chunk-G24WGTAU.js";
import "./chunk-TU6UWWTV.js";
import "./chunk-3OXDSLPJ.js";
import "./chunk-TVKFAMBW.js";
import "./chunk-PPP72TBL.js";
import "./chunk-OS7ZSSJM.js";

// node_modules/thirdweb/dist/esm/wallets/wallet-connect/controller.js
var cachedProvider = null;
var storageKeys = {
  lastUsedChainId: "tw.wc.lastUsedChainId",
  requestedChains: "tw.wc.requestedChains"
};
function isWalletConnect(wallet) {
  return wallet.id === "walletConnect";
}
async function connectWC(options, emitter, walletId, storage, sessionHandler) {
  var _a, _b, _c;
  const provider = await initProvider(options, walletId, sessionHandler);
  const wcOptions = options.walletConnect;
  let { onDisplayUri } = wcOptions || {};
  const walletInfo = await getWalletInfo(walletId);
  if (!onDisplayUri && sessionHandler) {
    const deeplinkHandler = (uri) => {
      const appUrl = walletInfo.mobile.native || walletInfo.mobile.universal;
      if (!appUrl) {
        sessionHandler(uri);
        return;
      }
      const fullUrl = formatWalletConnectUrl(appUrl, uri).redirect;
      sessionHandler(fullUrl);
    };
    onDisplayUri = deeplinkHandler;
  }
  if (onDisplayUri) {
    provider.events.addListener("display_uri", onDisplayUri);
  }
  let optionalChains = wcOptions == null ? void 0 : wcOptions.optionalChains;
  let chainToRequest = options.chain;
  if (walletId === "global.safe") {
    optionalChains = chainsToRequestForSafe.map(getCachedChain);
    if (chainToRequest && !optionalChains.includes(chainToRequest)) {
      chainToRequest = void 0;
    }
  }
  const { chains: chainsToRequest, rpcMap } = getChainsToRequest({
    chain: chainToRequest,
    client: options.client,
    optionalChains
  });
  await provider.connect({
    ...(wcOptions == null ? void 0 : wcOptions.pairingTopic) ? { pairingTopic: wcOptions == null ? void 0 : wcOptions.pairingTopic } : {},
    optionalNamespaces: {
      [NAMESPACE]: {
        chains: chainsToRequest,
        events: ["chainChanged", "accountsChanged"],
        methods: [
          "eth_sendTransaction",
          "eth_signTransaction",
          "eth_sign",
          "personal_sign",
          "eth_signTypedData",
          "eth_signTypedData_v4",
          "wallet_switchEthereumChain",
          "wallet_addEthereumChain"
        ],
        rpcMap
      }
    }
  });
  setRequestedChainsIds(chainsToRequest.map((x) => Number(x.split(":")[1])), storage);
  const currentChainId = ((_a = chainsToRequest[0]) == null ? void 0 : _a.split(":")[1]) || 1;
  const providerChainId = normalizeChainId(currentChainId);
  const account = firstAccountOn(provider.session, `eip155:1`);
  const address = account;
  if (!address) {
    throw new Error("No accounts found on provider.");
  }
  const chain = options.chain && options.chain.id === providerChainId ? options.chain : getCachedChain(providerChainId);
  if (options) {
    const savedParams = {
      chain: options.chain,
      optionalChains: (_b = options.walletConnect) == null ? void 0 : _b.optionalChains,
      pairingTopic: (_c = options.walletConnect) == null ? void 0 : _c.pairingTopic
    };
    if (storage) {
      saveConnectParamsToStorage(storage, walletId, savedParams);
    }
  }
  if (onDisplayUri) {
    provider.events.removeListener("display_uri", onDisplayUri);
  }
  return onConnect(address, chain, provider, emitter, storage, options.client, walletInfo, sessionHandler);
}
async function ensureTargetChain(provider, chain, walletInfo) {
  var _a, _b, _c, _d, _e, _f;
  if (!provider.session) {
    throw new Error("No session found on provider.");
  }
  const TARGET_CAIP = `eip155:${chain.id}`;
  const TARGET_HEX = numberToHex(chain.id);
  if (hasChainEnabled(provider.session, TARGET_CAIP)) {
    provider.setDefaultChain(TARGET_CAIP);
    return;
  }
  try {
    await requestAndOpenWallet({
      provider,
      payload: {
        method: "wallet_switchEthereumChain",
        params: [{ chainId: TARGET_HEX }]
      },
      chain: TARGET_CAIP,
      // route to target
      walletInfo
    });
    provider.setDefaultChain(TARGET_CAIP);
    return;
  } catch (err) {
    const code = (err == null ? void 0 : err.code) ?? ((_b = (_a = err == null ? void 0 : err.data) == null ? void 0 : _a.originalError) == null ? void 0 : _b.code);
    if (code === 4001)
      throw new Error("User rejected chain switch");
  }
  const routeChain = anyRoutableChain(provider.session);
  if (!routeChain)
    throw new Error("No routable chain to send wallet_addEthereumChain");
  try {
    await requestAndOpenWallet({
      provider,
      payload: {
        method: "wallet_addEthereumChain",
        params: [
          {
            chainId: TARGET_HEX,
            chainName: chain.name,
            nativeCurrency: chain.nativeCurrency,
            rpcUrls: [chain.rpc],
            blockExplorerUrls: [((_d = (_c = chain.blockExplorers) == null ? void 0 : _c[0]) == null ? void 0 : _d.url) ?? ""]
          }
        ]
      },
      chain: routeChain,
      // route via known-good chain, not the target
      walletInfo
    });
  } catch (err) {
    const code = (err == null ? void 0 : err.code) ?? ((_f = (_e = err == null ? void 0 : err.data) == null ? void 0 : _e.originalError) == null ? void 0 : _f.code);
    if (code === 4001)
      throw new Error("User rejected add chain");
    throw new Error(`Add chain failed: ${(err == null ? void 0 : err.message) || String(err)}`);
  }
  await requestAndOpenWallet({
    provider,
    payload: {
      method: "wallet_switchEthereumChain",
      params: [{ chainId: TARGET_HEX }]
    },
    chain: TARGET_CAIP,
    walletInfo
  });
  provider.setDefaultChain(TARGET_CAIP);
  if (!hasChainEnabled(provider.session, TARGET_CAIP)) {
    throw new Error("Target chain still not enabled by wallet");
  }
}
function getNS(session) {
  var _a;
  return (_a = session == null ? void 0 : session.namespaces) == null ? void 0 : _a.eip155;
}
function hasChainEnabled(session, caip) {
  var _a;
  const ns = getNS(session);
  return !!((_a = ns == null ? void 0 : ns.accounts) == null ? void 0 : _a.some((a) => a.startsWith(`${caip}:`)));
}
function firstAccountOn(session, caip) {
  var _a;
  const ns = getNS(session);
  const hit = ((_a = ns == null ? void 0 : ns.accounts) == null ? void 0 : _a.find((a) => a.startsWith(`${caip}:`))) || (ns == null ? void 0 : ns.accounts[0]);
  return hit ? hit.split(":")[2] ?? null : null;
}
function anyRoutableChain(session) {
  var _a, _b, _c, _d;
  const ns = getNS(session);
  return ((_d = (_c = (_b = (_a = ns == null ? void 0 : ns.accounts) == null ? void 0 : _a[0]) == null ? void 0 : _b.split(":")) == null ? void 0 : _c.slice(0, 2)) == null ? void 0 : _d.join(":")) ?? null;
}
async function autoConnectWC(options, emitter, walletId, storage, sessionHandler) {
  var _a, _b, _c, _d, _e;
  const savedConnectParams = storage ? await getSavedConnectParamsFromStorage(storage, walletId) : null;
  const walletInfo = await getWalletInfo(walletId);
  const provider = await initProvider(savedConnectParams ? {
    chain: savedConnectParams.chain,
    client: options.client,
    walletConnect: {
      optionalChains: savedConnectParams.optionalChains,
      pairingTopic: savedConnectParams.pairingTopic
    }
  } : {
    client: options.client,
    walletConnect: {}
  }, walletId, sessionHandler);
  if (!provider.session) {
    await provider.disconnect();
    throw new Error("No wallet connect session found on provider.");
  }
  const namespaceAccounts = (_c = (_b = (_a = provider.session) == null ? void 0 : _a.namespaces) == null ? void 0 : _b[NAMESPACE]) == null ? void 0 : _c.accounts;
  const address = (_d = namespaceAccounts == null ? void 0 : namespaceAccounts[0]) == null ? void 0 : _d.split(":")[2];
  if (!address) {
    throw new Error("No accounts found on provider.");
  }
  const currentChainId = ((_e = options.chain) == null ? void 0 : _e.id) || 1;
  const providerChainId = normalizeChainId(currentChainId);
  const chain = options.chain && options.chain.id === providerChainId ? options.chain : getCachedChain(providerChainId);
  return onConnect(address, chain, provider, emitter, storage, options.client, walletInfo, sessionHandler);
}
async function initProvider(options, walletId, sessionRequestHandler) {
  var _a, _b, _c, _d;
  if (cachedProvider) {
    return cachedProvider;
  }
  const walletInfo = await getWalletInfo(walletId);
  const wcOptions = options.walletConnect;
  const { UniversalProvider } = await import("./index.es-XUXCI5LW.js");
  let optionalChains = wcOptions == null ? void 0 : wcOptions.optionalChains;
  let chainToRequest = options.chain;
  if (walletId === "global.safe") {
    optionalChains = chainsToRequestForSafe.map(getCachedChain);
    if (chainToRequest && !optionalChains.includes(chainToRequest)) {
      chainToRequest = void 0;
    }
  }
  const provider = await UniversalProvider.init({
    metadata: {
      description: ((_a = wcOptions == null ? void 0 : wcOptions.appMetadata) == null ? void 0 : _a.description) || getDefaultAppMetadata().description,
      icons: [
        ((_b = wcOptions == null ? void 0 : wcOptions.appMetadata) == null ? void 0 : _b.logoUrl) || getDefaultAppMetadata().logoUrl
      ],
      name: ((_c = wcOptions == null ? void 0 : wcOptions.appMetadata) == null ? void 0 : _c.name) || getDefaultAppMetadata().name,
      url: ((_d = wcOptions == null ? void 0 : wcOptions.appMetadata) == null ? void 0 : _d.url) || getDefaultAppMetadata().url,
      redirect: {
        native: walletInfo.mobile.native || void 0,
        universal: walletInfo.mobile.universal || void 0
      }
    },
    projectId: (wcOptions == null ? void 0 : wcOptions.projectId) || DEFAULT_PROJECT_ID
  });
  provider.events.setMaxListeners(Number.POSITIVE_INFINITY);
  if (walletId !== "walletConnect") {
    async function handleSessionRequest() {
      var _a2, _b2, _c2, _d2;
      const walletLinkToOpen = ((_d2 = (_c2 = (_b2 = (_a2 = provider.session) == null ? void 0 : _a2.peer) == null ? void 0 : _b2.metadata) == null ? void 0 : _c2.redirect) == null ? void 0 : _d2.native) || walletInfo.mobile.native || walletInfo.mobile.universal;
      if (sessionRequestHandler && walletLinkToOpen) {
        await sessionRequestHandler(walletLinkToOpen);
      }
    }
    provider.on("session_request_sent", handleSessionRequest);
    provider.events.addListener("disconnect", () => {
      provider.off("session_request_sent", handleSessionRequest);
      cachedProvider = null;
    });
  }
  cachedProvider = provider;
  return provider;
}
function createAccount({ provider, address, client, chain, sessionRequestHandler, walletInfo }) {
  const account = {
    address: getAddress(address),
    async sendTransaction(tx) {
      const transactionHash = await requestAndOpenWallet({
        provider,
        payload: {
          method: "eth_sendTransaction",
          params: [
            {
              data: tx.data,
              from: getAddress(address),
              gas: tx.gas ? numberToHex(tx.gas) : void 0,
              to: tx.to,
              value: tx.value ? numberToHex(tx.value) : void 0
            }
          ]
        },
        chain: `eip155:${tx.chainId}`,
        walletInfo,
        sessionRequestHandler
      });
      trackTransaction({
        chainId: tx.chainId,
        client,
        contractAddress: tx.to ?? void 0,
        gasPrice: tx.gasPrice,
        transactionHash,
        walletAddress: getAddress(address),
        walletType: "walletConnect"
      });
      return {
        transactionHash
      };
    },
    async signMessage({ message }) {
      const messageToSign = (() => {
        if (typeof message === "string") {
          return stringToHex(message);
        }
        if (message.raw instanceof Uint8Array) {
          return uint8ArrayToHex(message.raw);
        }
        return message.raw;
      })();
      return requestAndOpenWallet({
        provider,
        payload: {
          method: "personal_sign",
          params: [messageToSign, this.address]
        },
        chain: `eip155:${chain.id}`,
        walletInfo,
        sessionRequestHandler
      });
    },
    async signTypedData(_data) {
      const data = parseTypedData(_data);
      const { domain, message, primaryType } = data;
      const types = {
        EIP712Domain: getTypesForEIP712Domain({ domain }),
        ...data.types
      };
      validateTypedData({ domain, message, primaryType, types });
      const typedData = serializeTypedData({
        domain: domain ?? {},
        message,
        primaryType,
        types
      });
      return await requestAndOpenWallet({
        provider,
        payload: {
          method: "eth_signTypedData_v4",
          params: [this.address, typedData]
        },
        chain: `eip155:${chain.id}`,
        walletInfo,
        sessionRequestHandler
      });
    }
  };
  return account;
}
async function requestAndOpenWallet(args) {
  var _a, _b, _c, _d;
  const { provider, payload, chain, walletInfo, sessionRequestHandler } = args;
  const resultPromise = provider.request(payload, chain);
  const walletLinkToOpen = ((_d = (_c = (_b = (_a = provider.session) == null ? void 0 : _a.peer) == null ? void 0 : _b.metadata) == null ? void 0 : _c.redirect) == null ? void 0 : _d.native) || walletInfo.mobile.native || walletInfo.mobile.universal;
  if (sessionRequestHandler && walletLinkToOpen) {
    await sessionRequestHandler(walletLinkToOpen);
  }
  return resultPromise;
}
function onConnect(address, chain, provider, emitter, storage, client, walletInfo, sessionRequestHandler) {
  const account = createAccount({
    address,
    chain,
    client,
    provider,
    sessionRequestHandler,
    walletInfo
  });
  async function disconnect() {
    provider.removeListener("accountsChanged", onAccountsChanged);
    provider.removeListener("chainChanged", onChainChanged);
    provider.removeListener("disconnect", onDisconnect);
    await provider.disconnect();
    cachedProvider = null;
  }
  function onDisconnect() {
    setRequestedChainsIds([], storage);
    storage == null ? void 0 : storage.removeItem(storageKeys.lastUsedChainId);
    disconnect();
    emitter.emit("disconnect", void 0);
  }
  function onAccountsChanged(accounts) {
    if (accounts[0]) {
      const newAccount = createAccount({
        address: getAddress(accounts[0]),
        chain,
        client,
        provider,
        sessionRequestHandler,
        walletInfo
      });
      emitter.emit("accountChanged", newAccount);
      emitter.emit("accountsChanged", accounts);
    } else {
      onDisconnect();
    }
  }
  function onChainChanged(newChainId) {
    const newChain = getCachedChain(normalizeChainId(newChainId));
    emitter.emit("chainChanged", newChain);
    storage == null ? void 0 : storage.setItem(storageKeys.lastUsedChainId, String(newChainId));
  }
  provider.on("accountsChanged", onAccountsChanged);
  provider.on("chainChanged", onChainChanged);
  provider.on("disconnect", onDisconnect);
  provider.on("session_delete", onDisconnect);
  return [
    account,
    chain,
    disconnect,
    (newChain) => switchChainWC(provider, newChain, walletInfo)
  ];
}
async function switchChainWC(provider, chain, walletInfo) {
  try {
    await ensureTargetChain(provider, chain, walletInfo);
  } catch (error) {
    const message = typeof error === "string" ? error : error == null ? void 0 : error.message;
    if (/user rejected request/i.test(message)) {
      throw new UserRejectedRequestError(error);
    }
    throw new SwitchChainError(error);
  }
}
function setRequestedChainsIds(chains, storage) {
  storage == null ? void 0 : storage.setItem(storageKeys.requestedChains, stringify(chains));
}
function getChainsToRequest(options) {
  const rpcMap = {};
  const chainIds = [];
  if (options.chain) {
    rpcMap[options.chain.id] = getRpcUrlForChain({
      chain: options.chain,
      client: options.client
    });
    chainIds.push(options.chain.id);
  }
  const optionalChains = ((options == null ? void 0 : options.optionalChains) || []).slice(0, 10);
  for (const chain of optionalChains) {
    rpcMap[chain.id] = getRpcUrlForChain({
      chain,
      client: options.client
    });
    chainIds.push(chain.id);
  }
  if (!chainIds.includes(1)) {
    rpcMap[1] = getCachedChain(1).rpc;
    chainIds.push(1);
  }
  return {
    chains: chainIds.map((x) => `eip155:${x}`),
    rpcMap
  };
}
var chainsToRequestForSafe = [
  1,
  // Ethereum Mainnet
  11155111,
  // Sepolia Testnet
  42161,
  // Arbitrum One Mainnet
  43114,
  // Avalanche Mainnet
  8453,
  // Base Mainnet
  1313161554,
  // Aurora Mainnet
  84532,
  // Base Sepolia Testnet
  56,
  // Binance Smart Chain Mainnet
  42220,
  // Celo Mainnet
  100,
  // Gnosis Mainnet
  10,
  // Optimism Mainnet
  137,
  // Polygon Mainnet
  1101,
  // Polygon zkEVM Mainnet
  324,
  // zkSync Era mainnet
  534352
  // Scroll mainnet
];
export {
  autoConnectWC,
  connectWC,
  isWalletConnect
};
//# sourceMappingURL=controller-PAP76FG4.js.map
