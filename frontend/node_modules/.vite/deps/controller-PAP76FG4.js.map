{
  "version": 3,
  "sources": ["../../thirdweb/src/wallets/wallet-connect/controller.ts"],
  "sourcesContent": ["import type {\n  RequestArguments,\n  UniversalProvider,\n} from \"@walletconnect/universal-provider\";\nimport type { Address } from \"abitype\";\nimport {\n  getTypesForEIP712Domain,\n  type ProviderRpcError,\n  type SignTypedDataParameters,\n  SwitchChainError,\n  serializeTypedData,\n  UserRejectedRequestError,\n  validateTypedData,\n} from \"viem\";\nimport { trackTransaction } from \"../../analytics/track/transaction.js\";\nimport type { Chain } from \"../../chains/types.js\";\nimport { getCachedChain, getRpcUrlForChain } from \"../../chains/utils.js\";\nimport type { ThirdwebClient } from \"../../client/client.js\";\nimport { getAddress } from \"../../utils/address.js\";\nimport {\n  type Hex,\n  numberToHex,\n  stringToHex,\n  uint8ArrayToHex,\n} from \"../../utils/encoding/hex.js\";\nimport { stringify } from \"../../utils/json.js\";\nimport { parseTypedData } from \"../../utils/signatures/helpers/parse-typed-data.js\";\nimport type { AsyncStorage } from \"../../utils/storage/AsyncStorage.js\";\nimport {\n  getSavedConnectParamsFromStorage,\n  saveConnectParamsToStorage,\n} from \"../../utils/storage/walletStorage.js\";\nimport { formatWalletConnectUrl } from \"../../utils/url.js\";\nimport { getWalletInfo } from \"../__generated__/getWalletInfo.js\";\nimport type { WCSupportedWalletIds } from \"../__generated__/wallet-ids.js\";\nimport type {\n  Account,\n  SendTransactionOption,\n  Wallet,\n} from \"../interfaces/wallet.js\";\nimport type { DisconnectFn, SwitchChainFn } from \"../types.js\";\nimport { getDefaultAppMetadata } from \"../utils/defaultDappMetadata.js\";\nimport { normalizeChainId } from \"../utils/normalizeChainId.js\";\nimport type { WalletEmitter } from \"../wallet-emitter.js\";\nimport type { WalletInfo } from \"../wallet-info.js\";\nimport type { WalletId } from \"../wallet-types.js\";\nimport { DEFAULT_PROJECT_ID, NAMESPACE } from \"./constants.js\";\nimport type { WCAutoConnectOptions, WCConnectOptions } from \"./types.js\";\n\ntype WCProvider = InstanceType<typeof UniversalProvider>;\n\nlet cachedProvider: WCProvider | null = null;\n\ntype SavedConnectParams = {\n  optionalChains?: Chain[];\n  chain?: Chain;\n  pairingTopic?: string;\n};\n\nconst storageKeys = {\n  lastUsedChainId: \"tw.wc.lastUsedChainId\",\n  requestedChains: \"tw.wc.requestedChains\",\n};\n\n/**\n * Checks if the provided wallet is a Wallet Connect wallet.\n *\n * @param wallet - The wallet to check.\n * @returns True if the wallet is a Wallet Connect wallet, false otherwise.\n */\nexport function isWalletConnect(\n  wallet: Wallet<WalletId>,\n): wallet is Wallet<\"walletConnect\"> {\n  return wallet.id === \"walletConnect\";\n}\n\n/**\n * @internal\n */\nexport async function connectWC(\n  options: WCConnectOptions,\n  emitter: WalletEmitter<WCSupportedWalletIds>,\n  walletId: WCSupportedWalletIds | \"walletConnect\",\n  storage: AsyncStorage,\n  sessionHandler?: (uri: string) => void | Promise<void>,\n): Promise<ReturnType<typeof onConnect>> {\n  const provider = await initProvider(options, walletId, sessionHandler);\n  const wcOptions = options.walletConnect;\n\n  let { onDisplayUri } = wcOptions || {};\n  const walletInfo = await getWalletInfo(walletId);\n\n  // use default sessionHandler unless onDisplayUri is explicitly provided\n  if (!onDisplayUri && sessionHandler) {\n    const deeplinkHandler = (uri: string) => {\n      const appUrl = walletInfo.mobile.native || walletInfo.mobile.universal;\n      if (!appUrl) {\n        // generic wc uri\n        sessionHandler(uri);\n        return;\n      }\n      const fullUrl = formatWalletConnectUrl(appUrl, uri).redirect;\n      sessionHandler(fullUrl);\n    };\n    onDisplayUri = deeplinkHandler;\n  }\n\n  if (onDisplayUri) {\n    provider.events.addListener(\"display_uri\", onDisplayUri);\n  }\n\n  let optionalChains: Chain[] | undefined = wcOptions?.optionalChains;\n  let chainToRequest = options.chain;\n\n  // ignore the given options chains - and set the safe supported chains\n  if (walletId === \"global.safe\") {\n    optionalChains = chainsToRequestForSafe.map(getCachedChain);\n    if (chainToRequest && !optionalChains.includes(chainToRequest)) {\n      chainToRequest = undefined;\n    }\n  }\n\n  // For UniversalProvider, we still need chain configuration for session management\n  const { chains: chainsToRequest, rpcMap } = getChainsToRequest({\n    chain: chainToRequest,\n    client: options.client,\n    optionalChains: optionalChains,\n  });\n\n  // For UniversalProvider, we need to connect with namespaces\n  await provider.connect({\n    ...(wcOptions?.pairingTopic\n      ? { pairingTopic: wcOptions?.pairingTopic }\n      : {}),\n    optionalNamespaces: {\n      [NAMESPACE]: {\n        chains: chainsToRequest,\n        events: [\"chainChanged\", \"accountsChanged\"],\n        methods: [\n          \"eth_sendTransaction\",\n          \"eth_signTransaction\",\n          \"eth_sign\",\n          \"personal_sign\",\n          \"eth_signTypedData\",\n          \"eth_signTypedData_v4\",\n          \"wallet_switchEthereumChain\",\n          \"wallet_addEthereumChain\",\n        ],\n        rpcMap,\n      },\n    },\n  });\n\n  setRequestedChainsIds(\n    chainsToRequest.map((x) => Number(x.split(\":\")[1])),\n    storage,\n  );\n  const currentChainId = chainsToRequest[0]?.split(\":\")[1] || 1;\n  const providerChainId = normalizeChainId(currentChainId);\n  const account = firstAccountOn(provider.session, `eip155:1`); // grab the address from mainnet if available\n  const address = account;\n  if (!address) {\n    throw new Error(\"No accounts found on provider.\");\n  }\n\n  const chain =\n    options.chain && options.chain.id === providerChainId\n      ? options.chain\n      : getCachedChain(providerChainId);\n\n  if (options) {\n    const savedParams: SavedConnectParams = {\n      chain: options.chain,\n      optionalChains: options.walletConnect?.optionalChains,\n      pairingTopic: options.walletConnect?.pairingTopic,\n    };\n\n    if (storage) {\n      saveConnectParamsToStorage(storage, walletId, savedParams);\n    }\n  }\n\n  if (onDisplayUri) {\n    provider.events.removeListener(\"display_uri\", onDisplayUri);\n  }\n\n  return onConnect(\n    address,\n    chain,\n    provider,\n    emitter,\n    storage,\n    options.client,\n    walletInfo,\n    sessionHandler,\n  );\n}\n\nasync function ensureTargetChain(\n  provider: Awaited<ReturnType<typeof initProvider>>,\n  chain: Chain,\n  walletInfo: WalletInfo,\n) {\n  if (!provider.session) {\n    throw new Error(\"No session found on provider.\");\n  }\n  const TARGET_CAIP = `eip155:${chain.id}`;\n  const TARGET_HEX = numberToHex(chain.id);\n\n  // Fast path: already enabled\n  if (hasChainEnabled(provider.session, TARGET_CAIP)) {\n    provider.setDefaultChain(TARGET_CAIP);\n    return;\n  }\n\n  // 1) Try switch\n  try {\n    await requestAndOpenWallet({\n      provider,\n      payload: {\n        method: \"wallet_switchEthereumChain\",\n        params: [{ chainId: TARGET_HEX }],\n      },\n      chain: TARGET_CAIP, // route to target\n      walletInfo,\n    });\n    provider.setDefaultChain(TARGET_CAIP);\n    return;\n  } catch (err: any) {\n    const code = err?.code ?? err?.data?.originalError?.code;\n    // 4001 user rejected; stop\n    if (code === 4001) throw new Error(\"User rejected chain switch\");\n    // fall through on 4902 or unknown -> try add\n  }\n\n  // 2) Add the chain via any chain we already have\n  const routeChain = anyRoutableChain(provider.session);\n  if (!routeChain)\n    throw new Error(\"No routable chain to send wallet_addEthereumChain\");\n\n  try {\n    await requestAndOpenWallet({\n      provider,\n      payload: {\n        method: \"wallet_addEthereumChain\",\n        params: [\n          {\n            chainId: TARGET_HEX,\n            chainName: chain.name,\n            nativeCurrency: chain.nativeCurrency,\n            rpcUrls: [chain.rpc],\n            blockExplorerUrls: [chain.blockExplorers?.[0]?.url ?? \"\"],\n          },\n        ],\n      },\n      chain: routeChain, // route via known-good chain, not the target\n      walletInfo,\n    });\n  } catch (err: any) {\n    const code = err?.code ?? err?.data?.originalError?.code;\n    if (code === 4001) throw new Error(\"User rejected add chain\");\n    throw new Error(`Add chain failed: ${err?.message || String(err)}`);\n  }\n\n  // 3) Re-try switch after add\n  await requestAndOpenWallet({\n    provider,\n    payload: {\n      method: \"wallet_switchEthereumChain\",\n      params: [{ chainId: TARGET_HEX }],\n    },\n    chain: TARGET_CAIP,\n    walletInfo,\n  });\n  provider.setDefaultChain(TARGET_CAIP);\n\n  // 4) Verify enablement\n  if (!hasChainEnabled(provider.session, TARGET_CAIP)) {\n    throw new Error(\"Target chain still not enabled by wallet\");\n  }\n}\n\ntype WCSession = Awaited<ReturnType<typeof UniversalProvider.init>>[\"session\"];\n\nfunction getNS(session: WCSession) {\n  return session?.namespaces?.eip155;\n}\nfunction hasChainEnabled(session: WCSession, caip: string) {\n  const ns = getNS(session);\n  return !!ns?.accounts?.some((a) => a.startsWith(`${caip}:`));\n}\nfunction firstAccountOn(session: WCSession, caip: string): string | null {\n  const ns = getNS(session);\n  const hit =\n    ns?.accounts?.find((a) => a.startsWith(`${caip}:`)) || ns?.accounts[0];\n  return hit ? (hit.split(\":\")[2] ?? null) : null;\n}\nfunction anyRoutableChain(session: WCSession): string | null {\n  const ns = getNS(session);\n  return ns?.accounts?.[0]?.split(\":\")?.slice(0, 2)?.join(\":\") ?? null; // e.g. \"eip155:1\"\n}\n\n/**\n * Auto connect to already connected wallet connect session.\n * @internal\n */\nexport async function autoConnectWC(\n  options: WCAutoConnectOptions,\n  emitter: WalletEmitter<WCSupportedWalletIds>,\n  walletId: WCSupportedWalletIds | \"walletConnect\",\n  storage: AsyncStorage,\n  sessionHandler?: (uri: string) => void | Promise<void>,\n): Promise<ReturnType<typeof onConnect>> {\n  const savedConnectParams: SavedConnectParams | null = storage\n    ? await getSavedConnectParamsFromStorage(storage, walletId)\n    : null;\n\n  const walletInfo = await getWalletInfo(walletId);\n\n  const provider = await initProvider(\n    savedConnectParams\n      ? {\n          chain: savedConnectParams.chain,\n          client: options.client,\n          walletConnect: {\n            optionalChains: savedConnectParams.optionalChains,\n            pairingTopic: savedConnectParams.pairingTopic,\n          },\n        }\n      : {\n          client: options.client,\n          walletConnect: {},\n        },\n    walletId,\n    sessionHandler,\n  );\n\n  if (!provider.session) {\n    await provider.disconnect();\n    throw new Error(\"No wallet connect session found on provider.\");\n  }\n\n  // For UniversalProvider, get accounts from enable() method\n  const namespaceAccounts = provider.session?.namespaces?.[NAMESPACE]?.accounts;\n  const address = namespaceAccounts?.[0]?.split(\":\")[2];\n\n  if (!address) {\n    throw new Error(\"No accounts found on provider.\");\n  }\n\n  // For UniversalProvider, get chainId from the session namespaces or use default\n  const currentChainId = options.chain?.id || 1;\n  const providerChainId = normalizeChainId(currentChainId);\n\n  const chain =\n    options.chain && options.chain.id === providerChainId\n      ? options.chain\n      : getCachedChain(providerChainId);\n\n  return onConnect(\n    address,\n    chain,\n    provider,\n    emitter,\n    storage,\n    options.client,\n    walletInfo,\n    sessionHandler,\n  );\n}\n\n// Connection utils -----------------------------------------------------------------------------------------------\n\nasync function initProvider(\n  options: WCConnectOptions,\n  walletId: WCSupportedWalletIds | \"walletConnect\",\n  sessionRequestHandler?: (uri: string) => void | Promise<void>,\n) {\n  if (cachedProvider) {\n    return cachedProvider;\n  }\n\n  const walletInfo = await getWalletInfo(walletId);\n  const wcOptions = options.walletConnect;\n  const { UniversalProvider } = await import(\n    \"@walletconnect/universal-provider\"\n  );\n\n  let optionalChains: Chain[] | undefined = wcOptions?.optionalChains;\n  let chainToRequest = options.chain;\n\n  // ignore the given options chains - and set the safe supported chains\n  if (walletId === \"global.safe\") {\n    optionalChains = chainsToRequestForSafe.map(getCachedChain);\n    if (chainToRequest && !optionalChains.includes(chainToRequest)) {\n      chainToRequest = undefined;\n    }\n  }\n\n  const provider = await UniversalProvider.init({\n    metadata: {\n      description:\n        wcOptions?.appMetadata?.description ||\n        getDefaultAppMetadata().description,\n      icons: [\n        wcOptions?.appMetadata?.logoUrl || getDefaultAppMetadata().logoUrl,\n      ],\n      name: wcOptions?.appMetadata?.name || getDefaultAppMetadata().name,\n      url: wcOptions?.appMetadata?.url || getDefaultAppMetadata().url,\n      redirect: {\n        native: walletInfo.mobile.native || undefined,\n        universal: walletInfo.mobile.universal || undefined,\n      },\n    },\n    projectId: wcOptions?.projectId || DEFAULT_PROJECT_ID,\n  });\n\n  provider.events.setMaxListeners(Number.POSITIVE_INFINITY);\n\n  if (walletId !== \"walletConnect\") {\n    async function handleSessionRequest() {\n      const walletLinkToOpen =\n        provider.session?.peer?.metadata?.redirect?.native ||\n        walletInfo.mobile.native ||\n        walletInfo.mobile.universal;\n\n      if (sessionRequestHandler && walletLinkToOpen) {\n        // TODO: propagate error when this fails\n        await sessionRequestHandler(walletLinkToOpen);\n      }\n    }\n\n    // For UniversalProvider, use different event handling\n    provider.on(\"session_request_sent\", handleSessionRequest);\n    provider.events.addListener(\"disconnect\", () => {\n      provider.off(\"session_request_sent\", handleSessionRequest);\n      cachedProvider = null;\n    });\n  }\n\n  cachedProvider = provider;\n\n  return provider;\n}\n\nfunction createAccount({\n  provider,\n  address,\n  client,\n  chain,\n  sessionRequestHandler,\n  walletInfo,\n}: {\n  provider: WCProvider;\n  address: string;\n  client: ThirdwebClient;\n  chain: Chain;\n  sessionRequestHandler?: (uri: string) => void | Promise<void>;\n  walletInfo: WalletInfo;\n}) {\n  const account: Account = {\n    address: getAddress(address),\n    async sendTransaction(tx: SendTransactionOption) {\n      const transactionHash = (await requestAndOpenWallet({\n        provider,\n        payload: {\n          method: \"eth_sendTransaction\",\n          params: [\n            {\n              data: tx.data,\n              from: getAddress(address),\n              gas: tx.gas ? numberToHex(tx.gas) : undefined,\n              to: tx.to as Address,\n              value: tx.value ? numberToHex(tx.value) : undefined,\n            },\n          ],\n        },\n        chain: `eip155:${tx.chainId}`,\n        walletInfo,\n        sessionRequestHandler,\n      })) as Hex;\n\n      trackTransaction({\n        chainId: tx.chainId,\n        client: client,\n        contractAddress: tx.to ?? undefined,\n        gasPrice: tx.gasPrice,\n        transactionHash,\n        walletAddress: getAddress(address),\n        walletType: \"walletConnect\",\n      });\n\n      return {\n        transactionHash,\n      };\n    },\n    async signMessage({ message }) {\n      const messageToSign = (() => {\n        if (typeof message === \"string\") {\n          return stringToHex(message);\n        }\n        if (message.raw instanceof Uint8Array) {\n          return uint8ArrayToHex(message.raw);\n        }\n        return message.raw;\n      })();\n      return requestAndOpenWallet({\n        provider,\n        payload: {\n          method: \"personal_sign\",\n          params: [messageToSign, this.address],\n        },\n        chain: `eip155:${chain.id}`,\n        walletInfo,\n        sessionRequestHandler,\n      });\n    },\n    async signTypedData(_data) {\n      const data = parseTypedData(_data);\n      const { domain, message, primaryType } =\n        data as unknown as SignTypedDataParameters;\n\n      const types = {\n        EIP712Domain: getTypesForEIP712Domain({ domain }),\n        ...data.types,\n      };\n\n      // Need to do a runtime validation check on addresses, byte ranges, integer ranges, etc\n      // as we can't statically check this with TypeScript.\n      validateTypedData({ domain, message, primaryType, types });\n\n      const typedData = serializeTypedData({\n        domain: domain ?? {},\n        message,\n        primaryType,\n        types,\n      });\n\n      return await requestAndOpenWallet({\n        provider,\n        payload: {\n          method: \"eth_signTypedData_v4\",\n          params: [this.address, typedData],\n        },\n        chain: `eip155:${chain.id}`,\n        walletInfo,\n        sessionRequestHandler,\n      });\n    },\n  };\n\n  return account;\n}\n\nasync function requestAndOpenWallet(args: {\n  provider: WCProvider;\n  payload: RequestArguments;\n  chain?: string;\n  walletInfo: WalletInfo;\n  sessionRequestHandler?: (uri: string) => void | Promise<void>;\n}) {\n  const { provider, payload, chain, walletInfo, sessionRequestHandler } = args;\n  const resultPromise: Promise<`0x${string}`> = provider.request(\n    payload,\n    chain,\n  );\n\n  const walletLinkToOpen =\n    provider.session?.peer?.metadata?.redirect?.native ||\n    walletInfo.mobile.native ||\n    walletInfo.mobile.universal;\n\n  if (sessionRequestHandler && walletLinkToOpen) {\n    await sessionRequestHandler(walletLinkToOpen);\n  }\n\n  return resultPromise;\n}\n\nfunction onConnect(\n  address: string,\n  chain: Chain,\n  provider: WCProvider,\n  emitter: WalletEmitter<WCSupportedWalletIds>,\n  storage: AsyncStorage,\n  client: ThirdwebClient,\n  walletInfo: WalletInfo,\n  sessionRequestHandler?: (uri: string) => void | Promise<void>,\n): [Account, Chain, DisconnectFn, SwitchChainFn] {\n  const account = createAccount({\n    address,\n    chain,\n    client,\n    provider,\n    sessionRequestHandler,\n    walletInfo,\n  });\n\n  async function disconnect() {\n    provider.removeListener(\"accountsChanged\", onAccountsChanged);\n    provider.removeListener(\"chainChanged\", onChainChanged);\n    provider.removeListener(\"disconnect\", onDisconnect);\n    await provider.disconnect();\n    cachedProvider = null;\n  }\n\n  function onDisconnect() {\n    setRequestedChainsIds([], storage);\n    storage?.removeItem(storageKeys.lastUsedChainId);\n    disconnect();\n    emitter.emit(\"disconnect\", undefined);\n  }\n\n  function onAccountsChanged(accounts: string[]) {\n    if (accounts[0]) {\n      const newAccount = createAccount({\n        address: getAddress(accounts[0]),\n        chain,\n        client,\n        provider,\n        sessionRequestHandler,\n        walletInfo,\n      });\n      emitter.emit(\"accountChanged\", newAccount);\n      emitter.emit(\"accountsChanged\", accounts);\n    } else {\n      onDisconnect();\n    }\n  }\n\n  function onChainChanged(newChainId: string) {\n    const newChain = getCachedChain(normalizeChainId(newChainId));\n    emitter.emit(\"chainChanged\", newChain);\n    storage?.setItem(storageKeys.lastUsedChainId, String(newChainId));\n  }\n\n  provider.on(\"accountsChanged\", onAccountsChanged);\n  provider.on(\"chainChanged\", onChainChanged);\n  provider.on(\"disconnect\", onDisconnect);\n  provider.on(\"session_delete\", onDisconnect);\n\n  return [\n    account,\n    chain,\n    disconnect,\n    (newChain) => switchChainWC(provider, newChain, walletInfo),\n  ];\n}\n\nasync function switchChainWC(\n  provider: WCProvider,\n  chain: Chain,\n  walletInfo: WalletInfo,\n) {\n  try {\n    await ensureTargetChain(provider, chain, walletInfo);\n  } catch (error) {\n    const message =\n      typeof error === \"string\" ? error : (error as ProviderRpcError)?.message;\n    if (/user rejected request/i.test(message)) {\n      throw new UserRejectedRequestError(error as Error);\n    }\n\n    throw new SwitchChainError(error as Error);\n  }\n}\n\n/**\n * Set the requested chains to the storage.\n * @internal\n */\nfunction setRequestedChainsIds(\n  chains: number[] | undefined,\n  storage: AsyncStorage,\n) {\n  storage?.setItem(storageKeys.requestedChains, stringify(chains));\n}\n\nfunction getChainsToRequest(options: {\n  chain?: Chain;\n  optionalChains?: Chain[];\n  client: ThirdwebClient;\n}): {\n  rpcMap: Record<number, string>;\n  chains: string[];\n} {\n  const rpcMap: Record<number, string> = {};\n  const chainIds: number[] = [];\n\n  if (options.chain) {\n    rpcMap[options.chain.id] = getRpcUrlForChain({\n      chain: options.chain,\n      client: options.client,\n    });\n    chainIds.push(options.chain.id);\n  }\n\n  // limit optional chains to 10\n  const optionalChains = (options?.optionalChains || []).slice(0, 10);\n\n  for (const chain of optionalChains) {\n    rpcMap[chain.id] = getRpcUrlForChain({\n      chain: chain,\n      client: options.client,\n    });\n    chainIds.push(chain.id);\n  }\n\n  // always include mainnet\n  // many wallets only support a handful of chains, but mainnet is always supported\n  // we will add additional chains in switchChain if needed\n  if (!chainIds.includes(1)) {\n    rpcMap[1] = getCachedChain(1).rpc;\n    chainIds.push(1);\n  }\n\n  return {\n    chains: chainIds.map((x) => `eip155:${x}`),\n    rpcMap,\n  };\n}\n\nconst chainsToRequestForSafe = [\n  1, // Ethereum Mainnet\n  11155111, // Sepolia Testnet\n  42161, // Arbitrum One Mainnet\n  43114, // Avalanche Mainnet\n  8453, // Base Mainnet\n  1313161554, // Aurora Mainnet\n  84532, // Base Sepolia Testnet\n  56, // Binance Smart Chain Mainnet\n  42220, // Celo Mainnet\n  100, // Gnosis Mainnet\n  10, // Optimism Mainnet\n  137, // Polygon Mainnet\n  1101, // Polygon zkEVM Mainnet\n  324, // zkSync Era mainnet\n  534352, // Scroll mainnet\n];\n"],
  "mappings": "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",
  "names": ["_a", "_b", "_c", "_d"]
}
