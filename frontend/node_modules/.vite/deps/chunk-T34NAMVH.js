import {
  normalizeChainId
} from "./chunk-MQ4Q2WYP.js";
import {
  getDefaultAppMetadata
} from "./chunk-5GPJCQB3.js";
import {
  parseTypedData
} from "./chunk-DKDKI4EI.js";
import {
  showCoinbasePopup
} from "./chunk-LWBFBP2R.js";
import {
  extractEip712DomainTypes,
  serialize,
  validate as validate2
} from "./chunk-FXH2AAXJ.js";
import {
  trackTransaction
} from "./chunk-PN6DQXIK.js";
import {
  resolvePromisedValue
} from "./chunk-L4NN5UUQ.js";
import {
  encode
} from "./chunk-QFKZXB2I.js";
import {
  stringify
} from "./chunk-2CIJO3V3.js";
import {
  getAddress
} from "./chunk-6SVI5C4W.js";
import {
  hexToBigInt,
  hexToNumber,
  numberToHex,
  stringToHex,
  uint8ArrayToHex
} from "./chunk-CCP6WQOA.js";
import {
  validate
} from "./chunk-HR2UIEMV.js";
import {
  getCachedChain,
  getChainMetadata
} from "./chunk-Z2MF3EIF.js";

// node_modules/thirdweb/dist/esm/wallets/constants.js
var COINBASE = "com.coinbase.wallet";
var METAMASK = "io.metamask";
var RAINBOW = "me.rainbow";
var ZERION = "io.zerion.wallet";
var NON_SEARCHABLE_WALLETS = [
  "inApp",
  "embedded",
  "smart",
  "xyz.abs"
];

// node_modules/thirdweb/dist/esm/wallets/eip5792/get-calls-status.js
async function getCallsStatus({ wallet, client, id }) {
  const account = wallet.getAccount();
  if (!account) {
    throw new Error(`Failed to get call status, no account found for wallet ${wallet.id}`);
  }
  const chain = wallet.getChain();
  if (!chain) {
    throw new Error(`Failed to get call status, no chain found for wallet ${wallet.id}`);
  }
  if (account.getCallsStatus) {
    return account.getCallsStatus({ id, chain, client });
  }
  throw new Error(`Failed to get call status, wallet ${wallet.id} does not support EIP-5792`);
}
var receiptStatuses = {
  "0x0": "reverted",
  "0x1": "success"
};
function toGetCallsStatusResponse(response) {
  var _a;
  const [status, statusCode] = (() => {
    const statusCode2 = response.status;
    if (statusCode2 >= 100 && statusCode2 < 200)
      return ["pending", statusCode2];
    if (statusCode2 >= 200 && statusCode2 < 300)
      return ["success", statusCode2];
    if (statusCode2 >= 300 && statusCode2 < 700)
      return ["failure", statusCode2];
    if (statusCode2 === "CONFIRMED")
      return ["success", 200];
    if (statusCode2 === "PENDING")
      return ["pending", 100];
    return [void 0, statusCode2];
  })();
  return {
    ...response,
    atomic: response.atomic,
    // @ts-expect-error: for backwards compatibility
    chainId: response.chainId ? hexToNumber(response.chainId) : void 0,
    receipts: ((_a = response.receipts) == null ? void 0 : _a.map((receipt) => ({
      ...receipt,
      blockNumber: hexToBigInt(receipt.blockNumber),
      gasUsed: hexToBigInt(receipt.gasUsed),
      status: receiptStatuses[receipt.status]
    }))) ?? [],
    status,
    statusCode,
    version: response.version
  };
}

// node_modules/thirdweb/dist/esm/wallets/eip5792/get-capabilities.js
async function getCapabilities({ wallet, chainId }) {
  const account = wallet.getAccount();
  if (!account) {
    return {
      message: `Can't get capabilities, no account connected for wallet: ${wallet.id}`
    };
  }
  if (account.getCapabilities) {
    return account.getCapabilities({ chainId });
  }
  throw new Error(`Failed to get capabilities, wallet ${wallet.id} does not support EIP-5792`);
}
function toGetCapabilitiesResult(result, chainId) {
  const capabilities = {};
  for (const [chainId2, capabilities_] of Object.entries(result)) {
    capabilities[Number(chainId2)] = {};
    const capabilitiesCopy = {};
    for (const [key, value] of Object.entries(capabilities_)) {
      capabilitiesCopy[key] = value;
    }
    capabilities[Number(chainId2)] = capabilitiesCopy;
  }
  return typeof chainId === "number" ? capabilities[chainId] : capabilities;
}

// node_modules/thirdweb/dist/esm/wallets/eip5792/send-calls.js
async function sendCalls(options) {
  var _a;
  const { wallet, chain } = options;
  const account = wallet.getAccount();
  if (!account) {
    throw new Error(`Cannot send calls, no account connected for wallet: ${wallet.id}`);
  }
  const firstCall = options.calls[0];
  if (!firstCall) {
    throw new Error("No calls to send");
  }
  const callChain = firstCall.chain || chain;
  if (((_a = wallet.getChain()) == null ? void 0 : _a.id) !== callChain.id) {
    await wallet.switchChain(callChain);
  }
  if (account.sendCalls) {
    const { wallet: _, ...optionsWithoutWallet } = options;
    const result = await account.sendCalls(optionsWithoutWallet);
    return {
      ...result,
      wallet
    };
  }
  throw new Error(`Cannot send calls, wallet ${wallet.id} does not support EIP-5792`);
}
async function toProviderCallParams(options, account) {
  const firstCall = options.calls[0];
  if (!firstCall) {
    throw new Error("No calls to send");
  }
  const { calls, capabilities, version = "2.0.0", chain = firstCall.chain } = options;
  const preparedCalls = await Promise.all(calls.map(async (call) => {
    const { to, value } = call;
    if (to === void 0 && call.data === void 0) {
      throw new Error("Cannot send call, `to` or `data` must be provided.");
    }
    const [_to, _data, _value] = await Promise.all([
      resolvePromisedValue(to),
      encode(call),
      resolvePromisedValue(value)
    ]);
    if (_to) {
      return {
        data: _data,
        to: getAddress(_to),
        value: typeof _value === "bigint" || typeof _value === "number" ? numberToHex(_value) : void 0
      };
    }
    return {
      data: _data,
      to: void 0,
      value: void 0
    };
  }));
  const injectedWalletCallParams = [
    {
      // see: https://eips.ethereum.org/EIPS/eip-5792#wallet_sendcalls
      atomicRequired: options.atomicRequired ?? false,
      calls: preparedCalls,
      capabilities,
      chainId: numberToHex(chain.id),
      from: getAddress(account.address),
      version
    }
  ];
  return { callParams: injectedWalletCallParams, chain };
}

// node_modules/thirdweb/dist/esm/wallets/utils/chains.js
function getValidPublicRPCUrl(chain) {
  return getValidChainRPCs(chain).map((rpc) => {
    try {
      const url = new URL(rpc);
      if (url.hostname.endsWith(".thirdweb.com")) {
        url.pathname = "";
        url.search = "";
      }
      return url.toString();
    } catch {
      return rpc;
    }
  });
}
function getValidChainRPCs(chain, clientId, mode = "http") {
  const processedRPCs = [];
  for (const rpc of chain.rpc) {
    if (mode === "http" && !rpc.startsWith("http")) {
      continue;
    }
    if (mode === "ws" && !rpc.startsWith("ws")) {
      continue;
    }
    if (rpc.includes("${THIRDWEB_API_KEY}")) {
      if (clientId) {
        processedRPCs.push(
          // biome-ignore lint/suspicious/noTemplateCurlyInString: this is what the string to replace looks like in this case
          rpc.replace("${THIRDWEB_API_KEY}", clientId) + (typeof globalThis !== "undefined" && "APP_BUNDLE_ID" in globalThis ? (
            // @ts-expect-error
            `/?bundleId=${globalThis.APP_BUNDLE_ID}`
          ) : "")
        );
      } else {
        processedRPCs.push(rpc.replace("${THIRDWEB_API_KEY}", ""));
      }
    } else if (rpc.includes("${")) {
    } else {
      processedRPCs.push(rpc);
    }
  }
  if (processedRPCs.length === 0) {
    throw new Error(`No RPC available for chainId "${chain.chainId}" with mode ${mode}`);
  }
  return processedRPCs;
}

// node_modules/thirdweb/dist/esm/wallets/coinbase/coinbase-web.js
var _provider;
async function getCoinbaseWebProvider(options) {
  var _a, _b;
  if (!_provider) {
    let CoinbaseWalletSDK = (await import("./dist-5SQRYPDZ.js")).default;
    if (typeof CoinbaseWalletSDK !== "function" && typeof CoinbaseWalletSDK.default === "function") {
      CoinbaseWalletSDK = CoinbaseWalletSDK.default;
    }
    const client = new CoinbaseWalletSDK({
      appChainIds: (options == null ? void 0 : options.chains) ? options.chains.map((c) => c.id) : void 0,
      appLogoUrl: ((_a = options == null ? void 0 : options.appMetadata) == null ? void 0 : _a.logoUrl) || getDefaultAppMetadata().logoUrl,
      appName: ((_b = options == null ? void 0 : options.appMetadata) == null ? void 0 : _b.name) || getDefaultAppMetadata().name
    });
    const provider = client.makeWeb3Provider(options == null ? void 0 : options.walletConfig);
    _provider = provider;
    return provider;
  }
  return _provider;
}
function isCoinbaseSDKWallet(wallet) {
  return wallet.id === COINBASE;
}
function createAccount({ provider, address, client }) {
  const account = {
    address: getAddress(address),
    onTransactionRequested: async () => {
      if (window.localStorage) {
        const signerType = window.localStorage.getItem("-CBWSDK:SignerConfigurator:SignerType");
        if (signerType === "scw") {
          await showCoinbasePopup(provider);
        }
      }
    },
    async sendTransaction(tx) {
      const transactionHash = await provider.request({
        method: "eth_sendTransaction",
        params: [
          {
            accessList: tx.accessList,
            data: tx.data,
            from: getAddress(address),
            gas: tx.gas ? numberToHex(tx.gas) : void 0,
            to: tx.to,
            value: tx.value ? numberToHex(tx.value) : void 0
          }
        ]
      });
      trackTransaction({
        chainId: tx.chainId,
        client,
        contractAddress: tx.to ?? void 0,
        gasPrice: tx.gasPrice,
        transactionHash,
        walletAddress: getAddress(address),
        walletType: COINBASE
      });
      return {
        transactionHash
      };
    },
    async signMessage({ message }) {
      if (!account.address) {
        throw new Error("Provider not setup");
      }
      const messageToSign = (() => {
        if (typeof message === "string") {
          return stringToHex(message);
        }
        if (message.raw instanceof Uint8Array) {
          return uint8ArrayToHex(message.raw);
        }
        return message.raw;
      })();
      const res = await provider.request({
        method: "personal_sign",
        params: [messageToSign, account.address]
      });
      if (!validate(res)) {
        throw new Error("Invalid signature returned");
      }
      return res;
    },
    async signTypedData(typedData) {
      if (!account.address) {
        throw new Error("Provider not setup");
      }
      const { domain, message, primaryType } = parseTypedData(typedData);
      const types = {
        EIP712Domain: extractEip712DomainTypes(domain),
        ...typedData.types
      };
      validate2({ domain, message, primaryType, types });
      const stringifiedData = serialize({
        domain: domain ?? {},
        message,
        primaryType,
        types
      });
      const res = await provider.request({
        method: "eth_signTypedData_v4",
        params: [account.address, stringifiedData]
      });
      if (!validate(res)) {
        throw new Error("Invalid signed payload returned");
      }
      return res;
    },
    sendCalls: async (options) => {
      try {
        const { callParams, chain } = await toProviderCallParams(options, account);
        const callId = await provider.request({
          method: "wallet_sendCalls",
          params: callParams
        });
        if (callId && typeof callId === "object" && "id" in callId) {
          return { chain, client, id: callId.id };
        }
        return { chain, client, id: callId };
      } catch (error) {
        if (/unsupport|not support/i.test(error.message)) {
          throw new Error(`${COINBASE} errored calling wallet_sendCalls, with error: ${error instanceof Error ? error.message : stringify(error)}`);
        }
        throw error;
      }
    },
    async getCallsStatus(options) {
      try {
        const rawResponse = await provider.request({
          method: "wallet_getCallsStatus",
          params: [options.id]
        });
        return toGetCallsStatusResponse(rawResponse);
      } catch (error) {
        if (/unsupport|not support/i.test(error.message)) {
          throw new Error(`${COINBASE} does not support wallet_getCallsStatus, reach out to them directly to request EIP-5792 support.`);
        }
        throw error;
      }
    },
    async getCapabilities(options) {
      const chainId = options.chainId;
      try {
        const result = await provider.request({
          method: "wallet_getCapabilities",
          params: [getAddress(account.address)]
        });
        return toGetCapabilitiesResult(result, chainId);
      } catch (error) {
        if (/unsupport|not support|not available/i.test(error.message)) {
          return {
            message: `${COINBASE} does not support wallet_getCapabilities, reach out to them directly to request EIP-5792 support.`
          };
        }
        throw error;
      }
    }
  };
  return account;
}
function onConnect(address, chain, provider, emitter, client) {
  const account = createAccount({ address, client, provider });
  async function disconnect() {
    provider.removeListener("accountsChanged", onAccountsChanged);
    provider.removeListener("chainChanged", onChainChanged);
    provider.removeListener("disconnect", onDisconnect);
    await provider.disconnect();
  }
  async function onDisconnect() {
    disconnect();
    emitter.emit("disconnect", void 0);
  }
  function onAccountsChanged(accounts) {
    if (accounts[0]) {
      const newAccount = createAccount({
        address: getAddress(accounts[0]),
        client,
        provider
      });
      emitter.emit("accountChanged", newAccount);
      emitter.emit("accountsChanged", accounts);
    } else {
      onDisconnect();
    }
  }
  function onChainChanged(newChainId) {
    const newChain = getCachedChain(normalizeChainId(newChainId));
    emitter.emit("chainChanged", newChain);
  }
  provider.on("accountsChanged", onAccountsChanged);
  provider.on("chainChanged", onChainChanged);
  provider.on("disconnect", onDisconnect);
  return [
    account,
    chain,
    onDisconnect,
    (newChain) => switchChainCoinbaseWalletSDK(provider, newChain)
  ];
}
async function connectCoinbaseWalletSDK(options, emitter, provider) {
  const accounts = await provider.request({
    method: "eth_requestAccounts"
  });
  if (!accounts[0]) {
    throw new Error("No accounts found");
  }
  const address = getAddress(accounts[0]);
  const connectedChainId = await provider.request({
    method: "eth_chainId"
  });
  const chainId = normalizeChainId(connectedChainId);
  let chain = options.chain && options.chain.id === chainId ? options.chain : getCachedChain(chainId);
  if (chainId && (options == null ? void 0 : options.chain) && chainId !== (options == null ? void 0 : options.chain.id)) {
    await switchChainCoinbaseWalletSDK(provider, options.chain);
    chain = options.chain;
  }
  return onConnect(address, chain, provider, emitter, options.client);
}
async function autoConnectCoinbaseWalletSDK(options, emitter, provider) {
  const addresses = await provider.request({
    method: "eth_accounts"
  });
  const address = addresses[0];
  if (!address) {
    throw new Error("No accounts found");
  }
  const connectedChainId = await provider.request({
    method: "eth_chainId"
  });
  const chainId = normalizeChainId(connectedChainId);
  const chain = options.chain && options.chain.id === chainId ? options.chain : getCachedChain(chainId);
  return onConnect(address, chain, provider, emitter, options.client);
}
async function switchChainCoinbaseWalletSDK(provider, chain) {
  var _a;
  const chainIdHex = numberToHex(chain.id);
  try {
    await provider.request({
      method: "wallet_switchEthereumChain",
      params: [{ chainId: chainIdHex }]
    });
  } catch (error) {
    const apiChain = await getChainMetadata(chain);
    if ((error == null ? void 0 : error.code) === 4902) {
      await provider.request({
        method: "wallet_addEthereumChain",
        params: [
          {
            blockExplorerUrls: ((_a = apiChain.explorers) == null ? void 0 : _a.map((x) => x.url)) || [],
            chainId: chainIdHex,
            chainName: apiChain.name,
            nativeCurrency: apiChain.nativeCurrency,
            // no client id on purpose here
            rpcUrls: getValidPublicRPCUrl(apiChain)
          }
        ]
      });
    }
  }
}

export {
  getCapabilities,
  toGetCapabilitiesResult,
  sendCalls,
  toProviderCallParams,
  getCallsStatus,
  toGetCallsStatusResponse,
  COINBASE,
  METAMASK,
  RAINBOW,
  ZERION,
  NON_SEARCHABLE_WALLETS,
  getValidPublicRPCUrl,
  getCoinbaseWebProvider,
  isCoinbaseSDKWallet,
  connectCoinbaseWalletSDK,
  autoConnectCoinbaseWalletSDK
};
//# sourceMappingURL=chunk-T34NAMVH.js.map
