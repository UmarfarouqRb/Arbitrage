{
  "version": 3,
  "sources": ["../../thirdweb/src/extensions/erc165/__generated__/IERC165/read/supportsInterface.ts", "../../thirdweb/src/extensions/erc721/read/isERC721.ts", "../../thirdweb/src/extensions/erc1155/read/isERC1155.ts", "../../thirdweb/src/extensions/marketplace/utils.ts", "../../thirdweb/src/extensions/marketplace/direct-listings/utils.ts", "../../thirdweb/src/extensions/marketplace/__generated__/IDirectListings/read/getListing.ts", "../../thirdweb/src/extensions/marketplace/direct-listings/read/getListing.ts"],
  "sourcesContent": ["import type { AbiParameterToPrimitiveType } from \"abitype\";\nimport { decodeAbiParameters } from \"viem\";\nimport { readContract } from \"../../../../../transaction/read-contract.js\";\nimport type { BaseTransactionOptions } from \"../../../../../transaction/types.js\";\nimport { encodeAbiParameters } from \"../../../../../utils/abi/encodeAbiParameters.js\";\nimport { detectMethod } from \"../../../../../utils/bytecode/detectExtension.js\";\nimport type { Hex } from \"../../../../../utils/encoding/hex.js\";\n\n/**\n * Represents the parameters for the \"supportsInterface\" function.\n */\nexport type SupportsInterfaceParams = {\n  interfaceId: AbiParameterToPrimitiveType<{\n    type: \"bytes4\";\n    name: \"interfaceId\";\n  }>;\n};\n\nexport const FN_SELECTOR = \"0x01ffc9a7\" as const;\nconst FN_INPUTS = [\n  {\n    name: \"interfaceId\",\n    type: \"bytes4\",\n  },\n] as const;\nconst FN_OUTPUTS = [\n  {\n    type: \"bool\",\n  },\n] as const;\n\n/**\n * Checks if the `supportsInterface` method is supported by the given contract.\n * @param availableSelectors An array of 4byte function selectors of the contract. You can get this in various ways, such as using \"whatsabi\" or if you have the ABI of the contract available you can use it to generate the selectors.\n * @returns A boolean indicating if the `supportsInterface` method is supported.\n * @extension ERC165\n * @example\n * ```ts\n * import { isSupportsInterfaceSupported } from \"thirdweb/extensions/erc165\";\n * const supported = isSupportsInterfaceSupported([\"0x...\"]);\n * ```\n */\nexport function isSupportsInterfaceSupported(availableSelectors: string[]) {\n  return detectMethod({\n    availableSelectors,\n    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS] as const,\n  });\n}\n\n/**\n * Encodes the parameters for the \"supportsInterface\" function.\n * @param options - The options for the supportsInterface function.\n * @returns The encoded ABI parameters.\n * @extension ERC165\n * @example\n * ```ts\n * import { encodeSupportsInterfaceParams } from \"thirdweb/extensions/erc165\";\n * const result = encodeSupportsInterfaceParams({\n *  interfaceId: ...,\n * });\n * ```\n */\nexport function encodeSupportsInterfaceParams(\n  options: SupportsInterfaceParams,\n) {\n  return encodeAbiParameters(FN_INPUTS, [options.interfaceId]);\n}\n\n/**\n * Encodes the \"supportsInterface\" function into a Hex string with its parameters.\n * @param options - The options for the supportsInterface function.\n * @returns The encoded hexadecimal string.\n * @extension ERC165\n * @example\n * ```ts\n * import { encodeSupportsInterface } from \"thirdweb/extensions/erc165\";\n * const result = encodeSupportsInterface({\n *  interfaceId: ...,\n * });\n * ```\n */\nexport function encodeSupportsInterface(options: SupportsInterfaceParams) {\n  // we do a \"manual\" concat here to avoid the overhead of the \"concatHex\" function\n  // we can do this because we know the specific formats of the values\n  return (FN_SELECTOR +\n    encodeSupportsInterfaceParams(options).slice(\n      2,\n    )) as `${typeof FN_SELECTOR}${string}`;\n}\n\n/**\n * Decodes the result of the supportsInterface function call.\n * @param result - The hexadecimal result to decode.\n * @returns The decoded result as per the FN_OUTPUTS definition.\n * @extension ERC165\n * @example\n * ```ts\n * import { decodeSupportsInterfaceResult } from \"thirdweb/extensions/erc165\";\n * const result = decodeSupportsInterfaceResultResult(\"...\");\n * ```\n */\nexport function decodeSupportsInterfaceResult(result: Hex) {\n  return decodeAbiParameters(FN_OUTPUTS, result)[0];\n}\n\n/**\n * Calls the \"supportsInterface\" function on the contract.\n * @param options - The options for the supportsInterface function.\n * @returns The parsed result of the function call.\n * @extension ERC165\n * @example\n * ```ts\n * import { supportsInterface } from \"thirdweb/extensions/erc165\";\n *\n * const result = await supportsInterface({\n *  contract,\n *  interfaceId: ...,\n * });\n *\n * ```\n */\nexport async function supportsInterface(\n  options: BaseTransactionOptions<SupportsInterfaceParams>,\n) {\n  return readContract({\n    contract: options.contract,\n    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS] as const,\n    params: [options.interfaceId],\n  });\n}\n", "import type { BaseTransactionOptions } from \"../../../transaction/types.js\";\nimport { supportsInterface } from \"../../erc165/__generated__/IERC165/read/supportsInterface.js\";\n\n/**\n * Check if a contract supports the ERC721 interface.\n * @param options - The transaction options.\n * @returns A boolean indicating whether the contract supports the ERC721 interface.\n * @extension ERC721\n * @example\n * ```ts\n * import { isERC721 } from \"thirdweb/extensions/erc721\";\n * const result = await isERC721({ contract });\n * ```\n */\nexport function isERC721(options: BaseTransactionOptions) {\n  return supportsInterface({\n    contract: options.contract,\n    interfaceId: \"0x80ac58cd\",\n  });\n}\n", "import type { BaseTransactionOptions } from \"../../../transaction/types.js\";\nimport { supportsInterface } from \"../../erc165/__generated__/IERC165/read/supportsInterface.js\";\n\n/**\n * Check if a contract supports the ERC1155 interface.\n * @param options - The transaction options.\n * @returns A boolean indicating whether the contract supports the ERC1155 interface.\n * @extension ERC1155\n * @example\n * ```ts\n * import { isERC1155 } from \"thirdweb/extensions/erc1155\";\n * const result = await isERC1155({ contract });\n * ```\n */\nexport function isERC1155(options: BaseTransactionOptions) {\n  return supportsInterface({\n    contract: options.contract,\n    interfaceId: \"0xd9b67a26\",\n  });\n}\n", "import type { BaseTransactionOptions } from \"../../transaction/types.js\";\nimport type { NFT } from \"../../utils/nft/parseNft.js\";\nimport { isERC721 } from \"../erc721/read/isERC721.js\";\nimport { isERC1155 } from \"../erc1155/read/isERC1155.js\";\nimport type { ListingStatus } from \"./types.js\";\n\n/**\n * @extension MARKETPLACE\n */\ntype GetAssetParams = {\n  tokenId: bigint;\n};\n\n/**\n * Retrieves the NFT asset based on the provided options.\n * @param options The transaction options.\n * @returns A promise that resolves to the NFT asset.\n * @extension MARKETPLACE\n * @example\n * ```ts\n * import { getNFTAsset } from \"thirdweb/extensions/marketplace\";\n *\n * const nft = await getNFTAsset({ contract, tokenId: 1n });\n * ```\n */\nexport async function getNFTAsset(\n  options: BaseTransactionOptions<GetAssetParams>,\n): Promise<NFT> {\n  const [erc721, erc1155] = await Promise.all([\n    isERC721(options),\n    isERC1155(options),\n  ]);\n  switch (true) {\n    case erc721: {\n      const { getNFT } = await import(\"../erc721/read/getNFT.js\");\n      return getNFT(options);\n    }\n    case erc1155: {\n      const { getNFT } = await import(\"../erc1155/read/getNFT.js\");\n      return getNFT(options);\n    }\n    default: {\n      throw new Error(\"Contract is neither ERC721 nor ERC1155.\");\n    }\n  }\n}\n\nexport function computeStatus(options: {\n  listingStatus: number;\n  blockTimeStamp: bigint;\n  startTimestamp: bigint;\n  endTimestamp: bigint;\n}): ListingStatus {\n  switch (options.listingStatus) {\n    case 1: {\n      if (options.startTimestamp > options.blockTimeStamp) {\n        return \"CREATED\";\n      }\n      if (options.endTimestamp < options.blockTimeStamp) {\n        return \"EXPIRED\";\n      }\n      return \"ACTIVE\";\n    }\n    case 2: {\n      return \"COMPLETED\";\n    }\n    case 3: {\n      return \"CANCELLED\";\n    }\n    default: {\n      throw new Error(`Invalid listing status: \"${options.listingStatus}\"`);\n    }\n  }\n}\n\n/**\n * @internal\n */\nexport async function getAllInBatches<const T>(\n  fn: (start: bigint, end: bigint) => Promise<T>,\n  options: {\n    start: bigint;\n    end: bigint;\n    maxSize: bigint;\n  },\n): Promise<T[]> {\n  let start = options.start;\n  const batches: Promise<T>[] = [];\n  while (options.end - start > options.maxSize) {\n    batches.push(fn(start, start + options.maxSize - 1n));\n    start += options.maxSize;\n  }\n  batches.push(fn(start, options.end - 1n));\n\n  return await Promise.all(batches);\n}\n", "import { getContract } from \"../../../contract/contract.js\";\nimport type { BaseTransactionOptions } from \"../../../transaction/types.js\";\nimport { toTokens } from \"../../../utils/units.js\";\nimport { getCurrencyMetadata } from \"../../erc20/read/getCurrencyMetadata.js\";\nimport { isERC721 } from \"../../erc721/read/isERC721.js\";\nimport { isERC1155 } from \"../../erc1155/read/isERC1155.js\";\nimport type { getListing } from \"../__generated__/IDirectListings/read/getListing.js\";\nimport { computeStatus, getNFTAsset } from \"../utils.js\";\nimport type { DirectListing } from \"./types.js\";\n\n/**\n * @internal\n */\nexport async function mapDirectListing(\n  options: BaseTransactionOptions<{\n    latestBlock: { timestamp: bigint };\n    rawListing: Awaited<ReturnType<typeof getListing>>;\n  }>,\n): Promise<DirectListing> {\n  const { latestBlock, rawListing } = options;\n  // process the listing\n  const status = computeStatus({\n    blockTimeStamp: latestBlock.timestamp,\n    endTimestamp: rawListing.endTimestamp,\n    listingStatus: rawListing.status,\n    startTimestamp: rawListing.startTimestamp,\n  });\n\n  const currencyContract = getContract({\n    ...options.contract,\n    address: rawListing.currency,\n  });\n  const [currencyValuePerToken, nftAsset] = await Promise.all([\n    getCurrencyMetadata({\n      contract: currencyContract,\n    }),\n    getNFTAsset({\n      ...options,\n      contract: getContract({\n        ...options.contract,\n        address: rawListing.assetContract,\n      }),\n      tokenId: rawListing.tokenId,\n    }),\n  ]);\n\n  return {\n    asset: nftAsset,\n    assetContractAddress: rawListing.assetContract,\n    creatorAddress: rawListing.listingCreator,\n    currencyContractAddress: rawListing.currency,\n    currencyValuePerToken: {\n      ...currencyValuePerToken,\n      chainId: currencyContract.chain.id,\n      displayValue: toTokens(\n        rawListing.pricePerToken,\n        currencyValuePerToken.decimals,\n      ),\n      tokenAddress: currencyContract.address,\n      value: rawListing.pricePerToken,\n    },\n    endTimeInSeconds: rawListing.endTimestamp,\n    id: rawListing.listingId,\n    isReservedListing: rawListing.reserved,\n    pricePerToken: rawListing.pricePerToken,\n    quantity: rawListing.quantity,\n    startTimeInSeconds: rawListing.startTimestamp,\n    status,\n    tokenId: rawListing.tokenId,\n    type: \"direct-listing\",\n  };\n}\n\ntype IsListingValidParams = {\n  listing: DirectListing;\n  quantity?: bigint;\n};\ntype ValidReturn = { valid: true } | { valid: false; reason: string };\n\nexport async function isListingValid(\n  options: BaseTransactionOptions<IsListingValidParams>,\n): Promise<ValidReturn> {\n  const assetContract = getContract({\n    ...options.contract,\n    address: options.listing.assetContractAddress,\n  });\n\n  const [erc721, erc1155] = await Promise.all([\n    isERC721({ contract: assetContract }),\n    isERC1155({ contract: assetContract }),\n  ]);\n\n  // if the asset is an erc721 token\n  if (erc721) {\n    const [{ isApprovedForAll }, { getApproved }, { ownerOf }] =\n      await Promise.all([\n        import(\"../../erc721/__generated__/IERC721A/read/isApprovedForAll.js\"),\n        import(\"../../erc721/__generated__/IERC721A/read/getApproved.js\"),\n        import(\"../../erc721/__generated__/IERC721A/read/ownerOf.js\"),\n      ]);\n    // check for token approval\n    const [approvedForAll, approvedOperator, tokenOwner] = await Promise.all([\n      isApprovedForAll({\n        contract: assetContract,\n        // the marketplace contract address has to be approved to transfer the token\n        operator: options.contract.address,\n        owner: options.listing.creatorAddress,\n      }),\n      getApproved({\n        contract: assetContract,\n        tokenId: options.listing.tokenId,\n      }).catch(() => \"\"),\n      ownerOf({\n        contract: assetContract,\n        tokenId: options.listing.tokenId,\n      }),\n    ]);\n    // if the marketplace is not approved for all and the marketplace contract is not the approved operator for the token\n    // -> the listing is not valid\n    if (!approvedForAll && approvedOperator !== options.contract.address) {\n      return { reason: \"Asset not approved for marketplace.\", valid: false };\n    }\n    // if the token owner is not the creator of the listing\n    // -> the listing is not valid\n    if (tokenOwner !== options.listing.creatorAddress) {\n      return {\n        reason: \"Listing creator no longer owns this token.\",\n        valid: false,\n      };\n    }\n    // otherwise the listing is valid\n    return {\n      valid: true,\n    };\n  }\n  // if the asset is an erc1155 token\n  if (erc1155) {\n    const [{ isApprovedForAll }, { balanceOf }] = await Promise.all([\n      import(\"../../erc1155/__generated__/IERC1155/read/isApprovedForAll.js\"),\n      import(\"../../erc1155/__generated__/IERC1155/read/balanceOf.js\"),\n    ]);\n\n    const [approvedForAll, balance] = await Promise.all([\n      isApprovedForAll({\n        contract: assetContract,\n        // the marketplace contract address has to be approved to transfer the token\n        operator: options.contract.address,\n        owner: options.listing.creatorAddress,\n      }),\n      balanceOf({\n        contract: assetContract,\n        owner: options.listing.creatorAddress,\n        tokenId: options.listing.tokenId,\n      }),\n    ]);\n\n    // if the marketplace is not approved for all\n    // -> the listing is not valid\n    if (!approvedForAll) {\n      return { reason: \"Asset not approved for marketplace.\", valid: false };\n    }\n    // if the balance is less than the quantity the user is trying to purchase or the listing quantity\n    // -> the listing is not valid\n    const quantityWanted = options.quantity || options.listing.quantity;\n    if (balance < quantityWanted) {\n      return {\n        reason:\n          \"Seller does not have enough balance of token to fulfill order.\",\n        valid: false,\n      };\n    }\n    return {\n      valid: true,\n    };\n  }\n  // if the asset is neither ERC721 nor ERC1155\n\n  return {\n    reason: \"AssetContract must implement ERC 1155 or ERC 721.\",\n    valid: false,\n  };\n}\n", "import type { AbiParameterToPrimitiveType } from \"abitype\";\nimport { decodeAbiParameters } from \"viem\";\nimport { readContract } from \"../../../../../transaction/read-contract.js\";\nimport type { BaseTransactionOptions } from \"../../../../../transaction/types.js\";\nimport { encodeAbiParameters } from \"../../../../../utils/abi/encodeAbiParameters.js\";\nimport { detectMethod } from \"../../../../../utils/bytecode/detectExtension.js\";\nimport type { Hex } from \"../../../../../utils/encoding/hex.js\";\n\n/**\n * Represents the parameters for the \"getListing\" function.\n */\nexport type GetListingParams = {\n  listingId: AbiParameterToPrimitiveType<{\n    type: \"uint256\";\n    name: \"_listingId\";\n  }>;\n};\n\nexport const FN_SELECTOR = \"0x107a274a\" as const;\nconst FN_INPUTS = [\n  {\n    name: \"_listingId\",\n    type: \"uint256\",\n  },\n] as const;\nconst FN_OUTPUTS = [\n  {\n    components: [\n      {\n        name: \"listingId\",\n        type: \"uint256\",\n      },\n      {\n        name: \"tokenId\",\n        type: \"uint256\",\n      },\n      {\n        name: \"quantity\",\n        type: \"uint256\",\n      },\n      {\n        name: \"pricePerToken\",\n        type: \"uint256\",\n      },\n      {\n        name: \"startTimestamp\",\n        type: \"uint128\",\n      },\n      {\n        name: \"endTimestamp\",\n        type: \"uint128\",\n      },\n      {\n        name: \"listingCreator\",\n        type: \"address\",\n      },\n      {\n        name: \"assetContract\",\n        type: \"address\",\n      },\n      {\n        name: \"currency\",\n        type: \"address\",\n      },\n      {\n        name: \"tokenType\",\n        type: \"uint8\",\n      },\n      {\n        name: \"status\",\n        type: \"uint8\",\n      },\n      {\n        name: \"reserved\",\n        type: \"bool\",\n      },\n    ],\n    name: \"listing\",\n    type: \"tuple\",\n  },\n] as const;\n\n/**\n * Checks if the `getListing` method is supported by the given contract.\n * @param availableSelectors An array of 4byte function selectors of the contract. You can get this in various ways, such as using \"whatsabi\" or if you have the ABI of the contract available you can use it to generate the selectors.\n * @returns A boolean indicating if the `getListing` method is supported.\n * @extension MARKETPLACE\n * @example\n * ```ts\n * import { isGetListingSupported } from \"thirdweb/extensions/marketplace\";\n * const supported = isGetListingSupported([\"0x...\"]);\n * ```\n */\nexport function isGetListingSupported(availableSelectors: string[]) {\n  return detectMethod({\n    availableSelectors,\n    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS] as const,\n  });\n}\n\n/**\n * Encodes the parameters for the \"getListing\" function.\n * @param options - The options for the getListing function.\n * @returns The encoded ABI parameters.\n * @extension MARKETPLACE\n * @example\n * ```ts\n * import { encodeGetListingParams } from \"thirdweb/extensions/marketplace\";\n * const result = encodeGetListingParams({\n *  listingId: ...,\n * });\n * ```\n */\nexport function encodeGetListingParams(options: GetListingParams) {\n  return encodeAbiParameters(FN_INPUTS, [options.listingId]);\n}\n\n/**\n * Encodes the \"getListing\" function into a Hex string with its parameters.\n * @param options - The options for the getListing function.\n * @returns The encoded hexadecimal string.\n * @extension MARKETPLACE\n * @example\n * ```ts\n * import { encodeGetListing } from \"thirdweb/extensions/marketplace\";\n * const result = encodeGetListing({\n *  listingId: ...,\n * });\n * ```\n */\nexport function encodeGetListing(options: GetListingParams) {\n  // we do a \"manual\" concat here to avoid the overhead of the \"concatHex\" function\n  // we can do this because we know the specific formats of the values\n  return (FN_SELECTOR +\n    encodeGetListingParams(options).slice(\n      2,\n    )) as `${typeof FN_SELECTOR}${string}`;\n}\n\n/**\n * Decodes the result of the getListing function call.\n * @param result - The hexadecimal result to decode.\n * @returns The decoded result as per the FN_OUTPUTS definition.\n * @extension MARKETPLACE\n * @example\n * ```ts\n * import { decodeGetListingResult } from \"thirdweb/extensions/marketplace\";\n * const result = decodeGetListingResultResult(\"...\");\n * ```\n */\nexport function decodeGetListingResult(result: Hex) {\n  return decodeAbiParameters(FN_OUTPUTS, result)[0];\n}\n\n/**\n * Calls the \"getListing\" function on the contract.\n * @param options - The options for the getListing function.\n * @returns The parsed result of the function call.\n * @extension MARKETPLACE\n * @example\n * ```ts\n * import { getListing } from \"thirdweb/extensions/marketplace\";\n *\n * const result = await getListing({\n *  contract,\n *  listingId: ...,\n * });\n *\n * ```\n */\nexport async function getListing(\n  options: BaseTransactionOptions<GetListingParams>,\n) {\n  return readContract({\n    contract: options.contract,\n    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS] as const,\n    params: [options.listingId],\n  });\n}\n", "import { eth_getBlockByNumber } from \"../../../../rpc/actions/eth_getBlockByNumber.js\";\nimport { getRpcClient } from \"../../../../rpc/rpc.js\";\nimport type { BaseTransactionOptions } from \"../../../../transaction/types.js\";\nimport * as GetListing from \"../../__generated__/IDirectListings/read/getListing.js\";\nimport type { DirectListing } from \"../types.js\";\nimport { mapDirectListing } from \"../utils.js\";\n\n/**\n * @extension MARKETPLACE\n */\nexport type GetListingParams = GetListing.GetListingParams;\n\n/**\n * Retrieves a direct listing based on the provided options.\n * @param options - The options for retrieving the listing.\n * @returns A promise that resolves to the direct listing.\n * @extension MARKETPLACE\n * @example\n *\n * ```ts\n * import { getListing } from \"thirdweb/extensions/marketplace\";\n *\n * const listing = await getListing({ contract, listingId: 1n });\n * ```\n */\nexport async function getListing(\n  options: BaseTransactionOptions<GetListingParams>,\n): Promise<DirectListing> {\n  const rpcClient = getRpcClient(options.contract);\n  const [rawListing, latestBlock] = await Promise.all([\n    GetListing.getListing(options),\n    eth_getBlockByNumber(rpcClient, {\n      blockTag: \"latest\",\n    }),\n  ]);\n\n  return mapDirectListing({\n    contract: options.contract,\n    latestBlock,\n    rawListing,\n  });\n}\n\n/**\n * Checks if the `isGetListingSupported` method is supported by the given contract.\n * @param availableSelectors An array of 4byte function selectors of the contract. You can get this in various ways, such as using \"whatsabi\" or if you have the ABI of the contract available you can use it to generate the selectors.\n * @returns A boolean indicating if the `isGetListingSupported` method is supported.\n * @extension MARKETPLACE\n * @example\n * ```ts\n * import { isGetListingSupported } from \"thirdweb/extensions/marketplace\";\n *\n * const supported = isGetListingSupported([\"0x...\"]);\n * ```\n */\nexport function isGetListingSupported(availableSelectors: string[]) {\n  return GetListing.isGetListingSupported(availableSelectors);\n}\n"],
  "mappings": "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",
  "names": ["FN_SELECTOR", "FN_INPUTS", "FN_OUTPUTS", "FN_SELECTOR", "FN_INPUTS", "FN_OUTPUTS", "getListing", "isGetListingSupported"]
}
