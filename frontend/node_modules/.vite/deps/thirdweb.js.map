{
  "version": 3,
  "sources": ["../../thirdweb/node_modules/@noble/hashes/src/_md.ts", "../../thirdweb/node_modules/@noble/hashes/src/sha256.ts", "../../thirdweb/src/utils/hashing/sha256.ts", "../../thirdweb/src/utils/client-id.ts", "../../thirdweb/src/client/client.ts", "../../thirdweb/src/engine/index.ts", "../../@thirdweb-dev/engine/src/client/core/bodySerializer.ts", "../../@thirdweb-dev/engine/src/client/core/params.ts", "../../@thirdweb-dev/engine/src/client/core/auth.ts", "../../@thirdweb-dev/engine/src/client/core/pathSerializer.ts", "../../@thirdweb-dev/engine/src/client/client/utils.ts", "../../@thirdweb-dev/engine/src/client/client/client.ts", "../../@thirdweb-dev/engine/src/client/client.gen.ts", "../../@thirdweb-dev/engine/src/client/sdk.gen.ts", "../../@thirdweb-dev/engine/src/configure.ts", "../../thirdweb/src/engine/create-server-wallet.ts", "../../thirdweb/src/engine/get-status.ts", "../../thirdweb/src/engine/list-server-wallets.ts", "../../thirdweb/src/engine/search-transactions.ts", "../../thirdweb/src/engine/wait-for-tx-hash.ts", "../../thirdweb/src/engine/server-wallet.ts", "../../thirdweb/src/rpc/actions/eth_getBlockByHash.ts", "../../thirdweb/src/rpc/actions/eth_getTransactionByHash.ts", "../../thirdweb/src/wallets/in-app/core/users/getUser.ts", "../../thirdweb/src/pay/buyWithCrypto/getTransfer.ts", "../../thirdweb/src/transaction/actions/sign-transaction.ts", "../../thirdweb/src/transaction/resolve-method.ts", "../../thirdweb/src/auth/verify-typed-data.ts", "../../thirdweb/src/transaction/actions/eip7702/authorization.ts"],
  "sourcesContent": ["/**\n * Internal Merkle-Damgard hash utils.\n * @module\n */\nimport { aexists, aoutput } from './_assert.ts';\nimport { type Input, Hash, createView, toBytes } from './utils.ts';\n\n/** Polyfill for Safari 14. https://caniuse.com/mdn-javascript_builtins_dataview_setbiguint64 */\nexport function setBigUint64(\n  view: DataView,\n  byteOffset: number,\n  value: bigint,\n  isLE: boolean\n): void {\n  if (typeof view.setBigUint64 === 'function') return view.setBigUint64(byteOffset, value, isLE);\n  const _32n = BigInt(32);\n  const _u32_max = BigInt(0xffffffff);\n  const wh = Number((value >> _32n) & _u32_max);\n  const wl = Number(value & _u32_max);\n  const h = isLE ? 4 : 0;\n  const l = isLE ? 0 : 4;\n  view.setUint32(byteOffset + h, wh, isLE);\n  view.setUint32(byteOffset + l, wl, isLE);\n}\n\n/** Choice: a ? b : c */\nexport function Chi(a: number, b: number, c: number): number {\n  return (a & b) ^ (~a & c);\n}\n\n/** Majority function, true if any two inputs is true. */\nexport function Maj(a: number, b: number, c: number): number {\n  return (a & b) ^ (a & c) ^ (b & c);\n}\n\n/**\n * Merkle-Damgard hash construction base class.\n * Could be used to create MD5, RIPEMD, SHA1, SHA2.\n */\nexport abstract class HashMD<T extends HashMD<T>> extends Hash<T> {\n  protected abstract process(buf: DataView, offset: number): void;\n  protected abstract get(): number[];\n  protected abstract set(...args: number[]): void;\n  abstract destroy(): void;\n  protected abstract roundClean(): void;\n\n  readonly blockLen: number;\n  readonly outputLen: number;\n  readonly padOffset: number;\n  readonly isLE: boolean;\n\n  // For partial updates less than block size\n  protected buffer: Uint8Array;\n  protected view: DataView;\n  protected finished = false;\n  protected length = 0;\n  protected pos = 0;\n  protected destroyed = false;\n\n  constructor(blockLen: number, outputLen: number, padOffset: number, isLE: boolean) {\n    super();\n    this.blockLen = blockLen;\n    this.outputLen = outputLen;\n    this.padOffset = padOffset;\n    this.isLE = isLE;\n    this.buffer = new Uint8Array(blockLen);\n    this.view = createView(this.buffer);\n  }\n  update(data: Input): this {\n    aexists(this);\n    const { view, buffer, blockLen } = this;\n    data = toBytes(data);\n    const len = data.length;\n    for (let pos = 0; pos < len; ) {\n      const take = Math.min(blockLen - this.pos, len - pos);\n      // Fast path: we have at least one block in input, cast it to view and process\n      if (take === blockLen) {\n        const dataView = createView(data);\n        for (; blockLen <= len - pos; pos += blockLen) this.process(dataView, pos);\n        continue;\n      }\n      buffer.set(data.subarray(pos, pos + take), this.pos);\n      this.pos += take;\n      pos += take;\n      if (this.pos === blockLen) {\n        this.process(view, 0);\n        this.pos = 0;\n      }\n    }\n    this.length += data.length;\n    this.roundClean();\n    return this;\n  }\n  digestInto(out: Uint8Array): void {\n    aexists(this);\n    aoutput(out, this);\n    this.finished = true;\n    // Padding\n    // We can avoid allocation of buffer for padding completely if it\n    // was previously not allocated here. But it won't change performance.\n    const { buffer, view, blockLen, isLE } = this;\n    let { pos } = this;\n    // append the bit '1' to the message\n    buffer[pos++] = 0b10000000;\n    this.buffer.subarray(pos).fill(0);\n    // we have less than padOffset left in buffer, so we cannot put length in\n    // current block, need process it and pad again\n    if (this.padOffset > blockLen - pos) {\n      this.process(view, 0);\n      pos = 0;\n    }\n    // Pad until full block byte with zeros\n    for (let i = pos; i < blockLen; i++) buffer[i] = 0;\n    // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that\n    // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.\n    // So we just write lowest 64 bits of that value.\n    setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);\n    this.process(view, 0);\n    const oview = createView(out);\n    const len = this.outputLen;\n    // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT\n    if (len % 4) throw new Error('_sha2: outputLen should be aligned to 32bit');\n    const outLen = len / 4;\n    const state = this.get();\n    if (outLen > state.length) throw new Error('_sha2: outputLen bigger than state');\n    for (let i = 0; i < outLen; i++) oview.setUint32(4 * i, state[i], isLE);\n  }\n  digest(): Uint8Array {\n    const { buffer, outputLen } = this;\n    this.digestInto(buffer);\n    const res = buffer.slice(0, outputLen);\n    this.destroy();\n    return res;\n  }\n  _cloneInto(to?: T): T {\n    to ||= new (this.constructor as any)() as T;\n    to.set(...this.get());\n    const { blockLen, buffer, length, finished, destroyed, pos } = this;\n    to.length = length;\n    to.pos = pos;\n    to.finished = finished;\n    to.destroyed = destroyed;\n    if (length % blockLen) to.buffer.set(buffer);\n    return to;\n  }\n}\n", "/**\n * SHA2-256 a.k.a. sha256. In JS, it is the fastest hash, even faster than Blake3.\n *\n * To break sha256 using birthday attack, attackers need to try 2^128 hashes.\n * BTC network is doing 2^70 hashes/sec (2^95 hashes/year) as per 2025.\n *\n * Check out [FIPS 180-4](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf).\n * @module\n */\nimport { Chi, HashMD, Maj } from './_md.ts';\nimport { type CHash, rotr, wrapConstructor } from './utils.ts';\n\n/** Round constants: first 32 bits of fractional parts of the cube roots of the first 64 primes 2..311). */\n// prettier-ignore\nconst SHA256_K = /* @__PURE__ */ new Uint32Array([\n  0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n  0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n  0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n  0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n  0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n  0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n  0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n  0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n]);\n\n/** Initial state: first 32 bits of fractional parts of the square roots of the first 8 primes 2..19. */\n// prettier-ignore\nconst SHA256_IV = /* @__PURE__ */ new Uint32Array([\n  0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19\n]);\n\n/**\n * Temporary buffer, not used to store anything between runs.\n * Named this way because it matches specification.\n */\nconst SHA256_W = /* @__PURE__ */ new Uint32Array(64);\nexport class SHA256 extends HashMD<SHA256> {\n  // We cannot use array here since array allows indexing by variable\n  // which means optimizer/compiler cannot use registers.\n  protected A: number = SHA256_IV[0] | 0;\n  protected B: number = SHA256_IV[1] | 0;\n  protected C: number = SHA256_IV[2] | 0;\n  protected D: number = SHA256_IV[3] | 0;\n  protected E: number = SHA256_IV[4] | 0;\n  protected F: number = SHA256_IV[5] | 0;\n  protected G: number = SHA256_IV[6] | 0;\n  protected H: number = SHA256_IV[7] | 0;\n\n  constructor(outputLen: number = 32) {\n    super(64, outputLen, 8, false);\n  }\n  protected get(): [number, number, number, number, number, number, number, number] {\n    const { A, B, C, D, E, F, G, H } = this;\n    return [A, B, C, D, E, F, G, H];\n  }\n  // prettier-ignore\n  protected set(\n    A: number, B: number, C: number, D: number, E: number, F: number, G: number, H: number\n  ): void {\n    this.A = A | 0;\n    this.B = B | 0;\n    this.C = C | 0;\n    this.D = D | 0;\n    this.E = E | 0;\n    this.F = F | 0;\n    this.G = G | 0;\n    this.H = H | 0;\n  }\n  protected process(view: DataView, offset: number): void {\n    // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array\n    for (let i = 0; i < 16; i++, offset += 4) SHA256_W[i] = view.getUint32(offset, false);\n    for (let i = 16; i < 64; i++) {\n      const W15 = SHA256_W[i - 15];\n      const W2 = SHA256_W[i - 2];\n      const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ (W15 >>> 3);\n      const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ (W2 >>> 10);\n      SHA256_W[i] = (s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16]) | 0;\n    }\n    // Compression function main loop, 64 rounds\n    let { A, B, C, D, E, F, G, H } = this;\n    for (let i = 0; i < 64; i++) {\n      const sigma1 = rotr(E, 6) ^ rotr(E, 11) ^ rotr(E, 25);\n      const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n      const sigma0 = rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22);\n      const T2 = (sigma0 + Maj(A, B, C)) | 0;\n      H = G;\n      G = F;\n      F = E;\n      E = (D + T1) | 0;\n      D = C;\n      C = B;\n      B = A;\n      A = (T1 + T2) | 0;\n    }\n    // Add the compressed chunk to the current hash value\n    A = (A + this.A) | 0;\n    B = (B + this.B) | 0;\n    C = (C + this.C) | 0;\n    D = (D + this.D) | 0;\n    E = (E + this.E) | 0;\n    F = (F + this.F) | 0;\n    G = (G + this.G) | 0;\n    H = (H + this.H) | 0;\n    this.set(A, B, C, D, E, F, G, H);\n  }\n  protected roundClean(): void {\n    SHA256_W.fill(0);\n  }\n  destroy(): void {\n    this.set(0, 0, 0, 0, 0, 0, 0, 0);\n    this.buffer.fill(0);\n  }\n}\n\n/**\n * Constants taken from https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf.\n */\nclass SHA224 extends SHA256 {\n  protected A = 0xc1059ed8 | 0;\n  protected B = 0x367cd507 | 0;\n  protected C = 0x3070dd17 | 0;\n  protected D = 0xf70e5939 | 0;\n  protected E = 0xffc00b31 | 0;\n  protected F = 0x68581511 | 0;\n  protected G = 0x64f98fa7 | 0;\n  protected H = 0xbefa4fa4 | 0;\n  constructor() {\n    super(28);\n  }\n}\n\n/** SHA2-256 hash function */\nexport const sha256: CHash = /* @__PURE__ */ wrapConstructor(() => new SHA256());\n/** SHA2-224 hash function */\nexport const sha224: CHash = /* @__PURE__ */ wrapConstructor(() => new SHA224());\n", "import { sha256 as noble_sha256 } from \"@noble/hashes/sha256\";\nimport {\n  type Hex,\n  hexToUint8Array,\n  isHex,\n  uint8ArrayToHex,\n} from \"../encoding/hex.js\";\n\ntype To = \"hex\" | \"bytes\";\n\ntype Sha256Hash<TTo extends To> =\n  | (TTo extends \"bytes\" ? Uint8Array : never)\n  | (TTo extends \"hex\" ? Hex : never);\n\n/**\n * Calculates the SHA256 hash of the given value.\n * @param value - The value to hash. It can be either a hexadecimal string or a Uint8Array.\n * @param to - (Optional) The desired output format of the hash. Defaults to 'hex'.\n * @returns The SHA256 hash of the value in the specified format.\n * @example\n * ```ts\n * import { sha256 } from \"thirdweb/utils\";\n * const hash = sha256(\"0x1234\");\n * ```\n * @utils\n */\nexport function sha256<TTo extends To = \"hex\">(\n  value: Hex | Uint8Array,\n  to?: TTo,\n): Sha256Hash<TTo> {\n  const bytes = noble_sha256(\n    isHex(value, { strict: false }) ? hexToUint8Array(value) : value,\n  );\n  if (to === \"bytes\") {\n    return bytes as Sha256Hash<TTo>;\n  }\n  return uint8ArrayToHex(bytes) as Sha256Hash<TTo>;\n}\n", "import { LruMap } from \"./caching/lru.js\";\nimport { stringToBytes } from \"./encoding/to-bytes.js\";\nimport { sha256 } from \"./hashing/sha256.js\";\n\nconst cache = new LruMap<string>(4096);\n\n/**\n * @param secretKey - the secret key to compute the client id from\n * @returns the 32 char hex client id\n * @internal\n */\nexport function computeClientIdFromSecretKey(secretKey: string): string {\n  if (cache.has(secretKey)) {\n    return cache.get(secretKey) as string;\n  }\n  // we slice off the leading `0x` and then take the first 32 chars\n  const cId = sha256(stringToBytes(secretKey)).slice(2, 34);\n  cache.set(secretKey, cId);\n  return cId;\n}\n", "import { computeClientIdFromSecretKey } from \"../utils/client-id.js\";\nimport { isJWT } from \"../utils/jwt/is-jwt.js\";\nimport type { Prettify } from \"../utils/type-utils.js\";\n\ntype FetchConfig = {\n  requestTimeoutMs?: number;\n  keepalive?: boolean;\n  headers?: HeadersInit;\n};\n\ntype ClientOptions = Prettify<{\n  /**\n   * The configuration options for the client.\n   */\n  config?: {\n    /**\n     * The configuration options for the RPC client.\n     */\n    rpc?: {\n      /**\n       * The configuration options for the fetch function.\n       * @default {}\n       */\n      fetch?: FetchConfig;\n      /**\n       * The maximum number of requests to batch together.\n       * @default 100\n       */\n      maxBatchSize?: number;\n      /**\n       * The maximum time to wait before sending a batch of requests.\n       * @default 0 (no timeout)\n       */\n      batchTimeoutMs?: number;\n    };\n    /**\n     * The configuration options for the storage client.\n     */\n    storage?: {\n      /**\n       * The configuration options for the fetch function.\n       * @default {}\n       */\n      fetch?: FetchConfig;\n      /**\n       * The IPFS gateway URL.\n       * @default \"https://<your_client_id>.ipfscdn.io/ipfs/<cid>\"\n       */\n      gatewayUrl?: string;\n    };\n  };\n\n  /**\n   * The team ID for thirdweb dashboard usage.\n   * @hidden\n   */\n  teamId?: string;\n}>;\n\nexport type CreateThirdwebClientOptions = Prettify<\n  (\n    | {\n        clientId: string;\n        secretKey?: string;\n      }\n    | {\n        clientId?: string;\n        secretKey: string;\n      }\n  ) &\n    ClientOptions\n>;\n\nexport type ThirdwebClient = {\n  readonly clientId: string;\n  readonly secretKey: string | undefined;\n} & Readonly<ClientOptions>;\n\n/**\n * Creates a Thirdweb client using the provided client ID (client-side) or secret key (server-side).\n *\n * Get your client ID and secret key from the Thirdweb dashboard [here](https://thirdweb.com/create-api-key).\n * **Never share your secret key with anyone.\n *\n * A client is necessary for most functions in the thirdweb SDK. It provides access to thirdweb APIs including built-in RPC, storage, and more.\n *\n * @param options - The options for creating the client.\n * @param [options.clientId] - The client ID to use for thirdweb services.\n * @param [options.secretKey] - The secret key to use for thirdweb services.\n * @returns The created Thirdweb client.\n * @throws An error if neither `clientId` nor `secretKey` is provided.\n *\n * @example\n * Create a client on the client side (client ID):\n * ```ts\n * import { createThirdwebClient } from \"thirdweb\";\n *\n * const client = createThirdwebClient({ clientId: \"...\" });\n * ```\n *\n * Create a client on the server (secret key):\n * ```ts\n * import { createThirdwebClient } from \"thirdweb\";\n *\n * const client = createThirdwebClient({ secretKey: \"...\" });\n * ```\n * @client\n */\nexport function createThirdwebClient(\n  options: CreateThirdwebClientOptions,\n): ThirdwebClient {\n  const { clientId, secretKey, ...rest } = options;\n\n  let realClientId: string | undefined = clientId;\n\n  if (secretKey) {\n    if (isJWT(secretKey)) {\n      // when passing a JWT as secret key we HAVE to also have a clientId\n      if (!clientId) {\n        throw new Error(\"clientId must be provided when using a JWT secretKey\");\n      }\n    } else {\n      // always PREFER the clientId if provided, only compute it from the secretKey if we don't have a clientId passed explicitly\n      realClientId = clientId ?? computeClientIdFromSecretKey(secretKey);\n    }\n  }\n\n  // only path we get here is if we have no secretKey and no clientId\n  if (!realClientId) {\n    throw new Error(\"clientId or secretKey must be provided\");\n  }\n\n  return {\n    ...rest,\n    clientId: realClientId,\n    secretKey,\n  } as const;\n}\n", "export {\n  type CreateServerWalletArgs,\n  createServerWallet,\n} from \"./create-server-wallet.js\";\nexport {\n  type ExecutionResult,\n  getTransactionStatus,\n  type RevertData,\n} from \"./get-status.js\";\nexport {\n  type GetServerWalletsArgs,\n  getServerWallets,\n} from \"./list-server-wallets.js\";\nexport {\n  type SearchTransactionsArgs,\n  searchTransactions,\n} from \"./search-transactions.js\";\nexport {\n  type ServerWallet,\n  type ServerWalletOptions,\n  serverWallet,\n} from \"./server-wallet.js\";\nexport { waitForTransactionHash } from \"./wait-for-tx-hash.js\";\n", "import type {\n\tArrayStyle,\n\tObjectStyle,\n\tSerializerOptions,\n} from \"./pathSerializer.js\";\n\nexport type QuerySerializer = (query: Record<string, unknown>) => string;\n\nexport type BodySerializer = (body: any) => any;\n\nexport interface QuerySerializerOptions {\n\tallowReserved?: boolean;\n\tarray?: SerializerOptions<ArrayStyle>;\n\tobject?: SerializerOptions<ObjectStyle>;\n}\n\nconst serializeFormDataPair = (data: FormData, key: string, value: unknown) => {\n\tif (typeof value === \"string\" || value instanceof Blob) {\n\t\tdata.append(key, value);\n\t} else {\n\t\tdata.append(key, JSON.stringify(value));\n\t}\n};\n\nconst serializeUrlSearchParamsPair = (\n\tdata: URLSearchParams,\n\tkey: string,\n\tvalue: unknown,\n) => {\n\tif (typeof value === \"string\") {\n\t\tdata.append(key, value);\n\t} else {\n\t\tdata.append(key, JSON.stringify(value));\n\t}\n};\n\nexport const formDataBodySerializer = {\n\tbodySerializer: <T extends Record<string, any> | Array<Record<string, any>>>(\n\t\tbody: T,\n\t) => {\n\t\tconst data = new FormData();\n\n\t\tObject.entries(body).forEach(([key, value]) => {\n\t\t\tif (value === undefined || value === null) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (Array.isArray(value)) {\n\t\t\t\tvalue.forEach((v) => serializeFormDataPair(data, key, v));\n\t\t\t} else {\n\t\t\t\tserializeFormDataPair(data, key, value);\n\t\t\t}\n\t\t});\n\n\t\treturn data;\n\t},\n};\n\nexport const jsonBodySerializer = {\n\tbodySerializer: <T>(body: T) =>\n\t\tJSON.stringify(body, (_key, value) =>\n\t\t\ttypeof value === \"bigint\" ? value.toString() : value,\n\t\t),\n};\n\nexport const urlSearchParamsBodySerializer = {\n\tbodySerializer: <T extends Record<string, any> | Array<Record<string, any>>>(\n\t\tbody: T,\n\t) => {\n\t\tconst data = new URLSearchParams();\n\n\t\tObject.entries(body).forEach(([key, value]) => {\n\t\t\tif (value === undefined || value === null) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (Array.isArray(value)) {\n\t\t\t\tvalue.forEach((v) => serializeUrlSearchParamsPair(data, key, v));\n\t\t\t} else {\n\t\t\t\tserializeUrlSearchParamsPair(data, key, value);\n\t\t\t}\n\t\t});\n\n\t\treturn data.toString();\n\t},\n};\n", "type Slot = \"body\" | \"headers\" | \"path\" | \"query\";\n\nexport type Field =\n\t| {\n\t\t\tin: Exclude<Slot, \"body\">;\n\t\t\tkey: string;\n\t\t\tmap?: string;\n\t  }\n\t| {\n\t\t\tin: Extract<Slot, \"body\">;\n\t\t\tkey?: string;\n\t\t\tmap?: string;\n\t  };\n\nexport interface Fields {\n\tallowExtra?: Partial<Record<Slot, boolean>>;\n\targs?: ReadonlyArray<Field>;\n}\n\nexport type FieldsConfig = ReadonlyArray<Field | Fields>;\n\nconst extraPrefixesMap: Record<string, Slot> = {\n\t$body_: \"body\",\n\t$headers_: \"headers\",\n\t$path_: \"path\",\n\t$query_: \"query\",\n};\nconst extraPrefixes = Object.entries(extraPrefixesMap);\n\ntype KeyMap = Map<\n\tstring,\n\t{\n\t\tin: Slot;\n\t\tmap?: string;\n\t}\n>;\n\nconst buildKeyMap = (fields: FieldsConfig, map?: KeyMap): KeyMap => {\n\tif (!map) {\n\t\tmap = new Map();\n\t}\n\n\tfor (const config of fields) {\n\t\tif (\"in\" in config) {\n\t\t\tif (config.key) {\n\t\t\t\tmap.set(config.key, {\n\t\t\t\t\tin: config.in,\n\t\t\t\t\tmap: config.map,\n\t\t\t\t});\n\t\t\t}\n\t\t} else if (config.args) {\n\t\t\tbuildKeyMap(config.args, map);\n\t\t}\n\t}\n\n\treturn map;\n};\n\ninterface Params {\n\tbody: unknown;\n\theaders: Record<string, unknown>;\n\tpath: Record<string, unknown>;\n\tquery: Record<string, unknown>;\n}\n\nconst stripEmptySlots = (params: Params) => {\n\tfor (const [slot, value] of Object.entries(params)) {\n\t\tif (value && typeof value === \"object\" && !Object.keys(value).length) {\n\t\t\tdelete params[slot as Slot];\n\t\t}\n\t}\n};\n\nexport const buildClientParams = (\n\targs: ReadonlyArray<unknown>,\n\tfields: FieldsConfig,\n) => {\n\tconst params: Params = {\n\t\tbody: {},\n\t\theaders: {},\n\t\tpath: {},\n\t\tquery: {},\n\t};\n\n\tconst map = buildKeyMap(fields);\n\n\tlet config: FieldsConfig[number] | undefined;\n\n\tfor (const [index, arg] of args.entries()) {\n\t\tif (fields[index]) {\n\t\t\tconfig = fields[index];\n\t\t}\n\n\t\tif (!config) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (\"in\" in config) {\n\t\t\tif (config.key) {\n\t\t\t\tconst field = map.get(config.key)!;\n\t\t\t\tconst name = field.map || config.key;\n\t\t\t\t(params[field.in] as Record<string, unknown>)[name] = arg;\n\t\t\t} else {\n\t\t\t\tparams.body = arg;\n\t\t\t}\n\t\t} else {\n\t\t\tfor (const [key, value] of Object.entries(arg ?? {})) {\n\t\t\t\tconst field = map.get(key);\n\n\t\t\t\tif (field) {\n\t\t\t\t\tconst name = field.map || key;\n\t\t\t\t\t(params[field.in] as Record<string, unknown>)[name] = value;\n\t\t\t\t} else {\n\t\t\t\t\tconst extra = extraPrefixes.find(([prefix]) =>\n\t\t\t\t\t\tkey.startsWith(prefix),\n\t\t\t\t\t);\n\n\t\t\t\t\tif (extra) {\n\t\t\t\t\t\tconst [prefix, slot] = extra;\n\t\t\t\t\t\t(params[slot] as Record<string, unknown>)[\n\t\t\t\t\t\t\tkey.slice(prefix.length)\n\t\t\t\t\t\t] = value;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfor (const [slot, allowed] of Object.entries(\n\t\t\t\t\t\t\tconfig.allowExtra ?? {},\n\t\t\t\t\t\t)) {\n\t\t\t\t\t\t\tif (allowed) {\n\t\t\t\t\t\t\t\t(params[slot as Slot] as Record<string, unknown>)[key] = value;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tstripEmptySlots(params);\n\n\treturn params;\n};\n", "export type AuthToken = string | undefined;\n\nexport interface Auth {\n\t/**\n\t * Which part of the request do we use to send the auth?\n\t *\n\t * @default 'header'\n\t */\n\tin?: \"header\" | \"query\" | \"cookie\";\n\t/**\n\t * Header or query parameter name.\n\t *\n\t * @default 'Authorization'\n\t */\n\tname?: string;\n\tscheme?: \"basic\" | \"bearer\";\n\ttype: \"apiKey\" | \"http\";\n}\n\nexport const getAuthToken = async (\n\tauth: Auth,\n\tcallback: ((auth: Auth) => Promise<AuthToken> | AuthToken) | AuthToken,\n): Promise<string | undefined> => {\n\tconst token =\n\t\ttypeof callback === \"function\" ? await callback(auth) : callback;\n\n\tif (!token) {\n\t\treturn;\n\t}\n\n\tif (auth.scheme === \"bearer\") {\n\t\treturn `Bearer ${token}`;\n\t}\n\n\tif (auth.scheme === \"basic\") {\n\t\treturn `Basic ${btoa(token)}`;\n\t}\n\n\treturn token;\n};\n", "interface SerializeOptions<T>\n\textends SerializePrimitiveOptions,\n\t\tSerializerOptions<T> {}\n\ninterface SerializePrimitiveOptions {\n\tallowReserved?: boolean;\n\tname: string;\n}\n\nexport interface SerializerOptions<T> {\n\t/**\n\t * @default true\n\t */\n\texplode: boolean;\n\tstyle: T;\n}\n\nexport type ArrayStyle = \"form\" | \"spaceDelimited\" | \"pipeDelimited\";\nexport type ArraySeparatorStyle = ArrayStyle | MatrixStyle;\ntype MatrixStyle = \"label\" | \"matrix\" | \"simple\";\nexport type ObjectStyle = \"form\" | \"deepObject\";\ntype ObjectSeparatorStyle = ObjectStyle | MatrixStyle;\n\ninterface SerializePrimitiveParam extends SerializePrimitiveOptions {\n\tvalue: string;\n}\n\nexport const separatorArrayExplode = (style: ArraySeparatorStyle) => {\n\tswitch (style) {\n\t\tcase \"label\":\n\t\t\treturn \".\";\n\t\tcase \"matrix\":\n\t\t\treturn \";\";\n\t\tcase \"simple\":\n\t\t\treturn \",\";\n\t\tdefault:\n\t\t\treturn \"&\";\n\t}\n};\n\nexport const separatorArrayNoExplode = (style: ArraySeparatorStyle) => {\n\tswitch (style) {\n\t\tcase \"form\":\n\t\t\treturn \",\";\n\t\tcase \"pipeDelimited\":\n\t\t\treturn \"|\";\n\t\tcase \"spaceDelimited\":\n\t\t\treturn \"%20\";\n\t\tdefault:\n\t\t\treturn \",\";\n\t}\n};\n\nexport const separatorObjectExplode = (style: ObjectSeparatorStyle) => {\n\tswitch (style) {\n\t\tcase \"label\":\n\t\t\treturn \".\";\n\t\tcase \"matrix\":\n\t\t\treturn \";\";\n\t\tcase \"simple\":\n\t\t\treturn \",\";\n\t\tdefault:\n\t\t\treturn \"&\";\n\t}\n};\n\nexport const serializeArrayParam = ({\n\tallowReserved,\n\texplode,\n\tname,\n\tstyle,\n\tvalue,\n}: SerializeOptions<ArraySeparatorStyle> & {\n\tvalue: unknown[];\n}) => {\n\tif (!explode) {\n\t\tconst joinedValues = (\n\t\t\tallowReserved ? value : value.map((v) => encodeURIComponent(v as string))\n\t\t).join(separatorArrayNoExplode(style));\n\t\tswitch (style) {\n\t\t\tcase \"label\":\n\t\t\t\treturn `.${joinedValues}`;\n\t\t\tcase \"matrix\":\n\t\t\t\treturn `;${name}=${joinedValues}`;\n\t\t\tcase \"simple\":\n\t\t\t\treturn joinedValues;\n\t\t\tdefault:\n\t\t\t\treturn `${name}=${joinedValues}`;\n\t\t}\n\t}\n\n\tconst separator = separatorArrayExplode(style);\n\tconst joinedValues = value\n\t\t.map((v) => {\n\t\t\tif (style === \"label\" || style === \"simple\") {\n\t\t\t\treturn allowReserved ? v : encodeURIComponent(v as string);\n\t\t\t}\n\n\t\t\treturn serializePrimitiveParam({\n\t\t\t\tallowReserved,\n\t\t\t\tname,\n\t\t\t\tvalue: v as string,\n\t\t\t});\n\t\t})\n\t\t.join(separator);\n\treturn style === \"label\" || style === \"matrix\"\n\t\t? separator + joinedValues\n\t\t: joinedValues;\n};\n\nexport const serializePrimitiveParam = ({\n\tallowReserved,\n\tname,\n\tvalue,\n}: SerializePrimitiveParam) => {\n\tif (value === undefined || value === null) {\n\t\treturn \"\";\n\t}\n\n\tif (typeof value === \"object\") {\n\t\tthrow new Error(\n\t\t\t\"Deeply-nested arrays/objects arenâ€™t supported. Provide your own `querySerializer()` to handle these.\",\n\t\t);\n\t}\n\n\treturn `${name}=${allowReserved ? value : encodeURIComponent(value)}`;\n};\n\nexport const serializeObjectParam = ({\n\tallowReserved,\n\texplode,\n\tname,\n\tstyle,\n\tvalue,\n\tvalueOnly,\n}: SerializeOptions<ObjectSeparatorStyle> & {\n\tvalue: Record<string, unknown> | Date;\n\tvalueOnly?: boolean;\n}) => {\n\tif (value instanceof Date) {\n\t\treturn valueOnly ? value.toISOString() : `${name}=${value.toISOString()}`;\n\t}\n\n\tif (style !== \"deepObject\" && !explode) {\n\t\tlet values: string[] = [];\n\t\tObject.entries(value).forEach(([key, v]) => {\n\t\t\tvalues = [\n\t\t\t\t...values,\n\t\t\t\tkey,\n\t\t\t\tallowReserved ? (v as string) : encodeURIComponent(v as string),\n\t\t\t];\n\t\t});\n\t\tconst joinedValues = values.join(\",\");\n\t\tswitch (style) {\n\t\t\tcase \"form\":\n\t\t\t\treturn `${name}=${joinedValues}`;\n\t\t\tcase \"label\":\n\t\t\t\treturn `.${joinedValues}`;\n\t\t\tcase \"matrix\":\n\t\t\t\treturn `;${name}=${joinedValues}`;\n\t\t\tdefault:\n\t\t\t\treturn joinedValues;\n\t\t}\n\t}\n\n\tconst separator = separatorObjectExplode(style);\n\tconst joinedValues = Object.entries(value)\n\t\t.map(([key, v]) =>\n\t\t\tserializePrimitiveParam({\n\t\t\t\tallowReserved,\n\t\t\t\tname: style === \"deepObject\" ? `${name}[${key}]` : key,\n\t\t\t\tvalue: v as string,\n\t\t\t}),\n\t\t)\n\t\t.join(separator);\n\treturn style === \"label\" || style === \"matrix\"\n\t\t? separator + joinedValues\n\t\t: joinedValues;\n};\n", "import { getAuthToken } from \"../core/auth.js\";\nimport type {\n\tQuerySerializer,\n\tQuerySerializerOptions,\n} from \"../core/bodySerializer.js\";\nimport { jsonBodySerializer } from \"../core/bodySerializer.js\";\nimport {\n\tserializeArrayParam,\n\tserializeObjectParam,\n\tserializePrimitiveParam,\n} from \"../core/pathSerializer.js\";\nimport type { Client, ClientOptions, Config, RequestOptions } from \"./types.js\";\n\ninterface PathSerializer {\n\tpath: Record<string, unknown>;\n\turl: string;\n}\n\nconst PATH_PARAM_RE = /\\{[^{}]+\\}/g;\n\ntype ArrayStyle = \"form\" | \"spaceDelimited\" | \"pipeDelimited\";\ntype MatrixStyle = \"label\" | \"matrix\" | \"simple\";\ntype ArraySeparatorStyle = ArrayStyle | MatrixStyle;\n\nconst defaultPathSerializer = ({ path, url: _url }: PathSerializer) => {\n\tlet url = _url;\n\tconst matches = _url.match(PATH_PARAM_RE);\n\tif (matches) {\n\t\tfor (const match of matches) {\n\t\t\tlet explode = false;\n\t\t\tlet name = match.substring(1, match.length - 1);\n\t\t\tlet style: ArraySeparatorStyle = \"simple\";\n\n\t\t\tif (name.endsWith(\"*\")) {\n\t\t\t\texplode = true;\n\t\t\t\tname = name.substring(0, name.length - 1);\n\t\t\t}\n\n\t\t\tif (name.startsWith(\".\")) {\n\t\t\t\tname = name.substring(1);\n\t\t\t\tstyle = \"label\";\n\t\t\t} else if (name.startsWith(\";\")) {\n\t\t\t\tname = name.substring(1);\n\t\t\t\tstyle = \"matrix\";\n\t\t\t}\n\n\t\t\tconst value = path[name];\n\n\t\t\tif (value === undefined || value === null) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (Array.isArray(value)) {\n\t\t\t\turl = url.replace(\n\t\t\t\t\tmatch,\n\t\t\t\t\tserializeArrayParam({ explode, name, style, value }),\n\t\t\t\t);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (typeof value === \"object\") {\n\t\t\t\turl = url.replace(\n\t\t\t\t\tmatch,\n\t\t\t\t\tserializeObjectParam({\n\t\t\t\t\t\texplode,\n\t\t\t\t\t\tname,\n\t\t\t\t\t\tstyle,\n\t\t\t\t\t\tvalue: value as Record<string, unknown>,\n\t\t\t\t\t\tvalueOnly: true,\n\t\t\t\t\t}),\n\t\t\t\t);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (style === \"matrix\") {\n\t\t\t\turl = url.replace(\n\t\t\t\t\tmatch,\n\t\t\t\t\t`;${serializePrimitiveParam({\n\t\t\t\t\t\tname,\n\t\t\t\t\t\tvalue: value as string,\n\t\t\t\t\t})}`,\n\t\t\t\t);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst replaceValue = encodeURIComponent(\n\t\t\t\tstyle === \"label\" ? `.${value as string}` : (value as string),\n\t\t\t);\n\t\t\turl = url.replace(match, replaceValue);\n\t\t}\n\t}\n\treturn url;\n};\n\nexport const createQuerySerializer = <T = unknown>({\n\tallowReserved,\n\tarray,\n\tobject,\n}: QuerySerializerOptions = {}) => {\n\tconst querySerializer = (queryParams: T) => {\n\t\tconst search: string[] = [];\n\t\tif (queryParams && typeof queryParams === \"object\") {\n\t\t\tfor (const name in queryParams) {\n\t\t\t\tconst value = queryParams[name];\n\n\t\t\t\tif (value === undefined || value === null) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (Array.isArray(value)) {\n\t\t\t\t\tconst serializedArray = serializeArrayParam({\n\t\t\t\t\t\tallowReserved,\n\t\t\t\t\t\texplode: true,\n\t\t\t\t\t\tname,\n\t\t\t\t\t\tstyle: \"form\",\n\t\t\t\t\t\tvalue,\n\t\t\t\t\t\t...array,\n\t\t\t\t\t});\n\t\t\t\t\tif (serializedArray) search.push(serializedArray);\n\t\t\t\t} else if (typeof value === \"object\") {\n\t\t\t\t\tconst serializedObject = serializeObjectParam({\n\t\t\t\t\t\tallowReserved,\n\t\t\t\t\t\texplode: true,\n\t\t\t\t\t\tname,\n\t\t\t\t\t\tstyle: \"deepObject\",\n\t\t\t\t\t\tvalue: value as Record<string, unknown>,\n\t\t\t\t\t\t...object,\n\t\t\t\t\t});\n\t\t\t\t\tif (serializedObject) search.push(serializedObject);\n\t\t\t\t} else {\n\t\t\t\t\tconst serializedPrimitive = serializePrimitiveParam({\n\t\t\t\t\t\tallowReserved,\n\t\t\t\t\t\tname,\n\t\t\t\t\t\tvalue: value as string,\n\t\t\t\t\t});\n\t\t\t\t\tif (serializedPrimitive) search.push(serializedPrimitive);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn search.join(\"&\");\n\t};\n\treturn querySerializer;\n};\n\n/**\n * Infers parseAs value from provided Content-Type header.\n */\nexport const getParseAs = (\n\tcontentType: string | null,\n): Exclude<Config[\"parseAs\"], \"auto\"> => {\n\tif (!contentType) {\n\t\t// If no Content-Type header is provided, the best we can do is return the raw response body,\n\t\t// which is effectively the same as the 'stream' option.\n\t\treturn \"stream\";\n\t}\n\n\tconst cleanContent = contentType.split(\";\")[0]?.trim();\n\n\tif (!cleanContent) {\n\t\treturn;\n\t}\n\n\tif (\n\t\tcleanContent.startsWith(\"application/json\") ||\n\t\tcleanContent.endsWith(\"+json\")\n\t) {\n\t\treturn \"json\";\n\t}\n\n\tif (cleanContent === \"multipart/form-data\") {\n\t\treturn \"formData\";\n\t}\n\n\tif (\n\t\t[\"application/\", \"audio/\", \"image/\", \"video/\"].some((type) =>\n\t\t\tcleanContent.startsWith(type),\n\t\t)\n\t) {\n\t\treturn \"blob\";\n\t}\n\n\tif (cleanContent.startsWith(\"text/\")) {\n\t\treturn \"text\";\n\t}\n\n\treturn;\n};\n\nexport const setAuthParams = async ({\n\tsecurity,\n\t...options\n}: Pick<Required<RequestOptions>, \"security\"> &\n\tPick<RequestOptions, \"auth\" | \"query\"> & {\n\t\theaders: Headers;\n\t}) => {\n\tfor (const auth of security) {\n\t\tconst token = await getAuthToken(auth, options.auth);\n\n\t\tif (!token) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst name = auth.name ?? \"Authorization\";\n\n\t\tswitch (auth.in) {\n\t\t\tcase \"query\":\n\t\t\t\tif (!options.query) {\n\t\t\t\t\toptions.query = {};\n\t\t\t\t}\n\t\t\t\toptions.query[name] = token;\n\t\t\t\tbreak;\n\t\t\tcase \"cookie\":\n\t\t\t\toptions.headers.append(\"Cookie\", `${name}=${token}`);\n\t\t\t\tbreak;\n\t\t\tcase \"header\":\n\t\t\tdefault:\n\t\t\t\toptions.headers.set(name, token);\n\t\t\t\tbreak;\n\t\t}\n\n\t\treturn;\n\t}\n};\n\nexport const buildUrl: Client[\"buildUrl\"] = (options) => {\n\tconst url = getUrl({\n\t\tbaseUrl: options.baseUrl as string,\n\t\tpath: options.path,\n\t\tquery: options.query,\n\t\tquerySerializer:\n\t\t\ttypeof options.querySerializer === \"function\"\n\t\t\t\t? options.querySerializer\n\t\t\t\t: createQuerySerializer(options.querySerializer),\n\t\turl: options.url,\n\t});\n\treturn url;\n};\n\nexport const getUrl = ({\n\tbaseUrl,\n\tpath,\n\tquery,\n\tquerySerializer,\n\turl: _url,\n}: {\n\tbaseUrl?: string;\n\tpath?: Record<string, unknown>;\n\tquery?: Record<string, unknown>;\n\tquerySerializer: QuerySerializer;\n\turl: string;\n}) => {\n\tconst pathUrl = _url.startsWith(\"/\") ? _url : `/${_url}`;\n\tlet url = (baseUrl ?? \"\") + pathUrl;\n\tif (path) {\n\t\turl = defaultPathSerializer({ path, url });\n\t}\n\tlet search = query ? querySerializer(query) : \"\";\n\tif (search.startsWith(\"?\")) {\n\t\tsearch = search.substring(1);\n\t}\n\tif (search) {\n\t\turl += `?${search}`;\n\t}\n\treturn url;\n};\n\nexport const mergeConfigs = (a: Config, b: Config): Config => {\n\tconst config = { ...a, ...b };\n\tif (config.baseUrl?.endsWith(\"/\")) {\n\t\tconfig.baseUrl = config.baseUrl.substring(0, config.baseUrl.length - 1);\n\t}\n\tconfig.headers = mergeHeaders(a.headers, b.headers);\n\treturn config;\n};\n\nexport const mergeHeaders = (\n\t...headers: Array<Required<Config>[\"headers\"] | undefined>\n): Headers => {\n\tconst mergedHeaders = new Headers();\n\tfor (const header of headers) {\n\t\tif (!header || typeof header !== \"object\") {\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst iterator =\n\t\t\theader instanceof Headers ? header.entries() : Object.entries(header);\n\n\t\tfor (const [key, value] of iterator) {\n\t\t\tif (value === null) {\n\t\t\t\tmergedHeaders.delete(key);\n\t\t\t} else if (Array.isArray(value)) {\n\t\t\t\tfor (const v of value) {\n\t\t\t\t\tmergedHeaders.append(key, v as string);\n\t\t\t\t}\n\t\t\t} else if (value !== undefined) {\n\t\t\t\t// assume object headers are meant to be JSON stringified, i.e. their\n\t\t\t\t// content value in OpenAPI specification is 'application/json'\n\t\t\t\tmergedHeaders.set(\n\t\t\t\t\tkey,\n\t\t\t\t\ttypeof value === \"object\" ? JSON.stringify(value) : (value as string),\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\treturn mergedHeaders;\n};\n\ntype ErrInterceptor<Err, Res, Req, Options> = (\n\terror: Err,\n\tresponse: Res,\n\trequest: Req,\n\toptions: Options,\n) => Err | Promise<Err>;\n\ntype ReqInterceptor<Req, Options> = (\n\trequest: Req,\n\toptions: Options,\n) => Req | Promise<Req>;\n\ntype ResInterceptor<Res, Req, Options> = (\n\tresponse: Res,\n\trequest: Req,\n\toptions: Options,\n) => Res | Promise<Res>;\n\nclass Interceptors<Interceptor> {\n\t_fns: (Interceptor | null)[];\n\n\tconstructor() {\n\t\tthis._fns = [];\n\t}\n\n\tclear() {\n\t\tthis._fns = [];\n\t}\n\n\tgetInterceptorIndex(id: number | Interceptor): number {\n\t\tif (typeof id === \"number\") {\n\t\t\treturn this._fns[id] ? id : -1;\n\t\t} else {\n\t\t\treturn this._fns.indexOf(id);\n\t\t}\n\t}\n\texists(id: number | Interceptor) {\n\t\tconst index = this.getInterceptorIndex(id);\n\t\treturn !!this._fns[index];\n\t}\n\n\teject(id: number | Interceptor) {\n\t\tconst index = this.getInterceptorIndex(id);\n\t\tif (this._fns[index]) {\n\t\t\tthis._fns[index] = null;\n\t\t}\n\t}\n\n\tupdate(id: number | Interceptor, fn: Interceptor) {\n\t\tconst index = this.getInterceptorIndex(id);\n\t\tif (this._fns[index]) {\n\t\t\tthis._fns[index] = fn;\n\t\t\treturn id;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tuse(fn: Interceptor) {\n\t\tthis._fns = [...this._fns, fn];\n\t\treturn this._fns.length - 1;\n\t}\n}\n\n// `createInterceptors()` response, meant for external use as it does not\n// expose internals\nexport interface Middleware<Req, Res, Err, Options> {\n\terror: Pick<\n\t\tInterceptors<ErrInterceptor<Err, Res, Req, Options>>,\n\t\t\"eject\" | \"use\"\n\t>;\n\trequest: Pick<Interceptors<ReqInterceptor<Req, Options>>, \"eject\" | \"use\">;\n\tresponse: Pick<\n\t\tInterceptors<ResInterceptor<Res, Req, Options>>,\n\t\t\"eject\" | \"use\"\n\t>;\n}\n\n// do not add `Middleware` as return type so we can use _fns internally\nexport const createInterceptors = <Req, Res, Err, Options>() => ({\n\terror: new Interceptors<ErrInterceptor<Err, Res, Req, Options>>(),\n\trequest: new Interceptors<ReqInterceptor<Req, Options>>(),\n\tresponse: new Interceptors<ResInterceptor<Res, Req, Options>>(),\n});\n\nconst defaultQuerySerializer = createQuerySerializer({\n\tallowReserved: false,\n\tarray: {\n\t\texplode: true,\n\t\tstyle: \"form\",\n\t},\n\tobject: {\n\t\texplode: true,\n\t\tstyle: \"deepObject\",\n\t},\n});\n\nconst defaultHeaders = {\n\t\"Content-Type\": \"application/json\",\n};\n\nexport const createConfig = <T extends ClientOptions = ClientOptions>(\n\toverride: Config<Omit<ClientOptions, keyof T> & T> = {},\n): Config<Omit<ClientOptions, keyof T> & T> => ({\n\t...jsonBodySerializer,\n\theaders: defaultHeaders,\n\tparseAs: \"auto\",\n\tquerySerializer: defaultQuerySerializer,\n\t...override,\n});\n", "import type { Client, Config, RequestOptions } from \"./types.js\";\nimport {\n\tbuildUrl,\n\tcreateConfig,\n\tcreateInterceptors,\n\tgetParseAs,\n\tmergeConfigs,\n\tmergeHeaders,\n\tsetAuthParams,\n} from \"./utils.js\";\n\ntype ReqInit = Omit<RequestInit, \"body\" | \"headers\"> & {\n\tbody?: any;\n\theaders: ReturnType<typeof mergeHeaders>;\n};\n\nexport const createClient = (config: Config = {}): Client => {\n\tlet _config = mergeConfigs(createConfig(), config);\n\n\tconst getConfig = (): Config => ({ ..._config });\n\n\tconst setConfig = (config: Config): Config => {\n\t\t_config = mergeConfigs(_config, config);\n\t\treturn getConfig();\n\t};\n\n\tconst interceptors = createInterceptors<\n\t\tRequest,\n\t\tResponse,\n\t\tunknown,\n\t\tRequestOptions\n\t>();\n\n\tconst request: Client[\"request\"] = async (options) => {\n\t\tconst opts = {\n\t\t\t..._config,\n\t\t\t...options,\n\t\t\tfetch: options.fetch ?? _config.fetch ?? globalThis.fetch,\n\t\t\theaders: mergeHeaders(_config.headers, options.headers),\n\t\t};\n\n\t\tif (opts.security) {\n\t\t\tawait setAuthParams({\n\t\t\t\t...opts,\n\t\t\t\tsecurity: opts.security,\n\t\t\t});\n\t\t}\n\n\t\tif (opts.body && opts.bodySerializer) {\n\t\t\topts.body = opts.bodySerializer(opts.body);\n\t\t}\n\n\t\t// remove Content-Type header if body is empty to avoid sending invalid requests\n\t\tif (opts.body === undefined || opts.body === \"\") {\n\t\t\topts.headers.delete(\"Content-Type\");\n\t\t}\n\n\t\tconst url = buildUrl(opts);\n\t\tconst requestInit: ReqInit = {\n\t\t\tredirect: \"follow\",\n\t\t\t...opts,\n\t\t};\n\n\t\tlet request = new Request(url, requestInit);\n\n\t\tfor (const fn of interceptors.request._fns) {\n\t\t\tif (fn) {\n\t\t\t\trequest = await fn(request, opts);\n\t\t\t}\n\t\t}\n\n\t\t// fetch must be assigned here, otherwise it would throw the error:\n\t\t// TypeError: Failed to execute 'fetch' on 'Window': Illegal invocation\n\t\tconst _fetch = opts.fetch!;\n\t\tlet response = await _fetch(request);\n\n\t\tfor (const fn of interceptors.response._fns) {\n\t\t\tif (fn) {\n\t\t\t\tresponse = await fn(response, request, opts);\n\t\t\t}\n\t\t}\n\n\t\tconst result = {\n\t\t\trequest,\n\t\t\tresponse,\n\t\t};\n\n\t\tif (response.ok) {\n\t\t\tif (\n\t\t\t\tresponse.status === 204 ||\n\t\t\t\tresponse.headers.get(\"Content-Length\") === \"0\"\n\t\t\t) {\n\t\t\t\treturn opts.responseStyle === \"data\"\n\t\t\t\t\t? {}\n\t\t\t\t\t: {\n\t\t\t\t\t\t\tdata: {},\n\t\t\t\t\t\t\t...result,\n\t\t\t\t\t\t};\n\t\t\t}\n\n\t\t\tconst parseAs =\n\t\t\t\t(opts.parseAs === \"auto\"\n\t\t\t\t\t? getParseAs(response.headers.get(\"Content-Type\"))\n\t\t\t\t\t: opts.parseAs) ?? \"json\";\n\n\t\t\tlet data: any;\n\t\t\tswitch (parseAs) {\n\t\t\t\tcase \"arrayBuffer\":\n\t\t\t\tcase \"blob\":\n\t\t\t\tcase \"formData\":\n\t\t\t\tcase \"json\":\n\t\t\t\tcase \"text\":\n\t\t\t\t\tdata = await response[parseAs]();\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"stream\":\n\t\t\t\t\treturn opts.responseStyle === \"data\"\n\t\t\t\t\t\t? response.body\n\t\t\t\t\t\t: {\n\t\t\t\t\t\t\t\tdata: response.body,\n\t\t\t\t\t\t\t\t...result,\n\t\t\t\t\t\t\t};\n\t\t\t}\n\n\t\t\tif (parseAs === \"json\") {\n\t\t\t\tif (opts.responseValidator) {\n\t\t\t\t\tawait opts.responseValidator(data);\n\t\t\t\t}\n\n\t\t\t\tif (opts.responseTransformer) {\n\t\t\t\t\tdata = await opts.responseTransformer(data);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn opts.responseStyle === \"data\"\n\t\t\t\t? data\n\t\t\t\t: {\n\t\t\t\t\t\tdata,\n\t\t\t\t\t\t...result,\n\t\t\t\t\t};\n\t\t}\n\n\t\tlet error = await response.text();\n\n\t\ttry {\n\t\t\terror = JSON.parse(error);\n\t\t} catch {\n\t\t\t// noop\n\t\t}\n\n\t\tlet finalError = error;\n\n\t\tfor (const fn of interceptors.error._fns) {\n\t\t\tif (fn) {\n\t\t\t\tfinalError = (await fn(error, response, request, opts)) as string;\n\t\t\t}\n\t\t}\n\n\t\tfinalError = finalError || ({} as string);\n\n\t\tif (opts.throwOnError) {\n\t\t\tthrow finalError;\n\t\t}\n\n\t\t// TODO: we probably want to return error and improve types\n\t\treturn opts.responseStyle === \"data\"\n\t\t\t? undefined\n\t\t\t: {\n\t\t\t\t\terror: finalError,\n\t\t\t\t\t...result,\n\t\t\t\t};\n\t};\n\n\treturn {\n\t\tbuildUrl,\n\t\tconnect: (options) => request({ ...options, method: \"CONNECT\" }),\n\t\tdelete: (options) => request({ ...options, method: \"DELETE\" }),\n\t\tget: (options) => request({ ...options, method: \"GET\" }),\n\t\tgetConfig,\n\t\thead: (options) => request({ ...options, method: \"HEAD\" }),\n\t\tinterceptors,\n\t\toptions: (options) => request({ ...options, method: \"OPTIONS\" }),\n\t\tpatch: (options) => request({ ...options, method: \"PATCH\" }),\n\t\tpost: (options) => request({ ...options, method: \"POST\" }),\n\t\tput: (options) => request({ ...options, method: \"PUT\" }),\n\t\trequest,\n\t\tsetConfig,\n\t\ttrace: (options) => request({ ...options, method: \"TRACE\" }),\n\t};\n};\n", "// This file is auto-generated by @hey-api/openapi-ts\n\nimport {\n\ttype Config,\n\tcreateClient,\n\tcreateConfig,\n\ttype ClientOptions as DefaultClientOptions,\n} from \"./client/index.js\";\nimport type { ClientOptions } from \"./types.gen.js\";\n\n/**\n * The `createClientConfig()` function will be called on client initialization\n * and the returned object will become the client's initial configuration.\n *\n * You may want to initialize your client this way instead of calling\n * `setConfig()`. This is useful for example if you're using Next.js\n * to ensure your client always has the correct values.\n */\nexport type CreateClientConfig<T extends DefaultClientOptions = ClientOptions> =\n\t(\n\t\toverride?: Config<DefaultClientOptions & T>,\n\t) => Config<Required<DefaultClientOptions> & T>;\n\nexport const client = createClient(\n\tcreateConfig<ClientOptions>({\n\t\tbaseUrl: \"https://engine.thirdweb.com\",\n\t}),\n);\n", "// This file is auto-generated by @hey-api/openapi-ts\n\nimport type {\n\tClient,\n\tOptions as ClientOptions,\n\tTDataShape,\n} from \"./client/index.js\";\nimport { client as _heyApiClient } from \"./client.gen.js\";\nimport type {\n\tCancelTransactionData,\n\tCancelTransactionResponses,\n\tCreateAccountData,\n\tCreateAccountResponses,\n\tCreateSolanaAccountData,\n\tCreateSolanaAccountResponses,\n\tEncodeContractData,\n\tEncodeContractResponses,\n\tGetActivityLogsData,\n\tGetActivityLogsErrors,\n\tGetActivityLogsResponses,\n\tGetSolanaActivityLogsData,\n\tGetSolanaActivityLogsErrors,\n\tGetSolanaActivityLogsResponses,\n\tGetSolanaTransactionsData,\n\tGetSolanaTransactionsResponses,\n\tGetTransactionAnalyticsData,\n\tGetTransactionAnalyticsResponses,\n\tGetTransactionAnalyticsSummaryData,\n\tGetTransactionAnalyticsSummaryErrors,\n\tGetTransactionAnalyticsSummaryResponses,\n\tGetTransactionsData,\n\tGetTransactionsResponses,\n\tListAccountsData,\n\tListAccountsResponses,\n\tListSolanaAccountsData,\n\tListSolanaAccountsResponses,\n\tReadContractData,\n\tReadContractResponses,\n\tSearchActivityLogsData,\n\tSearchActivityLogsErrors,\n\tSearchActivityLogsResponses,\n\tSearchSolanaActivityLogsData,\n\tSearchSolanaActivityLogsErrors,\n\tSearchSolanaActivityLogsResponses,\n\tSearchSolanaTransactionsData,\n\tSearchSolanaTransactionsResponses,\n\tSearchTransactionsData,\n\tSearchTransactionsResponses,\n\tSendSolanaTransactionData,\n\tSendSolanaTransactionResponses,\n\tSendTransactionData,\n\tSendTransactionResponses,\n\tSignMessageData,\n\tSignMessageResponses,\n\tSignSolanaMessageData,\n\tSignSolanaMessageResponses,\n\tSignSolanaTransactionData,\n\tSignSolanaTransactionResponses,\n\tSignTypedDataData,\n\tSignTypedDataResponses,\n\tWriteContractData,\n\tWriteContractResponses,\n} from \"./types.gen.js\";\n\nexport type Options<\n\tTData extends TDataShape = TDataShape,\n\tThrowOnError extends boolean = boolean,\n> = ClientOptions<TData, ThrowOnError> & {\n\t/**\n\t * You can provide a client instance returned by `createClient()` instead of\n\t * individual options. This might be also useful if you want to implement a\n\t * custom client.\n\t */\n\tclient?: Client;\n\t/**\n\t * You can pass arbitrary values through the `meta` object. This can be\n\t * used to access values that aren't defined as part of the SDK function.\n\t */\n\tmeta?: Record<string, unknown>;\n};\n\n/**\n * Write Contract\n * Call a contract function with a transaction\n */\nexport const writeContract = <ThrowOnError extends boolean = false>(\n\toptions: Options<WriteContractData, ThrowOnError>,\n) => {\n\treturn (options.client ?? _heyApiClient).post<\n\t\tWriteContractResponses,\n\t\tunknown,\n\t\tThrowOnError\n\t>({\n\t\tsecurity: [\n\t\t\t{\n\t\t\t\tname: \"x-secret-key\",\n\t\t\t\ttype: \"apiKey\",\n\t\t\t},\n\t\t],\n\t\turl: \"/v1/write/contract\",\n\t\t...options,\n\t\theaders: {\n\t\t\t\"Content-Type\": \"application/json\",\n\t\t\t...options.headers,\n\t\t},\n\t});\n};\n\n/**\n * Write Transaction\n * Execute raw transactions\n */\nexport const sendTransaction = <ThrowOnError extends boolean = false>(\n\toptions: Options<SendTransactionData, ThrowOnError>,\n) => {\n\treturn (options.client ?? _heyApiClient).post<\n\t\tSendTransactionResponses,\n\t\tunknown,\n\t\tThrowOnError\n\t>({\n\t\tsecurity: [\n\t\t\t{\n\t\t\t\tname: \"x-secret-key\",\n\t\t\t\ttype: \"apiKey\",\n\t\t\t},\n\t\t],\n\t\turl: \"/v1/write/transaction\",\n\t\t...options,\n\t\theaders: {\n\t\t\t\"Content-Type\": \"application/json\",\n\t\t\t...options.headers,\n\t\t},\n\t});\n};\n\n/**\n * Sign Message\n * Sign messages using either EOA or Smart Account\n */\nexport const signMessage = <ThrowOnError extends boolean = false>(\n\toptions: Options<SignMessageData, ThrowOnError>,\n) => {\n\treturn (options.client ?? _heyApiClient).post<\n\t\tSignMessageResponses,\n\t\tunknown,\n\t\tThrowOnError\n\t>({\n\t\tsecurity: [\n\t\t\t{\n\t\t\t\tname: \"x-secret-key\",\n\t\t\t\ttype: \"apiKey\",\n\t\t\t},\n\t\t],\n\t\turl: \"/v1/sign/message\",\n\t\t...options,\n\t\theaders: {\n\t\t\t\"Content-Type\": \"application/json\",\n\t\t\t...options.headers,\n\t\t},\n\t});\n};\n\n/**\n * Sign Typed Data\n * Sign EIP-712 typed data using either EOA or Smart Account\n */\nexport const signTypedData = <ThrowOnError extends boolean = false>(\n\toptions: Options<SignTypedDataData, ThrowOnError>,\n) => {\n\treturn (options.client ?? _heyApiClient).post<\n\t\tSignTypedDataResponses,\n\t\tunknown,\n\t\tThrowOnError\n\t>({\n\t\tsecurity: [\n\t\t\t{\n\t\t\t\tname: \"x-secret-key\",\n\t\t\t\ttype: \"apiKey\",\n\t\t\t},\n\t\t],\n\t\turl: \"/v1/sign/typed-data\",\n\t\t...options,\n\t\theaders: {\n\t\t\t\"Content-Type\": \"application/json\",\n\t\t\t...options.headers,\n\t\t},\n\t});\n};\n\n/**\n * Read Contract\n * Read from smart contracts with intelligent execution strategy:\n * - Single calls: Always executed directly for efficiency\n * - Multiple calls: Uses multicall by default, or direct calls if disabled\n * - Failed preparations: Returns preparation errors directly\n *\n * If multicall is not specified, it will be used by default. In case of multicall related errors, engine will fallback to direct calls.\n * Only in the case where multicall is explicitly enabled, engine will not fallback to direct calls.\n */\nexport const readContract = <ThrowOnError extends boolean = false>(\n\toptions: Options<ReadContractData, ThrowOnError>,\n) => {\n\treturn (options.client ?? _heyApiClient).post<\n\t\tReadContractResponses,\n\t\tunknown,\n\t\tThrowOnError\n\t>({\n\t\tsecurity: [\n\t\t\t{\n\t\t\t\tname: \"x-secret-key\",\n\t\t\t\ttype: \"apiKey\",\n\t\t\t},\n\t\t],\n\t\turl: \"/v1/read/contract\",\n\t\t...options,\n\t\theaders: {\n\t\t\t\"Content-Type\": \"application/json\",\n\t\t\t...options.headers,\n\t\t},\n\t});\n};\n\n/**\n * Encode Contract\n * Encode contract function calls without execution\n */\nexport const encodeContract = <ThrowOnError extends boolean = false>(\n\toptions: Options<EncodeContractData, ThrowOnError>,\n) => {\n\treturn (options.client ?? _heyApiClient).post<\n\t\tEncodeContractResponses,\n\t\tunknown,\n\t\tThrowOnError\n\t>({\n\t\tsecurity: [\n\t\t\t{\n\t\t\t\tname: \"x-secret-key\",\n\t\t\t\ttype: \"apiKey\",\n\t\t\t},\n\t\t],\n\t\turl: \"/v1/encode/contract\",\n\t\t...options,\n\t\theaders: {\n\t\t\t\"Content-Type\": \"application/json\",\n\t\t\t...options.headers,\n\t\t},\n\t});\n};\n\n/**\n * Send Solana Transaction\n * Execute a Solana transaction with custom instructions\n */\nexport const sendSolanaTransaction = <ThrowOnError extends boolean = false>(\n\toptions: Options<SendSolanaTransactionData, ThrowOnError>,\n) => {\n\treturn (options.client ?? _heyApiClient).post<\n\t\tSendSolanaTransactionResponses,\n\t\tunknown,\n\t\tThrowOnError\n\t>({\n\t\tsecurity: [\n\t\t\t{\n\t\t\t\tname: \"x-secret-key\",\n\t\t\t\ttype: \"apiKey\",\n\t\t\t},\n\t\t],\n\t\turl: \"/v1/solana/transaction\",\n\t\t...options,\n\t\theaders: {\n\t\t\t\"Content-Type\": \"application/json\",\n\t\t\t...options.headers,\n\t\t},\n\t});\n};\n\n/**\n * Cancel Transaction\n * Attempt to cancel a queued transaction. Transactions that have been sent and are waiting for mine cannot be cancelled.\n */\nexport const cancelTransaction = <ThrowOnError extends boolean = false>(\n\toptions: Options<CancelTransactionData, ThrowOnError>,\n) => {\n\treturn (options.client ?? _heyApiClient).post<\n\t\tCancelTransactionResponses,\n\t\tunknown,\n\t\tThrowOnError\n\t>({\n\t\tsecurity: [\n\t\t\t{\n\t\t\t\tname: \"x-secret-key\",\n\t\t\t\ttype: \"apiKey\",\n\t\t\t},\n\t\t],\n\t\turl: \"/v1/transactions/{id}/cancel\",\n\t\t...options,\n\t});\n};\n\n/**\n * List Server Wallets\n * List all engine server wallets for the current project. Returns an array of EOA addresses with their corresponding predicted smart account addresses.\n */\nexport const listAccounts = <ThrowOnError extends boolean = false>(\n\toptions?: Options<ListAccountsData, ThrowOnError>,\n) => {\n\treturn (options?.client ?? _heyApiClient).get<\n\t\tListAccountsResponses,\n\t\tunknown,\n\t\tThrowOnError\n\t>({\n\t\tsecurity: [\n\t\t\t{\n\t\t\t\tname: \"x-secret-key\",\n\t\t\t\ttype: \"apiKey\",\n\t\t\t},\n\t\t],\n\t\turl: \"/v1/accounts\",\n\t\t...options,\n\t});\n};\n\n/**\n * Get or Create Server Wallet\n * Create a new engine server wallet or retrieve an existing one. If the EOA already exists for the given label, it will be returned without creating a new one.\n */\nexport const createAccount = <ThrowOnError extends boolean = false>(\n\toptions?: Options<CreateAccountData, ThrowOnError>,\n) => {\n\treturn (options?.client ?? _heyApiClient).post<\n\t\tCreateAccountResponses,\n\t\tunknown,\n\t\tThrowOnError\n\t>({\n\t\tsecurity: [\n\t\t\t{\n\t\t\t\tname: \"x-secret-key\",\n\t\t\t\ttype: \"apiKey\",\n\t\t\t},\n\t\t],\n\t\turl: \"/v1/accounts\",\n\t\t...options,\n\t\theaders: {\n\t\t\t\"Content-Type\": \"application/json\",\n\t\t\t...options?.headers,\n\t\t},\n\t});\n};\n\n/**\n * List Solana Accounts\n * List all Solana wallets provisioned for the project.\n */\nexport const listSolanaAccounts = <ThrowOnError extends boolean = false>(\n\toptions?: Options<ListSolanaAccountsData, ThrowOnError>,\n) => {\n\treturn (options?.client ?? _heyApiClient).get<\n\t\tListSolanaAccountsResponses,\n\t\tunknown,\n\t\tThrowOnError\n\t>({\n\t\tsecurity: [\n\t\t\t{\n\t\t\t\tname: \"x-secret-key\",\n\t\t\t\ttype: \"apiKey\",\n\t\t\t},\n\t\t],\n\t\turl: \"/v1/solana/accounts\",\n\t\t...options,\n\t});\n};\n\n/**\n * Get or Create Solana Account\n * Create a new solana wallet in the vault or return the existing wallet for a given label.\n */\nexport const createSolanaAccount = <ThrowOnError extends boolean = false>(\n\toptions?: Options<CreateSolanaAccountData, ThrowOnError>,\n) => {\n\treturn (options?.client ?? _heyApiClient).post<\n\t\tCreateSolanaAccountResponses,\n\t\tunknown,\n\t\tThrowOnError\n\t>({\n\t\tsecurity: [\n\t\t\t{\n\t\t\t\tname: \"x-secret-key\",\n\t\t\t\ttype: \"apiKey\",\n\t\t\t},\n\t\t],\n\t\turl: \"/v1/solana/accounts\",\n\t\t...options,\n\t\theaders: {\n\t\t\t\"Content-Type\": \"application/json\",\n\t\t\t...options?.headers,\n\t\t},\n\t});\n};\n\n/**\n * Sign Solana Message\n * Sign an arbitrary message with a Solana wallet.\n */\nexport const signSolanaMessage = <ThrowOnError extends boolean = false>(\n\toptions?: Options<SignSolanaMessageData, ThrowOnError>,\n) => {\n\treturn (options?.client ?? _heyApiClient).post<\n\t\tSignSolanaMessageResponses,\n\t\tunknown,\n\t\tThrowOnError\n\t>({\n\t\tsecurity: [\n\t\t\t{\n\t\t\t\tname: \"x-secret-key\",\n\t\t\t\ttype: \"apiKey\",\n\t\t\t},\n\t\t],\n\t\turl: \"/v1/solana/sign-message\",\n\t\t...options,\n\t\theaders: {\n\t\t\t\"Content-Type\": \"application/json\",\n\t\t\t...options?.headers,\n\t\t},\n\t});\n};\n\n/**\n * Sign Solana Transaction\n * Sign a serialized Solana transaction.\n */\nexport const signSolanaTransaction = <ThrowOnError extends boolean = false>(\n\toptions?: Options<SignSolanaTransactionData, ThrowOnError>,\n) => {\n\treturn (options?.client ?? _heyApiClient).post<\n\t\tSignSolanaTransactionResponses,\n\t\tunknown,\n\t\tThrowOnError\n\t>({\n\t\tsecurity: [\n\t\t\t{\n\t\t\t\tname: \"x-secret-key\",\n\t\t\t\ttype: \"apiKey\",\n\t\t\t},\n\t\t],\n\t\turl: \"/v1/solana/sign-transaction\",\n\t\t...options,\n\t\theaders: {\n\t\t\t\"Content-Type\": \"application/json\",\n\t\t\t...options?.headers,\n\t\t},\n\t});\n};\n\n/**\n * Get Transactions\n * Search transactions with various filters and pagination\n */\nexport const getTransactions = <ThrowOnError extends boolean = false>(\n\toptions?: Options<GetTransactionsData, ThrowOnError>,\n) => {\n\treturn (options?.client ?? _heyApiClient).get<\n\t\tGetTransactionsResponses,\n\t\tunknown,\n\t\tThrowOnError\n\t>({\n\t\tsecurity: [\n\t\t\t{\n\t\t\t\tname: \"x-secret-key\",\n\t\t\t\ttype: \"apiKey\",\n\t\t\t},\n\t\t],\n\t\turl: \"/v1/transactions\",\n\t\t...options,\n\t});\n};\n\n/**\n * Transaction Analytics\n * Get transaction count analytics over time with filtering\n */\nexport const getTransactionAnalytics = <ThrowOnError extends boolean = false>(\n\toptions?: Options<GetTransactionAnalyticsData, ThrowOnError>,\n) => {\n\treturn (options?.client ?? _heyApiClient).post<\n\t\tGetTransactionAnalyticsResponses,\n\t\tunknown,\n\t\tThrowOnError\n\t>({\n\t\tsecurity: [\n\t\t\t{\n\t\t\t\tname: \"x-secret-key\",\n\t\t\t\ttype: \"apiKey\",\n\t\t\t},\n\t\t],\n\t\turl: \"/v1/transactions/analytics\",\n\t\t...options,\n\t\theaders: {\n\t\t\t\"Content-Type\": \"application/json\",\n\t\t\t...options?.headers,\n\t\t},\n\t});\n};\n\n/**\n * Transaction Analytics Summary\n * Get a summary (total count and total gas calculation) for transactions within a time range, supporting complex nested filters.\n */\nexport const getTransactionAnalyticsSummary = <\n\tThrowOnError extends boolean = false,\n>(\n\toptions?: Options<GetTransactionAnalyticsSummaryData, ThrowOnError>,\n) => {\n\treturn (options?.client ?? _heyApiClient).post<\n\t\tGetTransactionAnalyticsSummaryResponses,\n\t\tGetTransactionAnalyticsSummaryErrors,\n\t\tThrowOnError\n\t>({\n\t\tsecurity: [\n\t\t\t{\n\t\t\t\tname: \"x-secret-key\",\n\t\t\t\ttype: \"apiKey\",\n\t\t\t},\n\t\t],\n\t\turl: \"/v1/transactions/analytics-summary\",\n\t\t...options,\n\t\theaders: {\n\t\t\t\"Content-Type\": \"application/json\",\n\t\t\t...options?.headers,\n\t\t},\n\t});\n};\n\n/**\n * Search Transactions\n * Advanced search for transactions with complex nested filters\n */\nexport const searchTransactions = <ThrowOnError extends boolean = false>(\n\toptions?: Options<SearchTransactionsData, ThrowOnError>,\n) => {\n\treturn (options?.client ?? _heyApiClient).post<\n\t\tSearchTransactionsResponses,\n\t\tunknown,\n\t\tThrowOnError\n\t>({\n\t\tsecurity: [\n\t\t\t{\n\t\t\t\tname: \"x-secret-key\",\n\t\t\t\ttype: \"apiKey\",\n\t\t\t},\n\t\t],\n\t\turl: \"/v1/transactions/search\",\n\t\t...options,\n\t\theaders: {\n\t\t\t\"Content-Type\": \"application/json\",\n\t\t\t...options?.headers,\n\t\t},\n\t});\n};\n\n/**\n * Get Activity Logs\n * Get paginated activity logs for a specific transaction with tenancy enforcement\n */\nexport const getActivityLogs = <ThrowOnError extends boolean = false>(\n\toptions: Options<GetActivityLogsData, ThrowOnError>,\n) => {\n\treturn (options.client ?? _heyApiClient).get<\n\t\tGetActivityLogsResponses,\n\t\tGetActivityLogsErrors,\n\t\tThrowOnError\n\t>({\n\t\tsecurity: [\n\t\t\t{\n\t\t\t\tname: \"x-secret-key\",\n\t\t\t\ttype: \"apiKey\",\n\t\t\t},\n\t\t],\n\t\turl: \"/v1/transactions/activity-logs\",\n\t\t...options,\n\t});\n};\n\n/**\n * Search Activity Logs\n * Search activity logs across transactions with advanced filtering and tenancy enforcement\n */\nexport const searchActivityLogs = <ThrowOnError extends boolean = false>(\n\toptions?: Options<SearchActivityLogsData, ThrowOnError>,\n) => {\n\treturn (options?.client ?? _heyApiClient).post<\n\t\tSearchActivityLogsResponses,\n\t\tSearchActivityLogsErrors,\n\t\tThrowOnError\n\t>({\n\t\tsecurity: [\n\t\t\t{\n\t\t\t\tname: \"x-secret-key\",\n\t\t\t\ttype: \"apiKey\",\n\t\t\t},\n\t\t],\n\t\turl: \"/v1/transactions/activity-logs/search\",\n\t\t...options,\n\t\theaders: {\n\t\t\t\"Content-Type\": \"application/json\",\n\t\t\t...options?.headers,\n\t\t},\n\t});\n};\n\n/**\n * Get Solana Transactions\n * Search Solana transactions with various filters and pagination\n */\nexport const getSolanaTransactions = <ThrowOnError extends boolean = false>(\n\toptions?: Options<GetSolanaTransactionsData, ThrowOnError>,\n) => {\n\treturn (options?.client ?? _heyApiClient).get<\n\t\tGetSolanaTransactionsResponses,\n\t\tunknown,\n\t\tThrowOnError\n\t>({\n\t\tsecurity: [\n\t\t\t{\n\t\t\t\tname: \"x-secret-key\",\n\t\t\t\ttype: \"apiKey\",\n\t\t\t},\n\t\t],\n\t\turl: \"/v1/solana/transactions\",\n\t\t...options,\n\t});\n};\n\n/**\n * Search Solana Transactions\n * Advanced search for Solana transactions with complex nested filters\n */\nexport const searchSolanaTransactions = <ThrowOnError extends boolean = false>(\n\toptions?: Options<SearchSolanaTransactionsData, ThrowOnError>,\n) => {\n\treturn (options?.client ?? _heyApiClient).post<\n\t\tSearchSolanaTransactionsResponses,\n\t\tunknown,\n\t\tThrowOnError\n\t>({\n\t\tsecurity: [\n\t\t\t{\n\t\t\t\tname: \"x-secret-key\",\n\t\t\t\ttype: \"apiKey\",\n\t\t\t},\n\t\t],\n\t\turl: \"/v1/solana/transactions/search\",\n\t\t...options,\n\t\theaders: {\n\t\t\t\"Content-Type\": \"application/json\",\n\t\t\t...options?.headers,\n\t\t},\n\t});\n};\n\n/**\n * Get Solana Activity Logs\n * Get paginated activity logs for a specific Solana transaction with tenancy enforcement\n */\nexport const getSolanaActivityLogs = <ThrowOnError extends boolean = false>(\n\toptions: Options<GetSolanaActivityLogsData, ThrowOnError>,\n) => {\n\treturn (options.client ?? _heyApiClient).get<\n\t\tGetSolanaActivityLogsResponses,\n\t\tGetSolanaActivityLogsErrors,\n\t\tThrowOnError\n\t>({\n\t\tsecurity: [\n\t\t\t{\n\t\t\t\tname: \"x-secret-key\",\n\t\t\t\ttype: \"apiKey\",\n\t\t\t},\n\t\t],\n\t\turl: \"/v1/solana/transactions/activity-logs\",\n\t\t...options,\n\t});\n};\n\n/**\n * Search Solana Activity Logs\n * Search Solana activity logs across transactions with advanced filtering and tenancy enforcement\n */\nexport const searchSolanaActivityLogs = <ThrowOnError extends boolean = false>(\n\toptions?: Options<SearchSolanaActivityLogsData, ThrowOnError>,\n) => {\n\treturn (options?.client ?? _heyApiClient).post<\n\t\tSearchSolanaActivityLogsResponses,\n\t\tSearchSolanaActivityLogsErrors,\n\t\tThrowOnError\n\t>({\n\t\tsecurity: [\n\t\t\t{\n\t\t\t\tname: \"x-secret-key\",\n\t\t\t\ttype: \"apiKey\",\n\t\t\t},\n\t\t],\n\t\turl: \"/v1/solana/transactions/activity-logs/search\",\n\t\t...options,\n\t\theaders: {\n\t\t\t\"Content-Type\": \"application/json\",\n\t\t\t...options?.headers,\n\t\t},\n\t});\n};\n", "import type { Config } from \"./client/client/index.js\";\nimport { client } from \"./client/client.gen.js\";\n\nexport type EngineClientOptions = {\n\treadonly clientId?: string;\n\treadonly secretKey?: string;\n};\n\nexport function configure(\n\toptions: EngineClientOptions & { override?: Config },\n) {\n\tclient.setConfig({\n\t\tbodySerializer: stringify,\n\t\theaders: {\n\t\t\t...(options.clientId && { \"x-client-id\": options.clientId }),\n\t\t\t...(options.secretKey && { \"x-secret-key\": options.secretKey }),\n\t\t},\n\t\t...(options.override ?? {}),\n\t});\n}\n\nfunction stringify(\n\t// biome-ignore lint/suspicious/noExplicitAny: JSON.stringify signature\n\tvalue: any,\n\t// biome-ignore lint/suspicious/noExplicitAny: JSON.stringify signature\n\treplacer?: ((this: any, key: string, value: any) => any) | null,\n\tspace?: string | number,\n) {\n\tconst res = JSON.stringify(\n\t\tvalue,\n\t\t(key, value_) => {\n\t\t\tconst value__ = typeof value_ === \"bigint\" ? value_.toString() : value_;\n\t\t\treturn typeof replacer === \"function\" ? replacer(key, value__) : value__;\n\t\t},\n\t\tspace,\n\t);\n\treturn res;\n}\n\nexport type MaybeErrorResponse<D, E> = { result: D } | { error: E };\n\nexport function isErrorResponse<D, E>(\n\tres: MaybeErrorResponse<D, E>,\n): res is { error: E } {\n\treturn \"error\" in res;\n}\n\nexport function isSuccessResponse<D, E>(\n\tres: MaybeErrorResponse<D, E>,\n): res is { result: D } {\n\treturn \"result\" in res;\n}\n", "import { createAccount } from \"@thirdweb-dev/engine\";\nimport { stringify } from \"viem\";\nimport type { ThirdwebClient } from \"../client/client.js\";\nimport { getThirdwebBaseUrl } from \"../utils/domains.js\";\nimport { getClientFetch } from \"../utils/fetch.js\";\n\nexport type CreateServerWalletArgs = {\n  client: ThirdwebClient;\n  label: string;\n};\n\n/**\n * Create a new server wallet.\n * @param params - The parameters for the server wallet.\n * @param params.client - The thirdweb client to use.\n * @param params.label - The label for the server wallet.\n * @returns The server wallet signer address and the predicted smart account address.\n * @engine\n * @example\n * ```ts\n * import { Engine } from \"thirdweb\";\n *\n * const serverWallet = await Engine.createServerWallet({\n *   client,\n *   label: \"My Server Wallet\",\n * });\n * console.log(serverWallet.address);\n * console.log(serverWallet.smartAccountAddress);\n * ```\n */\nexport async function createServerWallet(params: CreateServerWalletArgs) {\n  const { client, label } = params;\n  const result = await createAccount({\n    baseUrl: getThirdwebBaseUrl(\"engineCloud\"),\n    body: {\n      label,\n    },\n    bodySerializer: stringify,\n    fetch: getClientFetch(client),\n  });\n\n  if (result.error) {\n    throw new Error(\n      `Error creating server wallet with label ${label}: ${stringify(\n        result.error,\n      )}`,\n    );\n  }\n\n  const data = result.data?.result;\n\n  if (!data) {\n    throw new Error(`No server wallet created with label ${label}`);\n  }\n\n  return data;\n}\n", "import { searchTransactions } from \"@thirdweb-dev/engine\";\nimport type { Chain } from \"../chains/types.js\";\nimport { getCachedChain } from \"../chains/utils.js\";\nimport type { ThirdwebClient } from \"../client/client.js\";\nimport { getThirdwebBaseUrl } from \"../utils/domains.js\";\nimport type { Hex } from \"../utils/encoding/hex.js\";\nimport { getClientFetch } from \"../utils/fetch.js\";\nimport { stringify } from \"../utils/json.js\";\nimport type { Prettify } from \"../utils/type-utils.js\";\n\nexport type RevertData = {\n  errorName: string;\n  errorArgs: Record<string, unknown>;\n};\n\ntype ExecutionResult4337Serialized =\n  | {\n      status: \"QUEUED\";\n    }\n  | {\n      status: \"FAILED\";\n      error: string;\n    }\n  | {\n      status: \"SUBMITTED\";\n      monitoringStatus: \"WILL_MONITOR\" | \"CANNOT_MONITOR\";\n      userOpHash: string;\n    }\n  | ({\n      status: \"CONFIRMED\";\n      userOpHash: Hex;\n      transactionHash: Hex;\n      actualGasCost: string;\n      actualGasUsed: string;\n      nonce: string;\n    } & (\n      | {\n          onchainStatus: \"SUCCESS\";\n        }\n      | {\n          onchainStatus: \"REVERTED\";\n          revertData?: RevertData;\n        }\n    ));\n\nexport type ExecutionResult = Prettify<\n  ExecutionResult4337Serialized & {\n    chain: Chain;\n    from: string | undefined;\n    id: string;\n    createdAt: string;\n    confirmedAt: string | null;\n    cancelledAt: string | null;\n  }\n>;\n\n/**\n * Get the execution status of a transaction.\n * @param args - The arguments for the transaction.\n * @param args.client - The thirdweb client to use.\n * @param args.transactionId - The id of the transaction to get the status of.\n * @engine\n * @example\n * ```ts\n * import { Engine } from \"thirdweb\";\n *\n * const executionResult = await Engine.getTransactionStatus({\n *   client,\n *   transactionId,\n * });\n * console.log(executionResult.status);\n * ```\n */\nexport async function getTransactionStatus(args: {\n  client: ThirdwebClient;\n  transactionId: string;\n}): Promise<ExecutionResult> {\n  const { client, transactionId } = args;\n  const searchResult = await searchTransactions({\n    baseUrl: getThirdwebBaseUrl(\"engineCloud\"),\n    body: {\n      filters: [\n        {\n          field: \"id\",\n          operation: \"OR\",\n          values: [transactionId],\n        },\n      ],\n    },\n    bodySerializer: stringify,\n    fetch: getClientFetch(client),\n  });\n\n  if (searchResult.error) {\n    throw new Error(\n      `Error searching for transaction ${transactionId}: ${stringify(\n        searchResult.error,\n      )}`,\n    );\n  }\n\n  const data = searchResult.data?.result?.transactions?.[0];\n\n  if (!data) {\n    throw new Error(`Transaction ${transactionId} not found`);\n  }\n\n  const executionResult = data.executionResult as ExecutionResult4337Serialized;\n  return {\n    ...executionResult,\n    cancelledAt: data.cancelledAt,\n    chain: getCachedChain(Number(data.chainId)),\n    confirmedAt: data.confirmedAt,\n    createdAt: data.createdAt,\n    from: data.from ?? undefined,\n    id: data.id,\n  };\n}\n", "import { listAccounts } from \"@thirdweb-dev/engine\";\nimport { stringify } from \"viem\";\nimport type { ThirdwebClient } from \"../client/client.js\";\nimport { getThirdwebBaseUrl } from \"../utils/domains.js\";\nimport { getClientFetch } from \"../utils/fetch.js\";\n\nexport type GetServerWalletsArgs = {\n  client: ThirdwebClient;\n  limit?: number;\n  page?: number;\n};\n\n/**\n * List all server wallets.\n * @param params - The parameters for the server wallet.\n * @param params.client - The thirdweb client to use.\n * @returns an array of server wallets with their signer address and predicted smart account address.\n * @engine\n * @example\n * ```ts\n * import { Engine } from \"thirdweb\";\n *\n * const serverWallets = await Engine.getServerWallets({\n *   client,\n * });\n * console.log(serverWallets);\n * ```\n */\nexport async function getServerWallets(params: GetServerWalletsArgs) {\n  const { client } = params;\n  const result = await listAccounts({\n    baseUrl: getThirdwebBaseUrl(\"engineCloud\"),\n    bodySerializer: stringify,\n    fetch: getClientFetch(client),\n    query: {\n      limit: params.limit,\n      page: params.page,\n    },\n  });\n\n  if (result.error) {\n    throw new Error(`Error listing server wallets: ${stringify(result.error)}`);\n  }\n\n  const data = result.data?.result;\n\n  if (!data) {\n    throw new Error(\"No server wallets found\");\n  }\n\n  return data;\n}\n", "import {\n  searchTransactions as engineSearchTransactions,\n  type TransactionsFilterNested,\n  type TransactionsFilterValue,\n} from \"@thirdweb-dev/engine\";\nimport type { ThirdwebClient } from \"../client/client.js\";\nimport { getThirdwebBaseUrl } from \"../utils/domains.js\";\nimport { getClientFetch } from \"../utils/fetch.js\";\nimport { stringify } from \"../utils/json.js\";\n\nexport type SearchTransactionsArgs = {\n  client: ThirdwebClient;\n  filters?: (TransactionsFilterValue | TransactionsFilterNested)[];\n  pageSize?: number;\n  page?: number;\n};\n\n/**\n * Search for transactions by their ids.\n * @param args - The arguments for the search.\n * @param args.client - The thirdweb client to use.\n * @param args.transactionIds - The ids of the transactions to search for.\n * @engine\n * @example\n * ## Search for transactions by their ids\n *\n * ```ts\n * import { Engine } from \"thirdweb\";\n *\n * const transactions = await Engine.searchTransactions({\n *   client,\n *   filters: [\n *     {\n *       field: \"id\",\n *       values: [\"1\", \"2\", \"3\"],\n *     },\n *   ],\n * });\n * console.log(transactions);\n * ```\n *\n * ## Search for transactions by chain id\n *\n * ```ts\n * import { Engine } from \"thirdweb\";\n *\n * const transactions = await Engine.searchTransactions({\n *   client,\n *   filters: [\n *     {\n *       field: \"chainId\",\n *       values: [\"1\", \"137\"],\n *     },\n *   ],\n * });\n * console.log(transactions);\n * ```\n *\n * ## Search for transactions by sender wallet address\n *\n * ```ts\n * import { Engine } from \"thirdweb\";\n *\n * const transactions = await Engine.searchTransactions({\n *   client,\n *   filters: [\n *     {\n *       field: \"from\",\n *       values: [\"0x1234567890123456789012345678901234567890\"],\n *     },\n *   ],\n * });\n * console.log(transactions);\n * ```\n *\n * ## Combined search\n *\n * ```ts\n * import { Engine } from \"thirdweb\";\n *\n * const transactions = await Engine.searchTransactions({\n *   client,\n *   filters: [\n *     {\n *       filters: [\n *         {\n *          field: \"from\",\n *          values: [\"0x1234567890123456789012345678901234567890\"],\n *        },\n *        {\n *          field: \"chainId\",\n *          values: [\"8453\"],\n *        },\n *      ],\n *      operation: \"AND\",\n *    },\n *  ],\n *  pageSize: 100,\n *  page: 0,\n * });\n * console.log(transactions);\n * ```\n */\nexport async function searchTransactions(args: SearchTransactionsArgs) {\n  const { client, filters, pageSize = 100, page = 1 } = args;\n  const searchResult = await engineSearchTransactions({\n    baseUrl: getThirdwebBaseUrl(\"engineCloud\"),\n    body: {\n      filters,\n      limit: pageSize,\n      page,\n    },\n    bodySerializer: stringify,\n    fetch: getClientFetch(client),\n  });\n\n  if (searchResult.error) {\n    throw new Error(\n      `Error searching for transaction with filters ${stringify(filters)}: ${stringify(\n        searchResult.error,\n      )}`,\n    );\n  }\n\n  const data = searchResult.data?.result;\n\n  if (!data) {\n    throw new Error(`No transactions found with filters ${stringify(filters)}`);\n  }\n\n  return data;\n}\n", "import { stringify } from \"viem\";\nimport type { ThirdwebClient } from \"../client/client.js\";\nimport type { WaitForReceiptOptions } from \"../transaction/actions/wait-for-tx-receipt.js\";\nimport type { Hex } from \"../utils/encoding/hex.js\";\nimport { getTransactionStatus } from \"./get-status.js\";\n\n/**\n * Wait for a transaction to be submitted onchain and return the transaction hash.\n * @param args - The arguments for the transaction.\n * @param args.client - The thirdweb client to use.\n * @param args.transactionId - The id of the transaction to wait for.\n * @param args.timeoutInSeconds - The timeout in seconds.\n * @engine\n * @example\n * ```ts\n * import { Engine } from \"thirdweb\";\n *\n * const { transactionHash } = await Engine.waitForTransactionHash({\n *   client,\n *   transactionId, // the transaction id returned from enqueueTransaction\n * });\n * ```\n */\nexport async function waitForTransactionHash(args: {\n  client: ThirdwebClient;\n  transactionId: string;\n  timeoutInSeconds?: number;\n}): Promise<WaitForReceiptOptions> {\n  const startTime = Date.now();\n  const TIMEOUT_IN_MS = args.timeoutInSeconds\n    ? args.timeoutInSeconds * 1000\n    : 5 * 60 * 1000; // 5 minutes in milliseconds\n\n  while (Date.now() - startTime < TIMEOUT_IN_MS) {\n    const executionResult = await getTransactionStatus(args);\n    const status = executionResult.status;\n\n    switch (status) {\n      case \"FAILED\": {\n        throw new Error(\n          `Transaction failed: ${stringify(executionResult.error) || \"Unknown error\"}`,\n        );\n      }\n      case \"CONFIRMED\": {\n        const onchainStatus =\n          executionResult && \"onchainStatus\" in executionResult\n            ? executionResult.onchainStatus\n            : null;\n        if (onchainStatus === \"REVERTED\") {\n          const revertData =\n            \"revertData\" in executionResult\n              ? executionResult.revertData\n              : undefined;\n          throw new Error(\n            `Transaction reverted: ${revertData?.errorName || \"unknown error\"} ${revertData?.errorArgs ? stringify(revertData.errorArgs) : \"\"} - ${executionResult.transactionHash ? executionResult.transactionHash : \"\"}`,\n          );\n        }\n        return {\n          chain: executionResult.chain,\n          client: args.client,\n          transactionHash: executionResult.transactionHash as Hex,\n        };\n      }\n      default: {\n        // wait for the transaction to be confirmed\n        await new Promise((resolve) => setTimeout(resolve, 1000));\n      }\n    }\n  }\n  throw new Error(\n    `Transaction timed out after ${TIMEOUT_IN_MS / 1000} seconds`,\n  );\n}\n", "import {\n  isSuccessResponse,\n  type SendTransactionData,\n  type SignMessageData,\n  type SpecificExecutionOptions,\n  sendTransaction,\n  signMessage,\n  signTypedData,\n} from \"@thirdweb-dev/engine\";\nimport type { Chain } from \"../chains/types.js\";\nimport type { ThirdwebClient } from \"../client/client.js\";\nimport { encode } from \"../transaction/actions/encode.js\";\nimport { toSerializableTransaction } from \"../transaction/actions/to-serializable-transaction.js\";\nimport type { PreparedTransaction } from \"../transaction/prepare-transaction.js\";\nimport { getThirdwebBaseUrl } from \"../utils/domains.js\";\nimport { type Hex, toHex } from \"../utils/encoding/hex.js\";\nimport { getClientFetch } from \"../utils/fetch.js\";\nimport { stringify } from \"../utils/json.js\";\nimport { resolvePromisedValue } from \"../utils/promise/resolve-promised-value.js\";\nimport type { Prettify } from \"../utils/type-utils.js\";\nimport type {\n  Account,\n  SendTransactionOption,\n} from \"../wallets/interfaces/wallet.js\";\nimport { waitForTransactionHash } from \"./wait-for-tx-hash.js\";\n\ntype ExecutionOptions = Prettify<SpecificExecutionOptions>;\n\n/**\n * Options for creating an server wallet.\n */\nexport type ServerWalletOptions = {\n  /**\n   * The thirdweb client to use for authentication to thirdweb services.\n   */\n  client: ThirdwebClient;\n  /**\n   * Optional vault access token to use your server wallet.\n   * If not provided, the server wallet will use the project secret key to authenticate.\n   */\n  vaultAccessToken?: string;\n  /**\n   * The server wallet address to use for sending transactions inside engine.\n   */\n  address: string;\n  /**\n   * The chain to use for signing messages and typed data (smart server wallet only).\n   */\n  chain?: Chain;\n  /**\n   * Optional custom execution options to use for sending transactions and signing data.\n   */\n  executionOptions?: ExecutionOptions;\n};\n\nexport type ServerWallet = Account & {\n  enqueueTransaction: (args: {\n    transaction: PreparedTransaction;\n    simulate?: boolean;\n  }) => Promise<{ transactionId: string }>;\n  enqueueBatchTransaction: (args: {\n    transactions: PreparedTransaction[];\n  }) => Promise<{ transactionId: string }>;\n};\n\n/**\n * Use a server wallet for sending transactions and signing messages via engine (v3+).\n * @param options - The server wallet options.\n * @returns An account object that can be used to send transactions and sign messages.\n * @engine\n * @example\n * ### Creating a server wallet\n * ```ts\n * import { Engine } from \"thirdweb\";\n *\n * const client = createThirdwebClient({\n *   secretKey: \"<your-project-secret-key>\",\n * });\n *\n * const myServerWallet = Engine.serverWallet({\n *   client,\n *   address: \"<your-server-wallet-address>\",\n * });\n * ```\n *\n * ### Sending a transaction\n * ```ts\n * // prepare the transaction\n * const transaction = claimTo({\n *   contract,\n *   to: \"0x...\",\n *   quantity: 1n,\n * });\n *\n * // enqueue the transaction\n * const { transactionId } = await myServerWallet.enqueueTransaction({\n *   transaction,\n * });\n * ```\n *\n * ### Polling for the transaction to be submitted onchain\n * ```ts\n * // optionally poll for the transaction to be submitted onchain\n * const { transactionHash } = await Engine.waitForTransactionHash({\n *   client,\n *   transactionId,\n * });\n * console.log(\"Transaction sent:\", transactionHash);\n * ```\n *\n *  ### Sending a batch of transactions\n * ```ts\n * // prepare the transactions\n * const transaction1 = claimTo({\n *   contract,\n *   to: firstRecipient,\n *   quantity: 1n,\n * });\n * const transaction2 = claimTo({\n *   contract,\n *   to: secondRecipient,\n *   quantity: 1n,\n * });\n *\n *\n * // enqueue the transactions in a batch\n * const { transactionId } = await myServerWallet.enqueueBatchTransaction({\n *   transactions: [transaction1, transaction2],\n * });\n * ```\n *\n * ### Polling for the batch of transactions to be submitted onchain\n * ```ts\n * // optionally poll for the transaction to be submitted onchain\n * const { transactionHash } = await Engine.waitForTransactionHash({\n *   client,\n *   transactionId,\n * });\n * console.log(\"Transaction sent:\", transactionHash);\n * ```\n *\n * ### Getting the execution status of a transaction\n * ```ts\n * const executionResult = await Engine.getTransactionStatus({\n *   client,\n *   transactionId,\n * });\n * console.log(\"Transaction status:\", executionResult.status);\n * ```\n */\nexport function serverWallet(options: ServerWalletOptions): ServerWallet {\n  const { client, vaultAccessToken, address, chain, executionOptions } =\n    options;\n\n  const headers: HeadersInit = vaultAccessToken\n    ? {\n        \"x-vault-access-token\": vaultAccessToken,\n      }\n    : {};\n\n  const getExecutionOptionsWithChainId = (\n    chainId: number,\n  ): SendTransactionData[\"body\"][\"executionOptions\"] => {\n    if (!executionOptions) {\n      return {\n        chainId,\n        from: address,\n        type: \"auto\",\n      };\n    }\n    switch (executionOptions.type) {\n      case \"auto\":\n        return {\n          chainId,\n          from: address,\n          type: \"auto\",\n        };\n      case \"ERC4337\":\n        return {\n          ...executionOptions,\n          chainId,\n          type: \"ERC4337\",\n        };\n      case \"EOA\":\n        return {\n          chainId,\n          from: address,\n          type: \"EOA\",\n        };\n      case \"EIP7702\":\n        return {\n          ...executionOptions,\n          chainId,\n          type: \"EIP7702\",\n        };\n    }\n  };\n\n  const getSigningOptions = (\n    chainId: number | undefined,\n  ): SignMessageData[\"body\"][\"signingOptions\"] => {\n    // if no chainId passed specifically for this signature\n    // we HAVE TO fallback to EOA signature\n    if (!chainId) {\n      return {\n        from: address,\n        type: \"EOA\",\n      };\n    }\n\n    if (!executionOptions) {\n      return {\n        chainId,\n        from: address,\n        type: \"auto\",\n      };\n    }\n\n    switch (executionOptions.type) {\n      case \"ERC4337\": {\n        return {\n          chainId,\n          ...executionOptions,\n          type: \"ERC4337\",\n        };\n      }\n      case \"auto\": {\n        return {\n          chainId,\n          from: address,\n          type: \"auto\",\n        };\n      }\n      case \"EIP7702\":\n      case \"EOA\": {\n        return {\n          chainId,\n          from: address,\n          type: \"EOA\",\n        };\n      }\n    }\n  };\n\n  const enqueueTx = async (transaction: SendTransactionOption[]) => {\n    if (transaction.length === 0) {\n      throw new Error(\"No transactions to enqueue\");\n    }\n    const firstTransaction = transaction[0];\n    if (!firstTransaction) {\n      throw new Error(\"No transactions to enqueue\");\n    }\n    const chainId = firstTransaction.chainId;\n    // Validate all transactions are on the same chain\n    for (let i = 1; i < transaction.length; i++) {\n      if (transaction[i]?.chainId !== chainId) {\n        throw new Error(\n          `All transactions in batch must be on the same chain. Expected ${chainId}, got ${transaction[i]?.chainId} at index ${i}`,\n        );\n      }\n    }\n    const body = {\n      executionOptions: getExecutionOptionsWithChainId(chainId),\n      params: transaction.map((t) => ({\n        data: t.data,\n        to: t.to,\n        gasLimit: t.gas ? Number(t.gas) : undefined,\n        value: t.value?.toString(),\n      })),\n    };\n\n    const result = await sendTransaction({\n      baseUrl: getThirdwebBaseUrl(\"engineCloud\"),\n      body,\n      bodySerializer: stringify,\n      fetch: getClientFetch(client),\n      headers,\n    });\n\n    if (result.error) {\n      throw new Error(`Error sending transaction: ${stringify(result.error)}`);\n    }\n\n    const data = result.data?.result;\n    if (!data) {\n      throw new Error(\"No data returned from engine\");\n    }\n    return data.transactions.map((t) => t.id);\n  };\n\n  const getAddress = () => {\n    if (\n      executionOptions?.type === \"ERC4337\" &&\n      executionOptions.smartAccountAddress\n    ) {\n      return executionOptions.smartAccountAddress;\n    }\n    return address;\n  };\n\n  return {\n    address: getAddress(),\n    enqueueBatchTransaction: async (args: {\n      transactions: PreparedTransaction[];\n    }) => {\n      const serializedTransactions: SendTransactionOption[] = [];\n      for (const transaction of args.transactions) {\n        const [to, data, value] = await Promise.all([\n          transaction.to ? resolvePromisedValue(transaction.to) : null,\n          encode(transaction),\n          transaction.value ? resolvePromisedValue(transaction.value) : null,\n        ]);\n        serializedTransactions.push({\n          chainId: transaction.chain.id,\n          data,\n          to: to ?? undefined,\n          value: value ?? undefined,\n        });\n      }\n      const transactionIds = await enqueueTx(serializedTransactions);\n      const transactionId = transactionIds[0];\n      if (!transactionId) {\n        throw new Error(\"No transactionId returned from engine\");\n      }\n      return { transactionId };\n    },\n    enqueueTransaction: async (args: {\n      transaction: PreparedTransaction;\n      simulate?: boolean;\n    }) => {\n      let serializedTransaction: SendTransactionOption;\n      if (args.simulate) {\n        serializedTransaction = await toSerializableTransaction({\n          transaction: args.transaction,\n        });\n      } else {\n        const [to, data, value] = await Promise.all([\n          args.transaction.to\n            ? resolvePromisedValue(args.transaction.to)\n            : null,\n          encode(args.transaction),\n          args.transaction.value\n            ? resolvePromisedValue(args.transaction.value)\n            : null,\n        ]);\n        serializedTransaction = {\n          chainId: args.transaction.chain.id,\n          data,\n          to: to ?? undefined,\n          value: value ?? undefined,\n        };\n      }\n      const transactionIds = await enqueueTx([serializedTransaction]);\n      const transactionId = transactionIds[0];\n      if (!transactionId) {\n        throw new Error(\"No transactionId returned from engine\");\n      }\n      return { transactionId };\n    },\n    sendBatchTransaction: async (transactions: SendTransactionOption[]) => {\n      const transactionIds = await enqueueTx(transactions);\n      const transactionId = transactionIds[0];\n      if (!transactionId) {\n        throw new Error(\"No transactionId returned from engine\");\n      }\n      return waitForTransactionHash({\n        client,\n        transactionId,\n      });\n    },\n    sendTransaction: async (transaction: SendTransactionOption) => {\n      const transactionIds = await enqueueTx([transaction]);\n      const transactionId = transactionIds[0];\n      if (!transactionId) {\n        throw new Error(\"No transactionId returned from engine\");\n      }\n      return waitForTransactionHash({\n        client,\n        transactionId,\n      });\n    },\n    signMessage: async (data) => {\n      const { message, chainId } = data;\n      let engineMessage: string | Hex;\n      let isBytes = false;\n      if (typeof message === \"string\") {\n        engineMessage = message;\n      } else {\n        engineMessage = toHex(message.raw);\n        isBytes = true;\n      }\n\n      const signingChainId = chainId || chain?.id;\n      if (!signingChainId) {\n        throw new Error(\"Chain ID is required for signing messages\");\n      }\n      const signResult = await signMessage({\n        baseUrl: getThirdwebBaseUrl(\"engineCloud\"),\n        body: {\n          params: [\n            {\n              format: isBytes ? \"hex\" : \"text\",\n              message: engineMessage,\n            },\n          ],\n          signingOptions: getSigningOptions(signingChainId),\n        },\n        bodySerializer: stringify,\n        fetch: getClientFetch(client),\n        headers,\n      });\n\n      if (signResult.error) {\n        throw new Error(\n          `Error signing message: ${stringify(signResult.error)}`,\n        );\n      }\n\n      const signatureResult = signResult.data?.result[0];\n      if (signatureResult && isSuccessResponse(signatureResult)) {\n        return signatureResult.result.signature as Hex;\n      }\n\n      throw new Error(\n        `Failed to sign message: ${stringify(signatureResult?.error) || \"Unknown error\"}`,\n      );\n    },\n    signTypedData: async (typedData) => {\n      const signingChainId = chain?.id;\n      if (!signingChainId) {\n        throw new Error(\"Chain ID is required for signing messages\");\n      }\n\n      const signResult = await signTypedData({\n        baseUrl: getThirdwebBaseUrl(\"engineCloud\"),\n        body: {\n          // biome-ignore lint/suspicious/noExplicitAny: TODO: fix ts / hey-api type clash\n          params: [typedData as any],\n          signingOptions: getSigningOptions(signingChainId),\n        },\n        bodySerializer: stringify,\n        fetch: getClientFetch(client),\n        headers,\n      });\n\n      if (signResult.error) {\n        throw new Error(\n          `Error signing message: ${stringify(signResult.error)}`,\n        );\n      }\n\n      const signatureResult = signResult.data?.result[0];\n      if (signatureResult && isSuccessResponse(signatureResult)) {\n        return signatureResult.result.signature as Hex;\n      }\n\n      throw new Error(\n        `Failed to sign message: ${stringify(signatureResult?.error) || \"Unknown error\"}`,\n      );\n    },\n  };\n}\n", "import {\n  type EIP1193RequestFn,\n  type EIP1474Methods,\n  formatBlock,\n  type GetBlockReturnType,\n  type Hash,\n} from \"viem\";\n\ntype GetBlockByHashParams<TIncludeTransactions extends boolean = false> = {\n  /** Whether or not to include transaction data in the response. */\n  includeTransactions?: TIncludeTransactions;\n} & {\n  /** Hash of the block. */\n  blockHash: Hash;\n};\n\n/**\n * Retrieves a block by its hash.\n * @param request - The EIP1193 request function.\n * @param params - The parameters for the block retrieval.\n * @returns A promise that resolves to the retrieved block.\n * @throws An error if the block is not found.\n * @rpc\n * @example\n * ```ts\n * import { getRpcClient, eth_getBlockByHash } from \"thirdweb/rpc\";\n * const rpcRequest = getRpcClient({ client, chain });\n * const block = await eth_getBlockByHash(rpcRequest, {\n * blockHash: \"0x...\",\n * includeTransactions: true,\n * });\n * ```\n */\nexport async function eth_getBlockByHash<\n  TIncludeTransactions extends boolean = false,\n>(\n  request: EIP1193RequestFn<EIP1474Methods>,\n  params: GetBlockByHashParams<TIncludeTransactions>,\n): Promise<GetBlockReturnType<undefined, TIncludeTransactions>> {\n  const includeTransactions = params.includeTransactions ?? false;\n\n  const block = await request({\n    method: \"eth_getBlockByHash\",\n    params: [params.blockHash, includeTransactions],\n  });\n  if (!block) {\n    throw new Error(\"Block not found\");\n  }\n  return formatBlock(block) as GetBlockReturnType<\n    undefined,\n    TIncludeTransactions\n  >;\n}\n", "import {\n  type EIP1193RequestFn,\n  type EIP1474Methods,\n  formatTransaction,\n  type Hash,\n  type Transaction,\n} from \"viem\";\n\ntype GetTransactionByHashParameters = {\n  hash: Hash;\n};\n\n/**\n * Retrieves a transaction by its hash.\n * @param request - The EIP1193 request function.\n * @param params - The parameters for retrieving the transaction.\n * @returns A promise that resolves to the transaction.\n * @throws An error if the transaction is not found.\n * @rpc\n * @example\n * ```ts\n * import { getRpcClient, eth_getTransactionByHash } from \"thirdweb/rpc\";\n * const rpcRequest = getRpcClient({ client, chain });\n *  const transaction = await eth_getTransactionByHash(rpcRequest, {\n *  hash: \"0x...\",\n * });\n * ```\n */\nexport async function eth_getTransactionByHash(\n  request: EIP1193RequestFn<EIP1474Methods>,\n  params: GetTransactionByHashParameters,\n): Promise<Transaction> {\n  const receipt = await request({\n    method: \"eth_getTransactionByHash\",\n    params: [params.hash],\n  });\n\n  if (!receipt) {\n    throw new Error(\"Transaction not found.\");\n  }\n\n  return formatTransaction(receipt);\n}\n", "import type { ThirdwebClient } from \"../../../../client/client.js\";\nimport { getThirdwebBaseUrl } from \"../../../../utils/domains.js\";\nimport { getClientFetch } from \"../../../../utils/fetch.js\";\nimport type { OneOf, Prettify } from \"../../../../utils/type-utils.js\";\nimport type { Profile } from \"../authentication/types.js\";\nimport type { Ecosystem } from \"../wallet/types.js\";\n\nexport type GetUserResult = {\n  userId: string;\n  walletAddress: string;\n  smartAccountAddress?: string;\n  email?: string;\n  phone?: string;\n  createdAt: string;\n  profiles: Profile[];\n};\n\n/**\n * Gets user based on the provided query parameters.\n *  This function is only available on the server (a secret key is required in the client).\n *\n * @param options - The options for the get user function.\n * @param options.client - The Thirdweb client with a secret key included.\n * @param [options.walletAddress] - The wallet address generated by thirdweb to query by.\n * @param [options.email] - The email to query by.\n * @param [options.phone] - The phone number to query by.\n * @param [options.id] - The user ID to query by.\n * @param [options.externalWalletAddress] - The linked external wallet address to query by.\n *\n * @returns A user object or null if not found.\n *\n * @example\n * import { getUser } from \"thirdweb/wallets\";\n *\n * const user = await getUser({\n *   client,\n *   walletAddress: \"0x123...\",\n * });\n *\n * @wallet\n */\nexport async function getUser({\n  client,\n  walletAddress,\n  email,\n  phone,\n  id,\n  externalWalletAddress,\n  ecosystem,\n}: Prettify<\n  {\n    client: ThirdwebClient;\n    ecosystem?: Ecosystem;\n  } & OneOf<{\n    walletAddress?: string;\n    email?: string;\n    phone?: string;\n    id?: string;\n    externalWalletAddress?: string;\n  }>\n>): Promise<GetUserResult | null> {\n  if (!client.secretKey) {\n    throw new Error(\n      \"A secret key is required to query for users. If you're making this request from the server, please add a secret key to your client.\",\n    );\n  }\n\n  const url = new URL(\n    `${getThirdwebBaseUrl(\"inAppWallet\")}/api/2023-11-30/embedded-wallet/user-details`,\n  );\n\n  if (walletAddress) {\n    url.searchParams.set(\"queryBy\", \"walletAddress\");\n    url.searchParams.set(\"walletAddress\", walletAddress);\n  } else if (email) {\n    url.searchParams.set(\"queryBy\", \"email\");\n    url.searchParams.set(\"email\", email);\n  } else if (phone) {\n    url.searchParams.set(\"queryBy\", \"phone\");\n    url.searchParams.set(\"phone\", phone);\n  } else if (id) {\n    url.searchParams.set(\"queryBy\", \"id\");\n    url.searchParams.set(\"id\", id);\n  } else if (externalWalletAddress) {\n    url.searchParams.set(\"queryBy\", \"externalWalletAddress\");\n    url.searchParams.set(\"externalWalletAddress\", externalWalletAddress);\n  } else {\n    throw new Error(\n      \"Please provide a walletAddress, email, phone, id, or externalWalletAddress to query for users.\",\n    );\n  }\n\n  const clientFetch = getClientFetch(client, ecosystem);\n\n  const res = await clientFetch(url.toString());\n\n  if (!res.ok) {\n    const error = await res.text().catch(() => \"Unknown error\");\n    throw new Error(\n      `Failed to get profiles. ${res.status} ${res.statusText}: ${error}`,\n    );\n  }\n\n  const data = (await res.json()) as {\n    userId: string;\n    walletAddress: string;\n    smartAccountAddress?: string;\n    email?: string;\n    phone?: string;\n    createdAt: string;\n    linkedAccounts: Profile[];\n  }[];\n\n  return (\n    data.map((item) => ({\n      createdAt: item.createdAt,\n      email: item.email,\n      phone: item.phone,\n      profiles: item.linkedAccounts.map((profile) => {\n        return {\n          details: profile.details,\n          type: (profile.type as string) === \"siwe\" ? \"wallet\" : profile.type,\n        };\n      }),\n      smartAccountAddress: item.smartAccountAddress,\n      userId: item.userId,\n      walletAddress: item.walletAddress,\n    }))[0] || null\n  );\n}\n", "import { Value } from \"ox\";\nimport * as ox__AbiFunction from \"ox/AbiFunction\";\nimport { Transfer } from \"../../bridge/index.js\";\nimport { getCachedChain } from \"../../chains/utils.js\";\nimport type { ThirdwebClient } from \"../../client/client.js\";\nimport { NATIVE_TOKEN_ADDRESS } from \"../../constants/addresses.js\";\nimport { getContract } from \"../../contract/contract.js\";\nimport { decimals } from \"../../extensions/erc20/read/decimals.js\";\nimport type { PrepareTransactionOptions } from \"../../transaction/prepare-transaction.js\";\nimport type { PurchaseData } from \"../types.js\";\nimport type { QuoteApprovalInfo, QuotePaymentToken } from \"./commonTypes.js\";\n\n/**\n * The parameters for [`getBuyWithCryptoTransfer`](https://portal.thirdweb.com/references/typescript/v5/getBuyWithCryptoTransfer) function\n * It facilitates a token transfer.\n * @buyCrypto\n */\nexport type GetBuyWithCryptoTransferParams = {\n  /**\n   * A client is the entry point to the thirdweb SDK. It is required for all other actions.\n   *\n   * You can create a client using the `createThirdwebClient` function.\n   * Refer to the [Creating a Client](https://portal.thirdweb.com/typescript/v5/client) documentation for more information.\n   *\n   */\n  client: ThirdwebClient;\n\n  /**\n   * The address of wallet that pays for the tokens.\n   */\n  fromAddress: string;\n\n  /**\n   * The address of the wallet where the tokens are sent\n   */\n  toAddress: string;\n\n  /**\n   * The chain id of the transfer token.\n   */\n  chainId: number;\n\n  /**\n   * The token address of the transfer token.\n   */\n  tokenAddress: string;\n\n  /**\n   * The amount of token to be transferred.\n   */\n  amount: string;\n\n  /**\n   * Extra details to store with the purchase.\n   *\n   * This details will be stored with the purchase and can be retrieved later via the status API or Webhook\n   */\n  purchaseData?: PurchaseData;\n\n  /**\n   * For direct transfers, specify who will pay for the transfer fee. Can be \"sender\" or \"receiver\".\n   */\n  feePayer?: \"sender\" | \"receiver\";\n\n  /**\n   * @hidden\n   */\n  paymentLinkId?: string;\n};\n\n/**\n * @buyCrypto\n */\nexport type BuyWithCryptoTransfer = {\n  transactionRequest: PrepareTransactionOptions;\n  approvalData?: QuoteApprovalInfo;\n  fromAddress: string;\n  toAddress: string;\n  paymentToken: QuotePaymentToken;\n  processingFee: QuotePaymentToken;\n  estimatedGasCostUSDCents: number;\n  client: ThirdwebClient;\n};\n\n/**\n * Get a quote of type [`BuyWithCryptoTransfer`](https://portal.thirdweb.com/references/typescript/v5/BuyWithCryptoTransfer) to facilitate a token transfer transaction.\n * Using this instead of a native transfer allows you to receive status and webhooks about successful or failed payments.\n *\n * Once you have the quote, you can use `prepareTransaction` and prepare the transaction for submission.\n * @param params - object of type [`GetBuyWithCryptoTransferParams`](https://portal.thirdweb.com/references/typescript/v5/GetBuyWithCryptoTransferParams)\n * @returns Object of type [`BuyWithCryptoTransfer`](https://portal.thirdweb.com/references/typescript/v5/BuyWithCryptoTransfer) which contains the information about the transfer\n * @example\n *\n * ```ts\n * import { getBuyWithCryptoTransfer } from \"thirdweb/pay\";\n *\n * const transfer = await getBuyWithCryptoTransfer({\n *  client,\n *  fromAddress: \"0x...\", // wallet address\n *  toAddress: \"0x...\", // recipient address - likely to be your wallet\n *  chainId: 10, // chain id of the token\n *  tokenAddress: \"0x...\", // address of the token\n *  amount: \"10\", // amount of token to transfer\n *  purchaseData: {  // any metadata for you to attribute this purchase\n *    \"customerId\": \"yourId\"\n *  }\n * });\n * ```\n * @deprecated\n * @buyCrypto\n */\nexport async function getBuyWithCryptoTransfer(\n  params: GetBuyWithCryptoTransferParams,\n): Promise<BuyWithCryptoTransfer> {\n  try {\n    const tokenContract = getContract({\n      address: params.tokenAddress,\n      chain: getCachedChain(params.chainId),\n      client: params.client,\n    });\n    const tokenDecimals =\n      tokenContract.address.toLowerCase() === NATIVE_TOKEN_ADDRESS\n        ? 18\n        : await decimals({\n            contract: tokenContract,\n          });\n    const amount = Value.from(params.amount, tokenDecimals);\n    const quote = await Transfer.prepare({\n      amount,\n      chainId: params.chainId,\n      client: params.client,\n      feePayer: params.feePayer,\n      paymentLinkId: params.paymentLinkId,\n      purchaseData: params.purchaseData,\n      receiver: params.toAddress,\n      sender: params.fromAddress,\n      tokenAddress: params.tokenAddress,\n    });\n\n    const firstStep = quote.steps[0];\n    if (!firstStep) {\n      throw new Error(\n        \"This quote is incompatible with getBuyWithCryptoTransfer. Please use Bridge.Transfer.prepare instead.\",\n      );\n    }\n\n    const approvalTxs = firstStep.transactions.filter(\n      (tx) => tx.action === \"approval\",\n    );\n    if (approvalTxs.length > 1) {\n      throw new Error(\n        \"This quote is incompatible with getBuyWithCryptoTransfer. Please use Bridge.Transfer.prepare instead.\",\n      );\n    }\n    const approvalTx = approvalTxs[0];\n\n    let approvalData: QuoteApprovalInfo | undefined;\n    if (approvalTx) {\n      const abiFunction = ox__AbiFunction.from([\n        \"function approve(address spender, uint256 amount)\",\n      ]);\n      const [spender, amount] = ox__AbiFunction.decodeData(\n        abiFunction,\n        approvalTx.data,\n      );\n      approvalData = {\n        amountWei: amount.toString(),\n        chainId: firstStep.originToken.chainId,\n        spenderAddress: spender,\n        tokenAddress: firstStep.originToken.address,\n      };\n    }\n\n    const txs = firstStep.transactions.filter((tx) => tx.action !== \"approval\");\n    if (txs.length > 1) {\n      throw new Error(\n        \"This quote is incompatible with getBuyWithCryptoTransfer. Please use Bridge.Transfer.prepare instead.\",\n      );\n    }\n    const tx = txs[0];\n    if (!tx) {\n      throw new Error(\n        \"This quote is incompatible with getBuyWithCryptoTransfer. Please use Bridge.Transfer.prepare instead.\",\n      );\n    }\n\n    const transfer: BuyWithCryptoTransfer = {\n      approvalData,\n      client: params.client,\n      estimatedGasCostUSDCents: 0,\n      fromAddress: params.fromAddress,\n      paymentToken: {\n        amount: Value.format(\n          quote.originAmount,\n          firstStep.originToken.decimals,\n        ).toString(),\n        amountUSDCents:\n          Number(\n            Value.format(quote.originAmount, firstStep.originToken.decimals),\n          ) *\n          (firstStep.originToken.prices.USD || 0) *\n          100,\n        amountWei: quote.originAmount.toString(),\n        token: {\n          chainId: firstStep.originToken.chainId,\n          decimals: firstStep.originToken.decimals,\n          name: firstStep.originToken.name,\n          priceUSDCents: (firstStep.originToken.prices.USD || 0) * 100,\n          symbol: firstStep.originToken.symbol,\n          tokenAddress: firstStep.originToken.address,\n        },\n      },\n      processingFee: {\n        amount:\n          params.feePayer === \"sender\"\n            ? Value.format(\n                quote.originAmount - quote.destinationAmount,\n                firstStep.originToken.decimals,\n              ).toString()\n            : \"0\",\n        amountUSDCents:\n          params.feePayer === \"sender\"\n            ? Number(\n                Value.format(\n                  quote.originAmount - quote.destinationAmount,\n                  firstStep.originToken.decimals,\n                ),\n              ) *\n              (firstStep.originToken.prices.USD || 0) *\n              100\n            : 0,\n        amountWei:\n          params.feePayer === \"sender\"\n            ? (quote.originAmount - quote.destinationAmount).toString()\n            : \"0\",\n        token: {\n          chainId: firstStep.originToken.chainId,\n          decimals: firstStep.originToken.decimals,\n          name: firstStep.originToken.name,\n          priceUSDCents: (firstStep.originToken.prices.USD || 0) * 100,\n          symbol: firstStep.originToken.symbol,\n          tokenAddress: firstStep.originToken.address,\n        },\n      },\n      toAddress: params.toAddress,\n      transactionRequest: {\n        ...tx,\n        extraGas: 50000n, // extra gas buffer\n      },\n    };\n\n    return transfer;\n  } catch (error) {\n    console.error(\"Error getting buy with crypto transfer\", error);\n    throw error;\n  }\n}\n", "import * as ox__Hash from \"ox/Hash\";\nimport * as ox__Secp256k1 from \"ox/Secp256k1\";\nimport type { Hex } from \"../../utils/encoding/hex.js\";\nimport {\n  type SerializableTransaction,\n  serializeTransaction,\n} from \"../serialize-transaction.js\";\n\nexport type SignTransactionOptions = {\n  transaction: SerializableTransaction;\n  privateKey: Hex;\n  // TODO: Add optional custom serializer here\n};\n\n/**\n * Signs a transaction to be sent to a node.\n * @param options The options for signing.\n * @param options.transaction - The transaction object to sign\n * @param options.privateKey - The account private key\n * @returns The signed transaction as a hex string\n * @example\n * ```ts\n * import { signTransaction } from \"thirdweb\";\n * signTransaction({\n *   transaction: {\n *     ...\n *   },\n *   privateKey: \"0x...\",\n * });\n * ```\n * @transaction\n */\nexport function signTransaction({\n  transaction,\n  privateKey,\n}: SignTransactionOptions): Hex {\n  const serializedTransaction = serializeTransaction({ transaction });\n\n  const signature = ox__Secp256k1.sign({\n    payload: ox__Hash.keccak256(serializedTransaction),\n    privateKey: privateKey,\n  });\n  return serializeTransaction({\n    transaction: { ...transaction, ...signature },\n  });\n}\n", "import type { Abi, AbiFunction } from \"abitype\";\nimport { parseAbiItem } from \"abitype\";\nimport { resolveContractAbi } from \"../contract/actions/resolve-abi.js\";\nimport type { ThirdwebContract } from \"../contract/contract.js\";\n\n/**\n * Resolves and returns the ABI function with the specified method name.\n * Throws an error if the function is not found in the ABI.\n * @template abiFn - The type of the ABI function.\n * @param method - The name of the method to resolve.\n * @returns The resolved ABI function.\n * @throws Error if the function is not found in the ABI.\n * @example\n * ```ts\n * import { resolveMethod, prepareContractCall } from \"thirdweb\";\n * const tx = prepareContractCall({\n *  contract,\n *  // automatically resolves the necessary abi to encode the transaction\n *  method: resolveMethod(\"transfer\"),\n *  // however there is no type completion for params in this case (as the resolution is async and happens at runtime)\n *  params: [to, value],\n * });\n * ```\n * @contract\n */\nexport function resolveMethod<\n  abiFn extends AbiFunction,\n  TAbi extends Abi = Abi,\n>(method: string) {\n  return async (contract: ThirdwebContract<TAbi>) => {\n    if (typeof method === \"string\" && method.startsWith(\"function \")) {\n      // we know it will be an abi function so we can cast it\n      return parseAbiItem(method) as AbiFunction;\n    }\n\n    const resolvedAbi = contract.abi?.length\n      ? contract.abi\n      : await resolveContractAbi<Abi>(contract);\n    // we try to find the abiFunction in the abi\n    const abiFunction = resolvedAbi.find((item) => {\n      // if the item is not a function we can ignore it\n      if (item.type !== \"function\") {\n        return false;\n      }\n      // if the item is a function we can compare the name\n      return item.name === method;\n    }) as abiFn | undefined;\n\n    if (!abiFunction) {\n      throw new Error(`could not find function with name \"${method}\" in abi`);\n    }\n    return abiFunction;\n  };\n}\n", "import * as ox__Secp256k1 from \"ox/Secp256k1\";\nimport * as ox__Signature from \"ox/Signature\";\nimport * as ox__TypedData from \"ox/TypedData\";\nimport type { Chain } from \"../chains/types.js\";\nimport type { ThirdwebClient } from \"../client/client.js\";\nimport { type Hex, isHex } from \"../utils/encoding/hex.js\";\nimport type { HashTypedDataParams } from \"../utils/hashing/hashTypedData.js\";\nimport { type VerifyHashParams, verifyHash } from \"./verify-hash.js\";\n\nexport type VerifyTypedDataParams<\n  typedData extends\n    | ox__TypedData.TypedData\n    | Record<string, unknown> = ox__TypedData.TypedData,\n  primaryType extends keyof typedData | \"EIP712Domain\" = keyof typedData,\n> = Omit<VerifyHashParams, \"hash\"> &\n  ox__TypedData.Definition<typedData, primaryType> & {\n    address: string;\n    signature: string | Uint8Array | ox__Signature.Signature;\n    client: ThirdwebClient;\n    chain: Chain;\n    accountFactory?: {\n      address: string;\n      verificationCalldata: Hex;\n    };\n  };\n\n/**\n * Verify am [EIP-712](https://eips.ethereum.org/EIPS/eip-712) typed data signature. This function is interoperable with all wallet types (smart accounts or EOAs).\n *\n * @param {string} options.address The address that signed the typed data\n * @param {string | Uint8Array | Signature} options.signature The signature that was signed\n * @param {ThirdwebClient} options.client The Thirdweb client\n * @param {Chain} options.chain The chain that the address is on. For an EOA, this can be any chain.\n * @param {string} [options.accountFactory.address] The address of the account factory that created the account if using a smart account with a custom account factory\n * @param {Hex} [options.accountFactory.verificationCalldata] The calldata that was used to create the account if using a smart account with a custom account factory\n * @param {typeof VerifyTypedDataParams.message} options.message The EIP-712 message that was signed.\n * @param {typeof VerifyTypedDataParams.domain} options.domain The EIP-712 domain that was signed.\n * @param {typeof VerifyTypedDataParams.primaryType} options.primaryType The EIP-712 primary type that was signed.\n * @param {typeof VerifyTypedDataParams.types} options.types The EIP-712 types that were signed.\n *\n * @returns {Promise<boolean>} A promise that resolves to `true` if the signature is valid, or `false` otherwise.\n *\n * @example\n * ```ts\n * import { verifyTypedData } from \"thirdweb/utils\";\n * const isValid = await verifyTypedData({\n *   address: \"0x...\",\n *   signature: \"0x...\",\n *   client,\n *   chain,\n *   domain: {\n      name: \"Ether Mail\",\n      version: \"1\",\n      chainId: 1,\n      verifyingContract: \"0x0000000000000000000000000000000000000000\",\n    },\n *   primaryType: \"Mail\",\n *   types: {\n      Person: [\n        { name: \"name\", type: \"string\" },\n        { name: \"wallet\", type: \"address\" },\n      ],\n      Mail: [\n        { name: \"from\", type: \"Person\" },\n        { name: \"to\", type: \"Person\" },\n        { name: \"contents\", type: \"string\" },\n      ],\n    },\n    message: {\n      from: {\n        name: \"Cow\",\n        wallet: \"0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826\",\n      },\n      to: {\n        name: \"Bob\",\n        wallet: \"0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB\",\n      },\n      contents: \"Hello, Bob!\",\n    },\n * });\n * ```\n *\n * @auth\n */\nexport async function verifyTypedData<\n  typedData extends ox__TypedData.TypedData | Record<string, unknown>,\n  primaryType extends keyof typedData | \"EIP712Domain\",\n>({\n  address,\n  signature,\n  client,\n  chain,\n  accountFactory,\n  message,\n  domain,\n  primaryType,\n  types,\n}: VerifyTypedDataParams<typedData, primaryType>): Promise<boolean> {\n  const messageHash = ox__TypedData.getSignPayload({\n    domain,\n    message,\n    primaryType,\n    types,\n  } as HashTypedDataParams);\n\n  if (!isHex(signature)) {\n    return false;\n  }\n\n  try {\n    const recoveredAddress = ox__Secp256k1.recoverAddress({\n      payload: messageHash,\n      signature: ox__Signature.fromHex(signature),\n    });\n\n    if (recoveredAddress.toLowerCase() === address.toLowerCase()) {\n      return true;\n    }\n  } catch {\n    // no-op, we skip to contract signature check\n  }\n  return verifyHash({\n    accountFactory,\n    address,\n    chain,\n    client,\n    hash: messageHash,\n    signature,\n  });\n}\n", "import type * as ox__Authorization from \"ox/Authorization\";\nimport type { Address } from \"../../../utils/address.js\";\nimport type { Account } from \"../../../wallets/interfaces/wallet.js\";\n\n/**\n * An EIP-7702 authorization object fully prepared and ready for signing.\n *\n * @beta\n * @transaction\n */\nexport type AuthorizationRequest = {\n  address: Address;\n  chainId: number;\n  nonce: bigint;\n};\n\n/**\n * Represents a signed EIP-7702 authorization object.\n *\n * @beta\n * @transaction\n */\nexport type SignedAuthorization = ox__Authorization.ListSigned[number];\n\n/**\n * Sign the given EIP-7702 authorization object.\n * @param options - The options for `signAuthorization`\n * Refer to the type [`SignAuthorizationOptions`](https://portal.thirdweb.com/references/typescript/v5/SignAuthorizationOptions)\n * @returns The signed authorization object\n *\n * ```ts\n * import { signAuthorization } from \"thirdweb\";\n *\n * const authorization = await signAuthorization({\n *     request: {\n *         address: \"0x...\",\n *         chainId: 911867,\n *         nonce: 100n,\n *     },\n *     account: myAccount,\n * });\n * ```\n *\n * @beta\n * @transaction\n */\nexport async function signAuthorization(options: {\n  account: Account;\n  request: AuthorizationRequest;\n}): Promise<SignedAuthorization> {\n  const { account, request } = options;\n  if (typeof account.signAuthorization === \"undefined\") {\n    throw new Error(\n      \"This account type does not yet support signing EIP-7702 authorizations\",\n    );\n  }\n  return account.signAuthorization(request);\n}\n"],
  "mappings": "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",
  "names": ["toBytes", "sha256", "sha256", "searchTransactions", "joinedValues", "config", "request", "sendTransaction", "client", "stringify", "client", "client", "stringify", "searchTransactions", "client", "stringify", "client", "_a", "sendTransaction", "getAddress", "client", "tx", "amount", "keccak256", "client", "fromHex"]
}
