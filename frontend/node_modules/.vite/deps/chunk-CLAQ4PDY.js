import {
  getCurrencyMetadata
} from "./chunk-HJ6MCRWL.js";
import {
  detectMethod
} from "./chunk-T5PDFO3A.js";
import {
  readContract
} from "./chunk-SZMJC6C4.js";
import {
  eth_getBlockByNumber
} from "./chunk-J6NIOEGA.js";
import {
  getRpcClient
} from "./chunk-X7CG3L2Z.js";
import {
  toTokens
} from "./chunk-DVNKWNZO.js";
import {
  getContract
} from "./chunk-UZAMIWMY.js";

// node_modules/thirdweb/dist/esm/extensions/erc165/__generated__/IERC165/read/supportsInterface.js
var FN_SELECTOR = "0x01ffc9a7";
var FN_INPUTS = [
  {
    name: "interfaceId",
    type: "bytes4"
  }
];
var FN_OUTPUTS = [
  {
    type: "bool"
  }
];
async function supportsInterface(options) {
  return readContract({
    contract: options.contract,
    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS],
    params: [options.interfaceId]
  });
}

// node_modules/thirdweb/dist/esm/extensions/erc721/read/isERC721.js
function isERC721(options) {
  return supportsInterface({
    contract: options.contract,
    interfaceId: "0x80ac58cd"
  });
}

// node_modules/thirdweb/dist/esm/extensions/erc1155/read/isERC1155.js
function isERC1155(options) {
  return supportsInterface({
    contract: options.contract,
    interfaceId: "0xd9b67a26"
  });
}

// node_modules/thirdweb/dist/esm/extensions/marketplace/utils.js
async function getNFTAsset(options) {
  const [erc721, erc1155] = await Promise.all([
    isERC721(options),
    isERC1155(options)
  ]);
  switch (true) {
    case erc721: {
      const { getNFT } = await import("./getNFT-4HRFM2YM.js");
      return getNFT(options);
    }
    case erc1155: {
      const { getNFT } = await import("./getNFT-2CBB2FPO.js");
      return getNFT(options);
    }
    default: {
      throw new Error("Contract is neither ERC721 nor ERC1155.");
    }
  }
}
function computeStatus(options) {
  switch (options.listingStatus) {
    case 1: {
      if (options.startTimestamp > options.blockTimeStamp) {
        return "CREATED";
      }
      if (options.endTimestamp < options.blockTimeStamp) {
        return "EXPIRED";
      }
      return "ACTIVE";
    }
    case 2: {
      return "COMPLETED";
    }
    case 3: {
      return "CANCELLED";
    }
    default: {
      throw new Error(`Invalid listing status: "${options.listingStatus}"`);
    }
  }
}

// node_modules/thirdweb/dist/esm/extensions/marketplace/direct-listings/utils.js
async function mapDirectListing(options) {
  const { latestBlock, rawListing } = options;
  const status = computeStatus({
    blockTimeStamp: latestBlock.timestamp,
    endTimestamp: rawListing.endTimestamp,
    listingStatus: rawListing.status,
    startTimestamp: rawListing.startTimestamp
  });
  const currencyContract = getContract({
    ...options.contract,
    address: rawListing.currency
  });
  const [currencyValuePerToken, nftAsset] = await Promise.all([
    getCurrencyMetadata({
      contract: currencyContract
    }),
    getNFTAsset({
      ...options,
      contract: getContract({
        ...options.contract,
        address: rawListing.assetContract
      }),
      tokenId: rawListing.tokenId
    })
  ]);
  return {
    asset: nftAsset,
    assetContractAddress: rawListing.assetContract,
    creatorAddress: rawListing.listingCreator,
    currencyContractAddress: rawListing.currency,
    currencyValuePerToken: {
      ...currencyValuePerToken,
      chainId: currencyContract.chain.id,
      displayValue: toTokens(rawListing.pricePerToken, currencyValuePerToken.decimals),
      tokenAddress: currencyContract.address,
      value: rawListing.pricePerToken
    },
    endTimeInSeconds: rawListing.endTimestamp,
    id: rawListing.listingId,
    isReservedListing: rawListing.reserved,
    pricePerToken: rawListing.pricePerToken,
    quantity: rawListing.quantity,
    startTimeInSeconds: rawListing.startTimestamp,
    status,
    tokenId: rawListing.tokenId,
    type: "direct-listing"
  };
}
async function isListingValid(options) {
  const assetContract = getContract({
    ...options.contract,
    address: options.listing.assetContractAddress
  });
  const [erc721, erc1155] = await Promise.all([
    isERC721({ contract: assetContract }),
    isERC1155({ contract: assetContract })
  ]);
  if (erc721) {
    const [{ isApprovedForAll }, { getApproved }, { ownerOf }] = await Promise.all([
      import("./isApprovedForAll-3UIKF3ZS.js"),
      import("./getApproved-OWFZWZY5.js"),
      import("./ownerOf-TDHGWCIO.js")
    ]);
    const [approvedForAll, approvedOperator, tokenOwner] = await Promise.all([
      isApprovedForAll({
        contract: assetContract,
        // the marketplace contract address has to be approved to transfer the token
        operator: options.contract.address,
        owner: options.listing.creatorAddress
      }),
      getApproved({
        contract: assetContract,
        tokenId: options.listing.tokenId
      }).catch(() => ""),
      ownerOf({
        contract: assetContract,
        tokenId: options.listing.tokenId
      })
    ]);
    if (!approvedForAll && approvedOperator !== options.contract.address) {
      return { reason: "Asset not approved for marketplace.", valid: false };
    }
    if (tokenOwner !== options.listing.creatorAddress) {
      return {
        reason: "Listing creator no longer owns this token.",
        valid: false
      };
    }
    return {
      valid: true
    };
  }
  if (erc1155) {
    const [{ isApprovedForAll }, { balanceOf }] = await Promise.all([
      import("./isApprovedForAll-55PUFIQ6.js"),
      import("./balanceOf-5ORHHRA4.js")
    ]);
    const [approvedForAll, balance] = await Promise.all([
      isApprovedForAll({
        contract: assetContract,
        // the marketplace contract address has to be approved to transfer the token
        operator: options.contract.address,
        owner: options.listing.creatorAddress
      }),
      balanceOf({
        contract: assetContract,
        owner: options.listing.creatorAddress,
        tokenId: options.listing.tokenId
      })
    ]);
    if (!approvedForAll) {
      return { reason: "Asset not approved for marketplace.", valid: false };
    }
    const quantityWanted = options.quantity || options.listing.quantity;
    if (balance < quantityWanted) {
      return {
        reason: "Seller does not have enough balance of token to fulfill order.",
        valid: false
      };
    }
    return {
      valid: true
    };
  }
  return {
    reason: "AssetContract must implement ERC 1155 or ERC 721.",
    valid: false
  };
}

// node_modules/thirdweb/dist/esm/extensions/marketplace/__generated__/IDirectListings/read/getListing.js
var FN_SELECTOR2 = "0x107a274a";
var FN_INPUTS2 = [
  {
    name: "_listingId",
    type: "uint256"
  }
];
var FN_OUTPUTS2 = [
  {
    components: [
      {
        name: "listingId",
        type: "uint256"
      },
      {
        name: "tokenId",
        type: "uint256"
      },
      {
        name: "quantity",
        type: "uint256"
      },
      {
        name: "pricePerToken",
        type: "uint256"
      },
      {
        name: "startTimestamp",
        type: "uint128"
      },
      {
        name: "endTimestamp",
        type: "uint128"
      },
      {
        name: "listingCreator",
        type: "address"
      },
      {
        name: "assetContract",
        type: "address"
      },
      {
        name: "currency",
        type: "address"
      },
      {
        name: "tokenType",
        type: "uint8"
      },
      {
        name: "status",
        type: "uint8"
      },
      {
        name: "reserved",
        type: "bool"
      }
    ],
    name: "listing",
    type: "tuple"
  }
];
function isGetListingSupported(availableSelectors) {
  return detectMethod({
    availableSelectors,
    method: [FN_SELECTOR2, FN_INPUTS2, FN_OUTPUTS2]
  });
}
async function getListing(options) {
  return readContract({
    contract: options.contract,
    method: [FN_SELECTOR2, FN_INPUTS2, FN_OUTPUTS2],
    params: [options.listingId]
  });
}

// node_modules/thirdweb/dist/esm/extensions/marketplace/direct-listings/read/getListing.js
async function getListing2(options) {
  const rpcClient = getRpcClient(options.contract);
  const [rawListing, latestBlock] = await Promise.all([
    getListing(options),
    eth_getBlockByNumber(rpcClient, {
      blockTag: "latest"
    })
  ]);
  return mapDirectListing({
    contract: options.contract,
    latestBlock,
    rawListing
  });
}
function isGetListingSupported2(availableSelectors) {
  return isGetListingSupported(availableSelectors);
}

export {
  isERC721,
  isERC1155,
  isListingValid,
  getListing2 as getListing,
  isGetListingSupported2 as isGetListingSupported
};
//# sourceMappingURL=chunk-CLAQ4PDY.js.map
