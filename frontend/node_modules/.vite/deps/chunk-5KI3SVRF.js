import {
  executeWithSignature,
  getQueuedTransactionHash
} from "./chunk-7VW6TCBI.js";
import {
  once
} from "./chunk-NACC2RRT.js";
import {
  socialAuthOptions
} from "./chunk-22D2ZAQ3.js";
import {
  prepareContractCall
} from "./chunk-7UCB3KUJ.js";
import {
  getDefaultBundlerUrl
} from "./chunk-CTU5HEBU.js";
import {
  toSerializableTransaction
} from "./chunk-QCGN5F3I.js";
import {
  getBytecode
} from "./chunk-EJZW7PV4.js";
import {
  randomBytesHex
} from "./chunk-S4ZD6P6T.js";
import {
  getRpcClient
} from "./chunk-X7CG3L2Z.js";
import {
  stringify
} from "./chunk-2CIJO3V3.js";
import {
  getContract
} from "./chunk-UZAMIWMY.js";
import {
  getAddress
} from "./chunk-6SVI5C4W.js";
import {
  ethereum
} from "./chunk-JS4FUXMM.js";
import {
  getCachedChain
} from "./chunk-Z2MF3EIF.js";
import {
  withCache
} from "./chunk-G24WGTAU.js";
import {
  getClientFetch
} from "./chunk-TU6UWWTV.js";

// node_modules/thirdweb/dist/esm/extensions/erc7702/__generated__/MinimalAccount/write/execute.js
var FN_SELECTOR = "0x3f707e6b";
var FN_INPUTS = [
  {
    type: "tuple[]",
    name: "calls",
    components: [
      {
        type: "address",
        name: "target"
      },
      {
        type: "uint256",
        name: "value"
      },
      {
        type: "bytes",
        name: "data"
      }
    ]
  }
];
var FN_OUTPUTS = [];
function execute(options) {
  const asyncOptions = once(async () => {
    return "asyncParams" in options ? await options.asyncParams() : options;
  });
  return prepareContractCall({
    contract: options.contract,
    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS],
    params: async () => {
      const resolvedOptions = await asyncOptions();
      return [resolvedOptions.calls];
    },
    value: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.value;
    },
    accessList: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.accessList;
    },
    gas: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.gas;
    },
    gasPrice: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.gasPrice;
    },
    maxFeePerGas: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.maxFeePerGas;
    },
    maxPriorityFeePerGas: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.maxPriorityFeePerGas;
    },
    nonce: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.nonce;
    },
    extraGas: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.extraGas;
    },
    erc20Value: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.erc20Value;
    },
    authorizationList: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.authorizationList;
    }
  });
}

// node_modules/thirdweb/dist/esm/wallets/in-app/core/eip7702/minimal-account.js
async function getDelegationContractAddress(args) {
  const { client, chain, bundlerUrl } = args;
  const url = bundlerUrl ?? getDefaultBundlerUrl(chain);
  const cacheKey = `delegation-contract:${url}`;
  return withCache(async () => {
    var _a;
    const fetchWithHeaders = getClientFetch(client);
    const response = await fetchWithHeaders(url, {
      useAuthToken: true,
      body: stringify({
        id: 1,
        jsonrpc: "2.0",
        method: "tw_getDelegationContract",
        params: []
      }),
      headers: {
        "Content-Type": "application/json"
      },
      method: "POST"
    });
    if (!response.ok) {
      throw new Error(`Failed to fetch delegation contract: ${response.status} ${response.statusText}`);
    }
    const result = await response.json();
    if (result.error) {
      throw new Error(`Delegation contract RPC error: ${JSON.stringify(result.error)}`);
    }
    if (!((_a = result.result) == null ? void 0 : _a.delegationContract)) {
      throw new Error("Invalid response: missing delegationContract in result");
    }
    return result.result.delegationContract;
  }, { cacheKey, cacheTime: 24 * 60 * 60 * 1e3 });
}
var create7702MinimalAccount = (args) => {
  const { client, adminAccount, sponsorGas } = args;
  const _sendTxWithAuthorization = async (txs) => {
    var _a, _b, _c;
    const firstTx = txs[0];
    if (!firstTx) {
      throw new Error("No transactions provided");
    }
    const chain = getCachedChain(firstTx.chainId);
    const eoaContract = getContract({
      address: adminAccount.address,
      chain,
      client,
      abi: MinimalAccountAbi
    });
    let authorization = (_a = firstTx.authorizationList) == null ? void 0 : _a[0];
    const delegationContractAddress = await getDelegationContractAddress({
      client,
      chain
    });
    if (authorization && ((_b = authorization.address) == null ? void 0 : _b.toLowerCase()) !== delegationContractAddress.toLowerCase()) {
      throw new Error(`Authorization address does not match expected delegation contract address. Expected ${delegationContractAddress} but got ${authorization.address}`);
    }
    if (!authorization) {
      const isMinimalAccount = await is7702MinimalAccount(eoaContract, delegationContractAddress);
      if (!isMinimalAccount) {
        let nonce = firstTx.nonce ? BigInt(firstTx.nonce) : BigInt(await getNonce({
          client,
          address: adminAccount.address,
          chain
        }));
        nonce += sponsorGas ? 0n : 1n;
        const auth = await ((_c = adminAccount.signAuthorization) == null ? void 0 : _c.call(adminAccount, {
          address: getAddress(delegationContractAddress),
          chainId: firstTx.chainId,
          nonce
        }));
        if (!auth) {
          throw new Error("Failed to sign authorization");
        }
        authorization = auth;
      }
    }
    if (sponsorGas) {
      const wrappedCalls = {
        calls: txs.map((tx) => ({
          data: tx.data ?? "0x",
          target: getAddress(tx.to ?? ""),
          value: tx.value ?? 0n
        })),
        uid: randomBytesHex()
      };
      const signature = await adminAccount.signTypedData({
        domain: {
          chainId: firstTx.chainId,
          name: "MinimalAccount",
          verifyingContract: eoaContract.address,
          version: "1"
        },
        message: wrappedCalls,
        primaryType: "WrappedCalls",
        types: {
          Call: [
            { name: "target", type: "address" },
            { name: "value", type: "uint256" },
            { name: "data", type: "bytes" }
          ],
          WrappedCalls: [
            { name: "calls", type: "Call[]" },
            { name: "uid", type: "bytes32" }
          ]
        }
      });
      const result = await executeWithSignature({
        authorization,
        eoaAddress: getAddress(adminAccount.address),
        options: {
          chain: getCachedChain(firstTx.chainId),
          client
        },
        signature,
        wrappedCalls
      });
      const transactionHash = await waitForTransactionHash({
        options: {
          chain: getCachedChain(firstTx.chainId),
          client
        },
        transactionId: result.transactionId
      });
      return {
        transactionHash
      };
    }
    const executeTx = execute({
      calls: txs.map((tx) => ({
        data: tx.data ?? "0x",
        target: getAddress(tx.to ?? ""),
        value: tx.value ?? 0n
      })),
      contract: eoaContract,
      overrides: {
        authorizationList: authorization ? [authorization] : void 0,
        value: txs.reduce((acc, tx) => acc + (tx.value ?? 0n), 0n)
      }
    });
    const serializedTx = await toSerializableTransaction({
      from: adminAccount.address,
      transaction: executeTx
    });
    return adminAccount.sendTransaction(serializedTx);
  };
  const minimalAccount = {
    address: adminAccount.address,
    sendBatchTransaction: async (txs) => {
      return _sendTxWithAuthorization(txs);
    },
    sendTransaction: async (tx) => {
      return _sendTxWithAuthorization([tx]);
    },
    signMessage: ({ message, originalMessage, chainId }) => adminAccount.signMessage({ chainId, message, originalMessage }),
    signTypedData: (_typedData) => adminAccount.signTypedData(_typedData),
    sendCalls: async (options) => {
      const { inAppWalletSendCalls } = await import("./in-app-wallet-calls-W6OEBFCG.js");
      const firstCall = options.calls[0];
      if (!firstCall) {
        throw new Error("No calls to send");
      }
      const client2 = firstCall.client;
      const chain = firstCall.chain || options.chain;
      const id = await inAppWalletSendCalls({
        account: minimalAccount,
        calls: options.calls,
        chain
      });
      return { chain, client: client2, id };
    },
    getCallsStatus: async (options) => {
      const { inAppWalletGetCallsStatus } = await import("./in-app-wallet-calls-W6OEBFCG.js");
      return inAppWalletGetCallsStatus(options);
    },
    getCapabilities: async (options) => {
      return {
        [options.chainId ?? 1]: {
          atomic: {
            status: "supported"
          },
          paymasterService: {
            supported: sponsorGas ?? false
          }
        }
      };
    }
  };
  return minimalAccount;
};
async function getNonce(args) {
  const { client, address, chain } = args;
  const rpcRequest = getRpcClient({
    chain,
    client
  });
  const nonce = await import("./eth_getTransactionCount-LKOSIJNH.js").then(({ eth_getTransactionCount }) => eth_getTransactionCount(rpcRequest, {
    address: getAddress(address),
    blockTag: "pending"
  }));
  return nonce;
}
async function is7702MinimalAccount(eoaContract, delegationContractAddress) {
  const code = await getBytecode(eoaContract);
  const isDelegated = code.length > 0 && code.startsWith("0xef0100");
  const target = `0x${code.slice(8, 48)}`;
  return isDelegated && target.toLowerCase() === delegationContractAddress.toLowerCase();
}
async function waitForTransactionHash(args) {
  const timeout = args.timeoutMs || 3e5;
  const interval = args.intervalMs || 1e3;
  const endtime = Date.now() + timeout;
  while (Date.now() < endtime) {
    const result = await getQueuedTransactionHash({
      options: args.options,
      transactionId: args.transactionId
    });
    if (result.transactionHash) {
      return result.transactionHash;
    }
    await new Promise((resolve) => setTimeout(resolve, interval));
  }
  throw new Error(`Timeout waiting for transaction to be mined on chain ${args.options.chain.id} with transactionId: ${args.transactionId}`);
}
var MinimalAccountAbi = [
  { type: "receive", stateMutability: "payable" },
  {
    type: "function",
    name: "createSessionWithSig",
    inputs: [
      {
        name: "sessionSpec",
        type: "tuple",
        internalType: "struct SessionLib.SessionSpec",
        components: [
          { name: "signer", type: "address", internalType: "address" },
          { name: "isWildcard", type: "bool", internalType: "bool" },
          { name: "expiresAt", type: "uint256", internalType: "uint256" },
          {
            name: "callPolicies",
            type: "tuple[]",
            internalType: "struct SessionLib.CallSpec[]",
            components: [
              { name: "target", type: "address", internalType: "address" },
              { name: "selector", type: "bytes4", internalType: "bytes4" },
              {
                name: "maxValuePerUse",
                type: "uint256",
                internalType: "uint256"
              },
              {
                name: "valueLimit",
                type: "tuple",
                internalType: "struct SessionLib.UsageLimit",
                components: [
                  {
                    name: "limitType",
                    type: "uint8",
                    internalType: "enum SessionLib.LimitType"
                  },
                  { name: "limit", type: "uint256", internalType: "uint256" },
                  { name: "period", type: "uint256", internalType: "uint256" }
                ]
              },
              {
                name: "constraints",
                type: "tuple[]",
                internalType: "struct SessionLib.Constraint[]",
                components: [
                  {
                    name: "condition",
                    type: "uint8",
                    internalType: "enum SessionLib.Condition"
                  },
                  { name: "index", type: "uint64", internalType: "uint64" },
                  {
                    name: "refValue",
                    type: "bytes32",
                    internalType: "bytes32"
                  },
                  {
                    name: "limit",
                    type: "tuple",
                    internalType: "struct SessionLib.UsageLimit",
                    components: [
                      {
                        name: "limitType",
                        type: "uint8",
                        internalType: "enum SessionLib.LimitType"
                      },
                      {
                        name: "limit",
                        type: "uint256",
                        internalType: "uint256"
                      },
                      {
                        name: "period",
                        type: "uint256",
                        internalType: "uint256"
                      }
                    ]
                  }
                ]
              }
            ]
          },
          {
            name: "transferPolicies",
            type: "tuple[]",
            internalType: "struct SessionLib.TransferSpec[]",
            components: [
              { name: "target", type: "address", internalType: "address" },
              {
                name: "maxValuePerUse",
                type: "uint256",
                internalType: "uint256"
              },
              {
                name: "valueLimit",
                type: "tuple",
                internalType: "struct SessionLib.UsageLimit",
                components: [
                  {
                    name: "limitType",
                    type: "uint8",
                    internalType: "enum SessionLib.LimitType"
                  },
                  { name: "limit", type: "uint256", internalType: "uint256" },
                  { name: "period", type: "uint256", internalType: "uint256" }
                ]
              }
            ]
          },
          { name: "uid", type: "bytes32", internalType: "bytes32" }
        ]
      },
      { name: "signature", type: "bytes", internalType: "bytes" }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "eip712Domain",
    inputs: [],
    outputs: [
      { name: "fields", type: "bytes1", internalType: "bytes1" },
      { name: "name", type: "string", internalType: "string" },
      { name: "version", type: "string", internalType: "string" },
      { name: "chainId", type: "uint256", internalType: "uint256" },
      { name: "verifyingContract", type: "address", internalType: "address" },
      { name: "salt", type: "bytes32", internalType: "bytes32" },
      { name: "extensions", type: "uint256[]", internalType: "uint256[]" }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "execute",
    inputs: [
      {
        name: "calls",
        type: "tuple[]",
        internalType: "struct Call[]",
        components: [
          { name: "target", type: "address", internalType: "address" },
          { name: "value", type: "uint256", internalType: "uint256" },
          { name: "data", type: "bytes", internalType: "bytes" }
        ]
      }
    ],
    outputs: [],
    stateMutability: "payable"
  },
  {
    type: "function",
    name: "executeWithSig",
    inputs: [
      {
        name: "wrappedCalls",
        type: "tuple",
        internalType: "struct WrappedCalls",
        components: [
          {
            name: "calls",
            type: "tuple[]",
            internalType: "struct Call[]",
            components: [
              { name: "target", type: "address", internalType: "address" },
              { name: "value", type: "uint256", internalType: "uint256" },
              { name: "data", type: "bytes", internalType: "bytes" }
            ]
          },
          { name: "uid", type: "bytes32", internalType: "bytes32" }
        ]
      },
      { name: "signature", type: "bytes", internalType: "bytes" }
    ],
    outputs: [],
    stateMutability: "payable"
  },
  {
    type: "function",
    name: "getCallPoliciesForSigner",
    inputs: [{ name: "signer", type: "address", internalType: "address" }],
    outputs: [
      {
        name: "",
        type: "tuple[]",
        internalType: "struct SessionLib.CallSpec[]",
        components: [
          { name: "target", type: "address", internalType: "address" },
          { name: "selector", type: "bytes4", internalType: "bytes4" },
          { name: "maxValuePerUse", type: "uint256", internalType: "uint256" },
          {
            name: "valueLimit",
            type: "tuple",
            internalType: "struct SessionLib.UsageLimit",
            components: [
              {
                name: "limitType",
                type: "uint8",
                internalType: "enum SessionLib.LimitType"
              },
              { name: "limit", type: "uint256", internalType: "uint256" },
              { name: "period", type: "uint256", internalType: "uint256" }
            ]
          },
          {
            name: "constraints",
            type: "tuple[]",
            internalType: "struct SessionLib.Constraint[]",
            components: [
              {
                name: "condition",
                type: "uint8",
                internalType: "enum SessionLib.Condition"
              },
              { name: "index", type: "uint64", internalType: "uint64" },
              { name: "refValue", type: "bytes32", internalType: "bytes32" },
              {
                name: "limit",
                type: "tuple",
                internalType: "struct SessionLib.UsageLimit",
                components: [
                  {
                    name: "limitType",
                    type: "uint8",
                    internalType: "enum SessionLib.LimitType"
                  },
                  { name: "limit", type: "uint256", internalType: "uint256" },
                  { name: "period", type: "uint256", internalType: "uint256" }
                ]
              }
            ]
          }
        ]
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getSessionExpirationForSigner",
    inputs: [{ name: "signer", type: "address", internalType: "address" }],
    outputs: [{ name: "", type: "uint256", internalType: "uint256" }],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getSessionStateForSigner",
    inputs: [{ name: "signer", type: "address", internalType: "address" }],
    outputs: [
      {
        name: "",
        type: "tuple",
        internalType: "struct SessionLib.SessionState",
        components: [
          {
            name: "transferValue",
            type: "tuple[]",
            internalType: "struct SessionLib.LimitState[]",
            components: [
              { name: "remaining", type: "uint256", internalType: "uint256" },
              { name: "target", type: "address", internalType: "address" },
              { name: "selector", type: "bytes4", internalType: "bytes4" },
              { name: "index", type: "uint256", internalType: "uint256" }
            ]
          },
          {
            name: "callValue",
            type: "tuple[]",
            internalType: "struct SessionLib.LimitState[]",
            components: [
              { name: "remaining", type: "uint256", internalType: "uint256" },
              { name: "target", type: "address", internalType: "address" },
              { name: "selector", type: "bytes4", internalType: "bytes4" },
              { name: "index", type: "uint256", internalType: "uint256" }
            ]
          },
          {
            name: "callParams",
            type: "tuple[]",
            internalType: "struct SessionLib.LimitState[]",
            components: [
              { name: "remaining", type: "uint256", internalType: "uint256" },
              { name: "target", type: "address", internalType: "address" },
              { name: "selector", type: "bytes4", internalType: "bytes4" },
              { name: "index", type: "uint256", internalType: "uint256" }
            ]
          }
        ]
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getTransferPoliciesForSigner",
    inputs: [{ name: "signer", type: "address", internalType: "address" }],
    outputs: [
      {
        name: "",
        type: "tuple[]",
        internalType: "struct SessionLib.TransferSpec[]",
        components: [
          { name: "target", type: "address", internalType: "address" },
          { name: "maxValuePerUse", type: "uint256", internalType: "uint256" },
          {
            name: "valueLimit",
            type: "tuple",
            internalType: "struct SessionLib.UsageLimit",
            components: [
              {
                name: "limitType",
                type: "uint8",
                internalType: "enum SessionLib.LimitType"
              },
              { name: "limit", type: "uint256", internalType: "uint256" },
              { name: "period", type: "uint256", internalType: "uint256" }
            ]
          }
        ]
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "isWildcardSigner",
    inputs: [{ name: "signer", type: "address", internalType: "address" }],
    outputs: [{ name: "", type: "bool", internalType: "bool" }],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "onERC1155BatchReceived",
    inputs: [
      { name: "", type: "address", internalType: "address" },
      { name: "", type: "address", internalType: "address" },
      { name: "", type: "uint256[]", internalType: "uint256[]" },
      { name: "", type: "uint256[]", internalType: "uint256[]" },
      { name: "", type: "bytes", internalType: "bytes" }
    ],
    outputs: [{ name: "", type: "bytes4", internalType: "bytes4" }],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "onERC1155Received",
    inputs: [
      { name: "", type: "address", internalType: "address" },
      { name: "", type: "address", internalType: "address" },
      { name: "", type: "uint256", internalType: "uint256" },
      { name: "", type: "uint256", internalType: "uint256" },
      { name: "", type: "bytes", internalType: "bytes" }
    ],
    outputs: [{ name: "", type: "bytes4", internalType: "bytes4" }],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "onERC721Received",
    inputs: [
      { name: "", type: "address", internalType: "address" },
      { name: "", type: "address", internalType: "address" },
      { name: "", type: "uint256", internalType: "uint256" },
      { name: "", type: "bytes", internalType: "bytes" }
    ],
    outputs: [{ name: "", type: "bytes4", internalType: "bytes4" }],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "supportsInterface",
    inputs: [{ name: "interfaceId", type: "bytes4", internalType: "bytes4" }],
    outputs: [{ name: "", type: "bool", internalType: "bool" }],
    stateMutability: "view"
  },
  {
    type: "event",
    name: "Executed",
    inputs: [
      { name: "to", type: "address", indexed: true, internalType: "address" },
      {
        name: "value",
        type: "uint256",
        indexed: false,
        internalType: "uint256"
      },
      { name: "data", type: "bytes", indexed: false, internalType: "bytes" }
    ],
    anonymous: false
  },
  {
    type: "event",
    name: "SessionCreated",
    inputs: [
      {
        name: "signer",
        type: "address",
        indexed: true,
        internalType: "address"
      },
      {
        name: "sessionSpec",
        type: "tuple",
        indexed: false,
        internalType: "struct SessionLib.SessionSpec",
        components: [
          { name: "signer", type: "address", internalType: "address" },
          { name: "isWildcard", type: "bool", internalType: "bool" },
          { name: "expiresAt", type: "uint256", internalType: "uint256" },
          {
            name: "callPolicies",
            type: "tuple[]",
            internalType: "struct SessionLib.CallSpec[]",
            components: [
              { name: "target", type: "address", internalType: "address" },
              { name: "selector", type: "bytes4", internalType: "bytes4" },
              {
                name: "maxValuePerUse",
                type: "uint256",
                internalType: "uint256"
              },
              {
                name: "valueLimit",
                type: "tuple",
                internalType: "struct SessionLib.UsageLimit",
                components: [
                  {
                    name: "limitType",
                    type: "uint8",
                    internalType: "enum SessionLib.LimitType"
                  },
                  { name: "limit", type: "uint256", internalType: "uint256" },
                  { name: "period", type: "uint256", internalType: "uint256" }
                ]
              },
              {
                name: "constraints",
                type: "tuple[]",
                internalType: "struct SessionLib.Constraint[]",
                components: [
                  {
                    name: "condition",
                    type: "uint8",
                    internalType: "enum SessionLib.Condition"
                  },
                  { name: "index", type: "uint64", internalType: "uint64" },
                  {
                    name: "refValue",
                    type: "bytes32",
                    internalType: "bytes32"
                  },
                  {
                    name: "limit",
                    type: "tuple",
                    internalType: "struct SessionLib.UsageLimit",
                    components: [
                      {
                        name: "limitType",
                        type: "uint8",
                        internalType: "enum SessionLib.LimitType"
                      },
                      {
                        name: "limit",
                        type: "uint256",
                        internalType: "uint256"
                      },
                      {
                        name: "period",
                        type: "uint256",
                        internalType: "uint256"
                      }
                    ]
                  }
                ]
              }
            ]
          },
          {
            name: "transferPolicies",
            type: "tuple[]",
            internalType: "struct SessionLib.TransferSpec[]",
            components: [
              { name: "target", type: "address", internalType: "address" },
              {
                name: "maxValuePerUse",
                type: "uint256",
                internalType: "uint256"
              },
              {
                name: "valueLimit",
                type: "tuple",
                internalType: "struct SessionLib.UsageLimit",
                components: [
                  {
                    name: "limitType",
                    type: "uint8",
                    internalType: "enum SessionLib.LimitType"
                  },
                  { name: "limit", type: "uint256", internalType: "uint256" },
                  { name: "period", type: "uint256", internalType: "uint256" }
                ]
              }
            ]
          },
          { name: "uid", type: "bytes32", internalType: "bytes32" }
        ]
      }
    ],
    anonymous: false
  },
  {
    type: "event",
    name: "ValueReceived",
    inputs: [
      { name: "from", type: "address", indexed: true, internalType: "address" },
      {
        name: "value",
        type: "uint256",
        indexed: false,
        internalType: "uint256"
      }
    ],
    anonymous: false
  },
  {
    type: "error",
    name: "AllowanceExceeded",
    inputs: [
      { name: "allowanceUsage", type: "uint256", internalType: "uint256" },
      { name: "limit", type: "uint256", internalType: "uint256" },
      { name: "period", type: "uint64", internalType: "uint64" }
    ]
  },
  {
    type: "error",
    name: "CallPolicyViolated",
    inputs: [
      { name: "target", type: "address", internalType: "address" },
      { name: "selector", type: "bytes4", internalType: "bytes4" }
    ]
  },
  { type: "error", name: "CallReverted", inputs: [] },
  {
    type: "error",
    name: "ConditionFailed",
    inputs: [
      { name: "param", type: "bytes32", internalType: "bytes32" },
      { name: "refValue", type: "bytes32", internalType: "bytes32" },
      { name: "condition", type: "uint8", internalType: "uint8" }
    ]
  },
  {
    type: "error",
    name: "InvalidDataLength",
    inputs: [
      { name: "actualLength", type: "uint256", internalType: "uint256" },
      { name: "expectedLength", type: "uint256", internalType: "uint256" }
    ]
  },
  {
    type: "error",
    name: "InvalidSignature",
    inputs: [
      { name: "msgSender", type: "address", internalType: "address" },
      { name: "thisAddress", type: "address", internalType: "address" }
    ]
  },
  {
    type: "error",
    name: "LifetimeUsageExceeded",
    inputs: [
      { name: "lifetimeUsage", type: "uint256", internalType: "uint256" },
      { name: "limit", type: "uint256", internalType: "uint256" }
    ]
  },
  {
    type: "error",
    name: "MaxValueExceeded",
    inputs: [
      { name: "value", type: "uint256", internalType: "uint256" },
      { name: "maxValuePerUse", type: "uint256", internalType: "uint256" }
    ]
  },
  { type: "error", name: "NoCallsToExecute", inputs: [] },
  { type: "error", name: "SessionExpired", inputs: [] },
  { type: "error", name: "SessionExpiresTooSoon", inputs: [] },
  { type: "error", name: "SessionZeroSigner", inputs: [] },
  {
    type: "error",
    name: "TransferPolicyViolated",
    inputs: [{ name: "target", type: "address", internalType: "address" }]
  },
  { type: "error", name: "UIDAlreadyProcessed", inputs: [] }
];

// node_modules/thirdweb/dist/esm/wallets/in-app/core/wallet/index.js
function isInAppWallet(wallet) {
  return wallet.id === "inApp" || wallet.id === "embedded";
}
async function connectInAppWallet(options, createOptions, connector) {
  var _a, _b, _c, _d;
  if (
    // if auth mode is not specified, the default is popup
    ((_a = createOptions == null ? void 0 : createOptions.auth) == null ? void 0 : _a.mode) !== "popup" && ((_b = createOptions == null ? void 0 : createOptions.auth) == null ? void 0 : _b.mode) !== void 0 && connector.authenticateWithRedirect
  ) {
    const strategy = options.strategy;
    if (socialAuthOptions.includes(strategy)) {
      await connector.authenticateWithRedirect(strategy, (_c = createOptions == null ? void 0 : createOptions.auth) == null ? void 0 : _c.mode, (_d = createOptions == null ? void 0 : createOptions.auth) == null ? void 0 : _d.redirectUrl);
    }
  }
  const authResult = await connector.connect(options);
  const authAccount = authResult.user.account;
  return createInAppAccount({
    authAccount,
    client: options.client,
    createOptions,
    desiredChain: options.chain
  });
}
async function autoConnectInAppWallet(options, createOptions, connector) {
  if (options.authResult && connector.loginWithAuthToken) {
    await connector.loginWithAuthToken(options.authResult);
  }
  const user = await getAuthenticatedUser(connector);
  if (!user) {
    throw new Error("Failed to authenticate user.");
  }
  const authAccount = user.account;
  return createInAppAccount({
    authAccount,
    client: options.client,
    createOptions,
    desiredChain: options.chain
  });
}
async function convertToSmartAccount(options) {
  const { connectSmartAccount } = await import("./smart-CZPYAULO.js");
  return connectSmartAccount({
    chain: options.chain,
    client: options.client,
    personalAccount: options.authAccount
  }, options.smartAccountOptions);
}
async function getAuthenticatedUser(connector) {
  const user = await connector.getUser();
  switch (user.status) {
    case "Logged In, Wallet Initialized": {
      return user;
    }
  }
  return void 0;
}
async function createInAppAccount(options) {
  const { createOptions, authAccount, desiredChain, client } = options;
  let smartAccountOptions;
  let eip7702;
  const executionMode = createOptions && "executionMode" in createOptions ? createOptions.executionMode : void 0;
  if (executionMode) {
    if (executionMode.mode === "EIP4337") {
      smartAccountOptions = executionMode.smartAccount;
    } else if (executionMode.mode === "EIP7702") {
      eip7702 = executionMode;
    }
  }
  if (createOptions && "smartAccount" in createOptions && (createOptions == null ? void 0 : createOptions.smartAccount)) {
    smartAccountOptions = createOptions.smartAccount;
  }
  if (smartAccountOptions) {
    const [account, chain] = await convertToSmartAccount({
      authAccount,
      chain: desiredChain,
      client,
      smartAccountOptions
    });
    return { account, adminAccount: authAccount, chain };
  }
  if (eip7702) {
    const chain = desiredChain;
    if (!chain) {
      throw new Error("Chain is required for EIP-7702 execution, pass a chain when connecting the inAppWallet.");
    }
    const account = create7702MinimalAccount({
      adminAccount: authAccount,
      client,
      sponsorGas: eip7702.sponsorGas
    });
    return {
      account,
      adminAccount: authAccount,
      chain
    };
  }
  return { account: authAccount, chain: desiredChain || ethereum };
}

export {
  isInAppWallet,
  connectInAppWallet,
  autoConnectInAppWallet
};
//# sourceMappingURL=chunk-5KI3SVRF.js.map
