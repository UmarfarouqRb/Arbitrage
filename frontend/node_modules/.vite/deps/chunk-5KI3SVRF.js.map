{
  "version": 3,
  "sources": ["../../thirdweb/src/extensions/erc7702/__generated__/MinimalAccount/write/execute.ts", "../../thirdweb/src/wallets/in-app/core/eip7702/minimal-account.ts", "../../thirdweb/src/wallets/in-app/core/wallet/index.ts"],
  "sourcesContent": ["import type { AbiParameterToPrimitiveType } from \"abitype\";\nimport { prepareContractCall } from \"../../../../../transaction/prepare-contract-call.js\";\nimport type {\n  BaseTransactionOptions,\n  WithOverrides,\n} from \"../../../../../transaction/types.js\";\nimport { encodeAbiParameters } from \"../../../../../utils/abi/encodeAbiParameters.js\";\nimport { detectMethod } from \"../../../../../utils/bytecode/detectExtension.js\";\nimport { once } from \"../../../../../utils/promise/once.js\";\n\n/**\n * Represents the parameters for the \"execute\" function.\n */\nexport type ExecuteParams = WithOverrides<{\n  calls: AbiParameterToPrimitiveType<{\n    type: \"tuple[]\";\n    name: \"calls\";\n    components: [\n      { type: \"address\"; name: \"target\" },\n      { type: \"uint256\"; name: \"value\" },\n      { type: \"bytes\"; name: \"data\" },\n    ];\n  }>;\n}>;\n\nexport const FN_SELECTOR = \"0x3f707e6b\" as const;\nconst FN_INPUTS = [\n  {\n    type: \"tuple[]\",\n    name: \"calls\",\n    components: [\n      {\n        type: \"address\",\n        name: \"target\",\n      },\n      {\n        type: \"uint256\",\n        name: \"value\",\n      },\n      {\n        type: \"bytes\",\n        name: \"data\",\n      },\n    ],\n  },\n] as const;\nconst FN_OUTPUTS = [] as const;\n\n/**\n * Checks if the `execute` method is supported by the given contract.\n * @param availableSelectors An array of 4byte function selectors of the contract. You can get this in various ways, such as using \"whatsabi\" or if you have the ABI of the contract available you can use it to generate the selectors.\n * @returns A boolean indicating if the `execute` method is supported.\n * @extension ERC7702\n * @example\n * ```ts\n * import { isExecuteSupported } from \"thirdweb/extensions/erc7702\";\n *\n * const supported = isExecuteSupported([\"0x...\"]);\n * ```\n */\nexport function isExecuteSupported(availableSelectors: string[]) {\n  return detectMethod({\n    availableSelectors,\n    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS] as const,\n  });\n}\n\n/**\n * Encodes the parameters for the \"execute\" function.\n * @param options - The options for the execute function.\n * @returns The encoded ABI parameters.\n * @extension ERC7702\n * @example\n * ```ts\n * import { encodeExecuteParams } from \"thirdweb/extensions/erc7702\";\n * const result = encodeExecuteParams({\n *  calls: ...,\n * });\n * ```\n */\nexport function encodeExecuteParams(options: ExecuteParams) {\n  return encodeAbiParameters(FN_INPUTS, [options.calls]);\n}\n\n/**\n * Encodes the \"execute\" function into a Hex string with its parameters.\n * @param options - The options for the execute function.\n * @returns The encoded hexadecimal string.\n * @extension ERC7702\n * @example\n * ```ts\n * import { encodeExecute } from \"thirdweb/extensions/erc7702\";\n * const result = encodeExecute({\n *  calls: ...,\n * });\n * ```\n */\nexport function encodeExecute(options: ExecuteParams) {\n  // we do a \"manual\" concat here to avoid the overhead of the \"concatHex\" function\n  // we can do this because we know the specific formats of the values\n  return (FN_SELECTOR +\n    encodeExecuteParams(options).slice(2)) as `${typeof FN_SELECTOR}${string}`;\n}\n\n/**\n * Prepares a transaction to call the \"execute\" function on the contract.\n * @param options - The options for the \"execute\" function.\n * @returns A prepared transaction object.\n * @extension ERC7702\n * @example\n * ```ts\n * import { sendTransaction } from \"thirdweb\";\n * import { execute } from \"thirdweb/extensions/erc7702\";\n *\n * const transaction = execute({\n *  contract,\n *  calls: ...,\n *  overrides: {\n *    ...\n *  }\n * });\n *\n * // Send the transaction\n * await sendTransaction({ transaction, account });\n * ```\n */\nexport function execute(\n  options: BaseTransactionOptions<\n    | ExecuteParams\n    | {\n        asyncParams: () => Promise<ExecuteParams>;\n      }\n  >,\n) {\n  const asyncOptions = once(async () => {\n    return \"asyncParams\" in options ? await options.asyncParams() : options;\n  });\n\n  return prepareContractCall({\n    contract: options.contract,\n    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS] as const,\n    params: async () => {\n      const resolvedOptions = await asyncOptions();\n      return [resolvedOptions.calls] as const;\n    },\n    value: async () => (await asyncOptions()).overrides?.value,\n    accessList: async () => (await asyncOptions()).overrides?.accessList,\n    gas: async () => (await asyncOptions()).overrides?.gas,\n    gasPrice: async () => (await asyncOptions()).overrides?.gasPrice,\n    maxFeePerGas: async () => (await asyncOptions()).overrides?.maxFeePerGas,\n    maxPriorityFeePerGas: async () =>\n      (await asyncOptions()).overrides?.maxPriorityFeePerGas,\n    nonce: async () => (await asyncOptions()).overrides?.nonce,\n    extraGas: async () => (await asyncOptions()).overrides?.extraGas,\n    erc20Value: async () => (await asyncOptions()).overrides?.erc20Value,\n    authorizationList: async () =>\n      (await asyncOptions()).overrides?.authorizationList,\n  });\n}\n", "import type { Definition, TypedData } from \"ox/TypedData\";\nimport type { Hex, SignableMessage } from \"viem\";\nimport type { Chain } from \"../../../../chains/types.js\";\nimport { getCachedChain } from \"../../../../chains/utils.js\";\nimport type { ThirdwebClient } from \"../../../../client/client.js\";\nimport { getBytecode } from \"../../../../contract/actions/get-bytecode.js\";\nimport {\n  getContract,\n  type ThirdwebContract,\n} from \"../../../../contract/contract.js\";\nimport { execute } from \"../../../../extensions/erc7702/__generated__/MinimalAccount/write/execute.js\";\nimport { getRpcClient } from \"../../../../rpc/rpc.js\";\nimport type { SignedAuthorization } from \"../../../../transaction/actions/eip7702/authorization.js\";\nimport { toSerializableTransaction } from \"../../../../transaction/actions/to-serializable-transaction.js\";\nimport type { SendTransactionResult } from \"../../../../transaction/types.js\";\nimport { getAddress } from \"../../../../utils/address.js\";\nimport { getClientFetch } from \"../../../../utils/fetch.js\";\nimport { stringify } from \"../../../../utils/json.js\";\nimport { withCache } from \"../../../../utils/promise/withCache.js\";\nimport { randomBytesHex } from \"../../../../utils/random.js\";\nimport type {\n  Account,\n  SendTransactionOption,\n} from \"../../../interfaces/wallet.js\";\nimport {\n  executeWithSignature,\n  getQueuedTransactionHash,\n} from \"../../../smart/lib/bundler.js\";\nimport { getDefaultBundlerUrl } from \"../../../smart/lib/constants.js\";\nimport type { BundlerOptions } from \"../../../smart/types.js\";\n\ninterface DelegationContractResponse {\n  id: string;\n  jsonrpc: string;\n  result: {\n    delegationContract: string;\n  };\n}\n\n/**\n * Fetches the delegation contract address from the bundler using the tw_getDelegationContract RPC method\n * @internal\n */\nasync function getDelegationContractAddress(args: {\n  client: ThirdwebClient;\n  chain: Chain;\n  bundlerUrl?: string;\n}): Promise<string> {\n  const { client, chain, bundlerUrl } = args;\n  const url = bundlerUrl ?? getDefaultBundlerUrl(chain);\n\n  // Create a cache key based on the bundler URL to ensure we cache per chain/bundler\n  const cacheKey = `delegation-contract:${url}`;\n\n  return withCache(\n    async () => {\n      const fetchWithHeaders = getClientFetch(client);\n\n      const response = await fetchWithHeaders(url, {\n        useAuthToken: true,\n        body: stringify({\n          id: 1,\n          jsonrpc: \"2.0\",\n          method: \"tw_getDelegationContract\",\n          params: [],\n        }),\n        headers: {\n          \"Content-Type\": \"application/json\",\n        },\n        method: \"POST\",\n      });\n\n      if (!response.ok) {\n        throw new Error(\n          `Failed to fetch delegation contract: ${response.status} ${response.statusText}`,\n        );\n      }\n\n      const result: DelegationContractResponse = await response.json();\n\n      if ((result as any).error) {\n        throw new Error(\n          `Delegation contract RPC error: ${JSON.stringify((result as any).error)}`,\n        );\n      }\n\n      if (!result.result?.delegationContract) {\n        throw new Error(\n          \"Invalid response: missing delegationContract in result\",\n        );\n      }\n\n      return result.result.delegationContract;\n    },\n    { cacheKey, cacheTime: 24 * 60 * 60 * 1000 }, // cache for 24 hours\n  );\n}\n\n/**\n * Creates an EIP-7702 account that enables EOA (Externally Owned Account) delegation\n * to smart contract functionality. This allows an EOA to delegate its code execution\n * to a minimal account contract, enabling features like batch transactions and sponsored gas.\n *\n * The minimal account leverages EIP-7702 authorization to delegate the EOA's code to a\n * MinimalAccount contract, allowing the EOA to execute smart contract functions while\n * maintaining its original address and private key control.\n *\n * @param args - Configuration object for creating the minimal account\n * @param args.client - The thirdweb client instance for blockchain interactions\n * @param args.adminAccount - The EOA account that will be delegated to the minimal account contract\n * @param args.sponsorGas - Optional flag to enable sponsored gas transactions via bundler\n *\n * @returns An Account object with enhanced capabilities including batch transactions and EIP-5792 support\n *\n * @example\n * ```typescript\n * import { createThirdwebClient, sendBatchTransaction } from \"thirdweb\";\n * import { privateKeyToAccount } from \"thirdweb/wallets\";\n * import { create7702MinimalAccount } from \"thirdweb/wallets/in-app\";\n * import { sepolia } from \"thirdweb/chains\";\n *\n * // Create a client\n * const client = createThirdwebClient({\n *   clientId: \"your-client-id\"\n * });\n *\n * // Create an EOA account\n * const adminAccount = privateKeyToAccount({\n *   client,\n *   privateKey: \"0x...\"\n * });\n *\n * // Wrap it with a EIP-7702 account\n * const minimal7702Account = create7702MinimalAccount({\n *   client,\n *   adminAccount,\n *   sponsorGas: true // Enable sponsored transactions\n * });\n *\n * // Send a batch of transactions\n * const result = await sendBatchTransaction({\n *   account: minimal7702Account,\n *   transactions: [\n *   {\n *     to: \"0x...\",\n *     data: \"0x...\",\n *     value: 0n,\n *     chainId: sepolia.id\n *   },\n *   {\n *     to: \"0x...\",\n *     data: \"0x...\",\n *     value: 0n,\n *     chainId: sepolia.id\n *   }\n * ]});\n *\n * console.log(\"Batch transaction hash:\", result.transactionHash);\n * ```\n *\n * @wallet\n */\nexport const create7702MinimalAccount = (args: {\n  client: ThirdwebClient;\n  adminAccount: Account;\n  sponsorGas?: boolean;\n}): Account => {\n  const { client, adminAccount, sponsorGas } = args;\n\n  const _sendTxWithAuthorization = async (txs: SendTransactionOption[]) => {\n    const firstTx = txs[0];\n    if (!firstTx) {\n      throw new Error(\"No transactions provided\");\n    }\n    const chain = getCachedChain(firstTx.chainId);\n    const eoaContract = getContract({\n      address: adminAccount.address,\n      chain,\n      client,\n      abi: MinimalAccountAbi,\n    });\n    // check if account has been delegated already\n    let authorization: SignedAuthorization | undefined =\n      firstTx.authorizationList?.[0];\n    const delegationContractAddress = await getDelegationContractAddress({\n      client,\n      chain,\n    });\n    if (\n      authorization &&\n      authorization.address?.toLowerCase() !==\n        delegationContractAddress.toLowerCase()\n    ) {\n      throw new Error(\n        `Authorization address does not match expected delegation contract address. Expected ${delegationContractAddress} but got ${authorization.address}`,\n      );\n    }\n    // if the tx already has an authorization, use it, otherwise sign one\n    if (!authorization) {\n      const isMinimalAccount = await is7702MinimalAccount(\n        eoaContract,\n        delegationContractAddress,\n      );\n      if (!isMinimalAccount) {\n        // if not, sign authorization\n        let nonce = firstTx.nonce\n          ? BigInt(firstTx.nonce)\n          : BigInt(\n              await getNonce({\n                client,\n                address: adminAccount.address,\n                chain,\n              }),\n            );\n        nonce += sponsorGas ? 0n : 1n;\n        const auth = await adminAccount.signAuthorization?.({\n          address: getAddress(delegationContractAddress),\n          chainId: firstTx.chainId,\n          nonce,\n        });\n        if (!auth) {\n          throw new Error(\"Failed to sign authorization\");\n        }\n        authorization = auth;\n      }\n    }\n    if (sponsorGas) {\n      // send transaction from executor, needs signature\n      const wrappedCalls = {\n        calls: txs.map((tx) => ({\n          data: tx.data ?? \"0x\",\n          target: getAddress(tx.to ?? \"\"),\n          value: tx.value ?? 0n,\n        })),\n        uid: randomBytesHex(),\n      };\n      const signature = await adminAccount.signTypedData({\n        domain: {\n          chainId: firstTx.chainId,\n          name: \"MinimalAccount\",\n          verifyingContract: eoaContract.address,\n          version: \"1\",\n        },\n        message: wrappedCalls,\n        primaryType: \"WrappedCalls\",\n        types: {\n          Call: [\n            { name: \"target\", type: \"address\" },\n            { name: \"value\", type: \"uint256\" },\n            { name: \"data\", type: \"bytes\" },\n          ],\n          WrappedCalls: [\n            { name: \"calls\", type: \"Call[]\" },\n            { name: \"uid\", type: \"bytes32\" },\n          ],\n        },\n      });\n\n      const result = await executeWithSignature({\n        authorization,\n        eoaAddress: getAddress(adminAccount.address),\n        options: {\n          chain: getCachedChain(firstTx.chainId),\n          client,\n        },\n        signature,\n        wrappedCalls,\n      });\n\n      const transactionHash = await waitForTransactionHash({\n        options: {\n          chain: getCachedChain(firstTx.chainId),\n          client,\n        },\n        transactionId: result.transactionId,\n      });\n      return {\n        transactionHash,\n      };\n    }\n    // send transaction from EOA\n    // wrap txs in a single execute call to the MinimalAccount\n    const executeTx = execute({\n      calls: txs.map((tx) => ({\n        data: tx.data ?? \"0x\",\n        target: getAddress(tx.to ?? \"\"),\n        value: tx.value ?? 0n,\n      })),\n      contract: eoaContract,\n      overrides: {\n        authorizationList: authorization ? [authorization] : undefined,\n        value: txs.reduce((acc, tx) => acc + (tx.value ?? 0n), 0n),\n      },\n    });\n    // re-estimate gas for the entire batch + authorization\n    const serializedTx = await toSerializableTransaction({\n      from: adminAccount.address,\n      transaction: executeTx,\n    });\n    return adminAccount.sendTransaction(serializedTx);\n  };\n\n  const minimalAccount: Account = {\n    address: adminAccount.address,\n    sendBatchTransaction: async (\n      txs: SendTransactionOption[],\n    ): Promise<SendTransactionResult> => {\n      return _sendTxWithAuthorization(txs);\n    },\n    sendTransaction: async (\n      tx: SendTransactionOption,\n    ): Promise<SendTransactionResult> => {\n      return _sendTxWithAuthorization([tx]);\n    },\n    signMessage: ({\n      message,\n      originalMessage,\n      chainId,\n    }: {\n      message: SignableMessage;\n      originalMessage?: string;\n      chainId?: number;\n    }): Promise<Hex> =>\n      adminAccount.signMessage({ chainId, message, originalMessage }),\n    signTypedData: <\n      const typedData extends TypedData | Record<string, unknown>,\n      primaryType extends keyof typedData | \"EIP712Domain\" = keyof typedData,\n    >(\n      _typedData: Definition<typedData, primaryType>,\n    ): Promise<Hex> => adminAccount.signTypedData(_typedData),\n    sendCalls: async (options) => {\n      const { inAppWalletSendCalls } = await import(\n        \"../eip5792/in-app-wallet-calls.js\"\n      );\n      const firstCall = options.calls[0];\n      if (!firstCall) {\n        throw new Error(\"No calls to send\");\n      }\n      const client = firstCall.client;\n      const chain = firstCall.chain || options.chain;\n      const id = await inAppWalletSendCalls({\n        account: minimalAccount,\n        calls: options.calls,\n        chain,\n      });\n      return { chain, client, id };\n    },\n    getCallsStatus: async (options) => {\n      const { inAppWalletGetCallsStatus } = await import(\n        \"../eip5792/in-app-wallet-calls.js\"\n      );\n      return inAppWalletGetCallsStatus(options);\n    },\n    getCapabilities: async (options) => {\n      return {\n        [options.chainId ?? 1]: {\n          atomic: {\n            status: \"supported\",\n          },\n          paymasterService: {\n            supported: sponsorGas ?? false,\n          },\n        },\n      };\n    },\n  };\n  return minimalAccount;\n};\n\nasync function getNonce(args: {\n  client: ThirdwebClient;\n  address: string;\n  chain: Chain;\n}): Promise<number> {\n  const { client, address, chain } = args;\n  const rpcRequest = getRpcClient({\n    chain,\n    client,\n  });\n  const nonce = await import(\n    \"../../../../rpc/actions/eth_getTransactionCount.js\"\n  ).then(({ eth_getTransactionCount }) =>\n    eth_getTransactionCount(rpcRequest, {\n      address: getAddress(address),\n      blockTag: \"pending\",\n    }),\n  );\n  return nonce;\n}\n\nasync function is7702MinimalAccount(\n  // biome-ignore lint/suspicious/noExplicitAny: TODO properly type tw contract\n  eoaContract: ThirdwebContract<any>,\n  delegationContractAddress: string,\n): Promise<boolean> {\n  const code = await getBytecode(eoaContract);\n  const isDelegated = code.length > 0 && code.startsWith(\"0xef0100\");\n  const target = `0x${code.slice(8, 48)}`;\n  return (\n    isDelegated &&\n    target.toLowerCase() === delegationContractAddress.toLowerCase()\n  );\n}\n\nasync function waitForTransactionHash(args: {\n  options: BundlerOptions;\n  transactionId: string;\n  timeoutMs?: number;\n  intervalMs?: number;\n}): Promise<Hex> {\n  const timeout = args.timeoutMs || 300000; // 5mins\n  const interval = args.intervalMs || 1000; // 1s\n  const endtime = Date.now() + timeout;\n  while (Date.now() < endtime) {\n    const result = await getQueuedTransactionHash({\n      options: args.options,\n      transactionId: args.transactionId,\n    });\n    if (result.transactionHash) {\n      return result.transactionHash;\n    }\n    await new Promise((resolve) => setTimeout(resolve, interval));\n  }\n  throw new Error(\n    `Timeout waiting for transaction to be mined on chain ${args.options.chain.id} with transactionId: ${args.transactionId}`,\n  );\n}\n\nconst MinimalAccountAbi = [\n  { type: \"receive\", stateMutability: \"payable\" },\n  {\n    type: \"function\",\n    name: \"createSessionWithSig\",\n    inputs: [\n      {\n        name: \"sessionSpec\",\n        type: \"tuple\",\n        internalType: \"struct SessionLib.SessionSpec\",\n        components: [\n          { name: \"signer\", type: \"address\", internalType: \"address\" },\n          { name: \"isWildcard\", type: \"bool\", internalType: \"bool\" },\n          { name: \"expiresAt\", type: \"uint256\", internalType: \"uint256\" },\n          {\n            name: \"callPolicies\",\n            type: \"tuple[]\",\n            internalType: \"struct SessionLib.CallSpec[]\",\n            components: [\n              { name: \"target\", type: \"address\", internalType: \"address\" },\n              { name: \"selector\", type: \"bytes4\", internalType: \"bytes4\" },\n              {\n                name: \"maxValuePerUse\",\n                type: \"uint256\",\n                internalType: \"uint256\",\n              },\n              {\n                name: \"valueLimit\",\n                type: \"tuple\",\n                internalType: \"struct SessionLib.UsageLimit\",\n                components: [\n                  {\n                    name: \"limitType\",\n                    type: \"uint8\",\n                    internalType: \"enum SessionLib.LimitType\",\n                  },\n                  { name: \"limit\", type: \"uint256\", internalType: \"uint256\" },\n                  { name: \"period\", type: \"uint256\", internalType: \"uint256\" },\n                ],\n              },\n              {\n                name: \"constraints\",\n                type: \"tuple[]\",\n                internalType: \"struct SessionLib.Constraint[]\",\n                components: [\n                  {\n                    name: \"condition\",\n                    type: \"uint8\",\n                    internalType: \"enum SessionLib.Condition\",\n                  },\n                  { name: \"index\", type: \"uint64\", internalType: \"uint64\" },\n                  {\n                    name: \"refValue\",\n                    type: \"bytes32\",\n                    internalType: \"bytes32\",\n                  },\n                  {\n                    name: \"limit\",\n                    type: \"tuple\",\n                    internalType: \"struct SessionLib.UsageLimit\",\n                    components: [\n                      {\n                        name: \"limitType\",\n                        type: \"uint8\",\n                        internalType: \"enum SessionLib.LimitType\",\n                      },\n                      {\n                        name: \"limit\",\n                        type: \"uint256\",\n                        internalType: \"uint256\",\n                      },\n                      {\n                        name: \"period\",\n                        type: \"uint256\",\n                        internalType: \"uint256\",\n                      },\n                    ],\n                  },\n                ],\n              },\n            ],\n          },\n          {\n            name: \"transferPolicies\",\n            type: \"tuple[]\",\n            internalType: \"struct SessionLib.TransferSpec[]\",\n            components: [\n              { name: \"target\", type: \"address\", internalType: \"address\" },\n              {\n                name: \"maxValuePerUse\",\n                type: \"uint256\",\n                internalType: \"uint256\",\n              },\n              {\n                name: \"valueLimit\",\n                type: \"tuple\",\n                internalType: \"struct SessionLib.UsageLimit\",\n                components: [\n                  {\n                    name: \"limitType\",\n                    type: \"uint8\",\n                    internalType: \"enum SessionLib.LimitType\",\n                  },\n                  { name: \"limit\", type: \"uint256\", internalType: \"uint256\" },\n                  { name: \"period\", type: \"uint256\", internalType: \"uint256\" },\n                ],\n              },\n            ],\n          },\n          { name: \"uid\", type: \"bytes32\", internalType: \"bytes32\" },\n        ],\n      },\n      { name: \"signature\", type: \"bytes\", internalType: \"bytes\" },\n    ],\n    outputs: [],\n    stateMutability: \"nonpayable\",\n  },\n  {\n    type: \"function\",\n    name: \"eip712Domain\",\n    inputs: [],\n    outputs: [\n      { name: \"fields\", type: \"bytes1\", internalType: \"bytes1\" },\n      { name: \"name\", type: \"string\", internalType: \"string\" },\n      { name: \"version\", type: \"string\", internalType: \"string\" },\n      { name: \"chainId\", type: \"uint256\", internalType: \"uint256\" },\n      { name: \"verifyingContract\", type: \"address\", internalType: \"address\" },\n      { name: \"salt\", type: \"bytes32\", internalType: \"bytes32\" },\n      { name: \"extensions\", type: \"uint256[]\", internalType: \"uint256[]\" },\n    ],\n    stateMutability: \"view\",\n  },\n  {\n    type: \"function\",\n    name: \"execute\",\n    inputs: [\n      {\n        name: \"calls\",\n        type: \"tuple[]\",\n        internalType: \"struct Call[]\",\n        components: [\n          { name: \"target\", type: \"address\", internalType: \"address\" },\n          { name: \"value\", type: \"uint256\", internalType: \"uint256\" },\n          { name: \"data\", type: \"bytes\", internalType: \"bytes\" },\n        ],\n      },\n    ],\n    outputs: [],\n    stateMutability: \"payable\",\n  },\n  {\n    type: \"function\",\n    name: \"executeWithSig\",\n    inputs: [\n      {\n        name: \"wrappedCalls\",\n        type: \"tuple\",\n        internalType: \"struct WrappedCalls\",\n        components: [\n          {\n            name: \"calls\",\n            type: \"tuple[]\",\n            internalType: \"struct Call[]\",\n            components: [\n              { name: \"target\", type: \"address\", internalType: \"address\" },\n              { name: \"value\", type: \"uint256\", internalType: \"uint256\" },\n              { name: \"data\", type: \"bytes\", internalType: \"bytes\" },\n            ],\n          },\n          { name: \"uid\", type: \"bytes32\", internalType: \"bytes32\" },\n        ],\n      },\n      { name: \"signature\", type: \"bytes\", internalType: \"bytes\" },\n    ],\n    outputs: [],\n    stateMutability: \"payable\",\n  },\n  {\n    type: \"function\",\n    name: \"getCallPoliciesForSigner\",\n    inputs: [{ name: \"signer\", type: \"address\", internalType: \"address\" }],\n    outputs: [\n      {\n        name: \"\",\n        type: \"tuple[]\",\n        internalType: \"struct SessionLib.CallSpec[]\",\n        components: [\n          { name: \"target\", type: \"address\", internalType: \"address\" },\n          { name: \"selector\", type: \"bytes4\", internalType: \"bytes4\" },\n          { name: \"maxValuePerUse\", type: \"uint256\", internalType: \"uint256\" },\n          {\n            name: \"valueLimit\",\n            type: \"tuple\",\n            internalType: \"struct SessionLib.UsageLimit\",\n            components: [\n              {\n                name: \"limitType\",\n                type: \"uint8\",\n                internalType: \"enum SessionLib.LimitType\",\n              },\n              { name: \"limit\", type: \"uint256\", internalType: \"uint256\" },\n              { name: \"period\", type: \"uint256\", internalType: \"uint256\" },\n            ],\n          },\n          {\n            name: \"constraints\",\n            type: \"tuple[]\",\n            internalType: \"struct SessionLib.Constraint[]\",\n            components: [\n              {\n                name: \"condition\",\n                type: \"uint8\",\n                internalType: \"enum SessionLib.Condition\",\n              },\n              { name: \"index\", type: \"uint64\", internalType: \"uint64\" },\n              { name: \"refValue\", type: \"bytes32\", internalType: \"bytes32\" },\n              {\n                name: \"limit\",\n                type: \"tuple\",\n                internalType: \"struct SessionLib.UsageLimit\",\n                components: [\n                  {\n                    name: \"limitType\",\n                    type: \"uint8\",\n                    internalType: \"enum SessionLib.LimitType\",\n                  },\n                  { name: \"limit\", type: \"uint256\", internalType: \"uint256\" },\n                  { name: \"period\", type: \"uint256\", internalType: \"uint256\" },\n                ],\n              },\n            ],\n          },\n        ],\n      },\n    ],\n    stateMutability: \"view\",\n  },\n  {\n    type: \"function\",\n    name: \"getSessionExpirationForSigner\",\n    inputs: [{ name: \"signer\", type: \"address\", internalType: \"address\" }],\n    outputs: [{ name: \"\", type: \"uint256\", internalType: \"uint256\" }],\n    stateMutability: \"view\",\n  },\n  {\n    type: \"function\",\n    name: \"getSessionStateForSigner\",\n    inputs: [{ name: \"signer\", type: \"address\", internalType: \"address\" }],\n    outputs: [\n      {\n        name: \"\",\n        type: \"tuple\",\n        internalType: \"struct SessionLib.SessionState\",\n        components: [\n          {\n            name: \"transferValue\",\n            type: \"tuple[]\",\n            internalType: \"struct SessionLib.LimitState[]\",\n            components: [\n              { name: \"remaining\", type: \"uint256\", internalType: \"uint256\" },\n              { name: \"target\", type: \"address\", internalType: \"address\" },\n              { name: \"selector\", type: \"bytes4\", internalType: \"bytes4\" },\n              { name: \"index\", type: \"uint256\", internalType: \"uint256\" },\n            ],\n          },\n          {\n            name: \"callValue\",\n            type: \"tuple[]\",\n            internalType: \"struct SessionLib.LimitState[]\",\n            components: [\n              { name: \"remaining\", type: \"uint256\", internalType: \"uint256\" },\n              { name: \"target\", type: \"address\", internalType: \"address\" },\n              { name: \"selector\", type: \"bytes4\", internalType: \"bytes4\" },\n              { name: \"index\", type: \"uint256\", internalType: \"uint256\" },\n            ],\n          },\n          {\n            name: \"callParams\",\n            type: \"tuple[]\",\n            internalType: \"struct SessionLib.LimitState[]\",\n            components: [\n              { name: \"remaining\", type: \"uint256\", internalType: \"uint256\" },\n              { name: \"target\", type: \"address\", internalType: \"address\" },\n              { name: \"selector\", type: \"bytes4\", internalType: \"bytes4\" },\n              { name: \"index\", type: \"uint256\", internalType: \"uint256\" },\n            ],\n          },\n        ],\n      },\n    ],\n    stateMutability: \"view\",\n  },\n  {\n    type: \"function\",\n    name: \"getTransferPoliciesForSigner\",\n    inputs: [{ name: \"signer\", type: \"address\", internalType: \"address\" }],\n    outputs: [\n      {\n        name: \"\",\n        type: \"tuple[]\",\n        internalType: \"struct SessionLib.TransferSpec[]\",\n        components: [\n          { name: \"target\", type: \"address\", internalType: \"address\" },\n          { name: \"maxValuePerUse\", type: \"uint256\", internalType: \"uint256\" },\n          {\n            name: \"valueLimit\",\n            type: \"tuple\",\n            internalType: \"struct SessionLib.UsageLimit\",\n            components: [\n              {\n                name: \"limitType\",\n                type: \"uint8\",\n                internalType: \"enum SessionLib.LimitType\",\n              },\n              { name: \"limit\", type: \"uint256\", internalType: \"uint256\" },\n              { name: \"period\", type: \"uint256\", internalType: \"uint256\" },\n            ],\n          },\n        ],\n      },\n    ],\n    stateMutability: \"view\",\n  },\n  {\n    type: \"function\",\n    name: \"isWildcardSigner\",\n    inputs: [{ name: \"signer\", type: \"address\", internalType: \"address\" }],\n    outputs: [{ name: \"\", type: \"bool\", internalType: \"bool\" }],\n    stateMutability: \"view\",\n  },\n  {\n    type: \"function\",\n    name: \"onERC1155BatchReceived\",\n    inputs: [\n      { name: \"\", type: \"address\", internalType: \"address\" },\n      { name: \"\", type: \"address\", internalType: \"address\" },\n      { name: \"\", type: \"uint256[]\", internalType: \"uint256[]\" },\n      { name: \"\", type: \"uint256[]\", internalType: \"uint256[]\" },\n      { name: \"\", type: \"bytes\", internalType: \"bytes\" },\n    ],\n    outputs: [{ name: \"\", type: \"bytes4\", internalType: \"bytes4\" }],\n    stateMutability: \"nonpayable\",\n  },\n  {\n    type: \"function\",\n    name: \"onERC1155Received\",\n    inputs: [\n      { name: \"\", type: \"address\", internalType: \"address\" },\n      { name: \"\", type: \"address\", internalType: \"address\" },\n      { name: \"\", type: \"uint256\", internalType: \"uint256\" },\n      { name: \"\", type: \"uint256\", internalType: \"uint256\" },\n      { name: \"\", type: \"bytes\", internalType: \"bytes\" },\n    ],\n    outputs: [{ name: \"\", type: \"bytes4\", internalType: \"bytes4\" }],\n    stateMutability: \"nonpayable\",\n  },\n  {\n    type: \"function\",\n    name: \"onERC721Received\",\n    inputs: [\n      { name: \"\", type: \"address\", internalType: \"address\" },\n      { name: \"\", type: \"address\", internalType: \"address\" },\n      { name: \"\", type: \"uint256\", internalType: \"uint256\" },\n      { name: \"\", type: \"bytes\", internalType: \"bytes\" },\n    ],\n    outputs: [{ name: \"\", type: \"bytes4\", internalType: \"bytes4\" }],\n    stateMutability: \"nonpayable\",\n  },\n  {\n    type: \"function\",\n    name: \"supportsInterface\",\n    inputs: [{ name: \"interfaceId\", type: \"bytes4\", internalType: \"bytes4\" }],\n    outputs: [{ name: \"\", type: \"bool\", internalType: \"bool\" }],\n    stateMutability: \"view\",\n  },\n  {\n    type: \"event\",\n    name: \"Executed\",\n    inputs: [\n      { name: \"to\", type: \"address\", indexed: true, internalType: \"address\" },\n      {\n        name: \"value\",\n        type: \"uint256\",\n        indexed: false,\n        internalType: \"uint256\",\n      },\n      { name: \"data\", type: \"bytes\", indexed: false, internalType: \"bytes\" },\n    ],\n    anonymous: false,\n  },\n  {\n    type: \"event\",\n    name: \"SessionCreated\",\n    inputs: [\n      {\n        name: \"signer\",\n        type: \"address\",\n        indexed: true,\n        internalType: \"address\",\n      },\n      {\n        name: \"sessionSpec\",\n        type: \"tuple\",\n        indexed: false,\n        internalType: \"struct SessionLib.SessionSpec\",\n        components: [\n          { name: \"signer\", type: \"address\", internalType: \"address\" },\n          { name: \"isWildcard\", type: \"bool\", internalType: \"bool\" },\n          { name: \"expiresAt\", type: \"uint256\", internalType: \"uint256\" },\n          {\n            name: \"callPolicies\",\n            type: \"tuple[]\",\n            internalType: \"struct SessionLib.CallSpec[]\",\n            components: [\n              { name: \"target\", type: \"address\", internalType: \"address\" },\n              { name: \"selector\", type: \"bytes4\", internalType: \"bytes4\" },\n              {\n                name: \"maxValuePerUse\",\n                type: \"uint256\",\n                internalType: \"uint256\",\n              },\n              {\n                name: \"valueLimit\",\n                type: \"tuple\",\n                internalType: \"struct SessionLib.UsageLimit\",\n                components: [\n                  {\n                    name: \"limitType\",\n                    type: \"uint8\",\n                    internalType: \"enum SessionLib.LimitType\",\n                  },\n                  { name: \"limit\", type: \"uint256\", internalType: \"uint256\" },\n                  { name: \"period\", type: \"uint256\", internalType: \"uint256\" },\n                ],\n              },\n              {\n                name: \"constraints\",\n                type: \"tuple[]\",\n                internalType: \"struct SessionLib.Constraint[]\",\n                components: [\n                  {\n                    name: \"condition\",\n                    type: \"uint8\",\n                    internalType: \"enum SessionLib.Condition\",\n                  },\n                  { name: \"index\", type: \"uint64\", internalType: \"uint64\" },\n                  {\n                    name: \"refValue\",\n                    type: \"bytes32\",\n                    internalType: \"bytes32\",\n                  },\n                  {\n                    name: \"limit\",\n                    type: \"tuple\",\n                    internalType: \"struct SessionLib.UsageLimit\",\n                    components: [\n                      {\n                        name: \"limitType\",\n                        type: \"uint8\",\n                        internalType: \"enum SessionLib.LimitType\",\n                      },\n                      {\n                        name: \"limit\",\n                        type: \"uint256\",\n                        internalType: \"uint256\",\n                      },\n                      {\n                        name: \"period\",\n                        type: \"uint256\",\n                        internalType: \"uint256\",\n                      },\n                    ],\n                  },\n                ],\n              },\n            ],\n          },\n          {\n            name: \"transferPolicies\",\n            type: \"tuple[]\",\n            internalType: \"struct SessionLib.TransferSpec[]\",\n            components: [\n              { name: \"target\", type: \"address\", internalType: \"address\" },\n              {\n                name: \"maxValuePerUse\",\n                type: \"uint256\",\n                internalType: \"uint256\",\n              },\n              {\n                name: \"valueLimit\",\n                type: \"tuple\",\n                internalType: \"struct SessionLib.UsageLimit\",\n                components: [\n                  {\n                    name: \"limitType\",\n                    type: \"uint8\",\n                    internalType: \"enum SessionLib.LimitType\",\n                  },\n                  { name: \"limit\", type: \"uint256\", internalType: \"uint256\" },\n                  { name: \"period\", type: \"uint256\", internalType: \"uint256\" },\n                ],\n              },\n            ],\n          },\n          { name: \"uid\", type: \"bytes32\", internalType: \"bytes32\" },\n        ],\n      },\n    ],\n    anonymous: false,\n  },\n  {\n    type: \"event\",\n    name: \"ValueReceived\",\n    inputs: [\n      { name: \"from\", type: \"address\", indexed: true, internalType: \"address\" },\n      {\n        name: \"value\",\n        type: \"uint256\",\n        indexed: false,\n        internalType: \"uint256\",\n      },\n    ],\n    anonymous: false,\n  },\n  {\n    type: \"error\",\n    name: \"AllowanceExceeded\",\n    inputs: [\n      { name: \"allowanceUsage\", type: \"uint256\", internalType: \"uint256\" },\n      { name: \"limit\", type: \"uint256\", internalType: \"uint256\" },\n      { name: \"period\", type: \"uint64\", internalType: \"uint64\" },\n    ],\n  },\n  {\n    type: \"error\",\n    name: \"CallPolicyViolated\",\n    inputs: [\n      { name: \"target\", type: \"address\", internalType: \"address\" },\n      { name: \"selector\", type: \"bytes4\", internalType: \"bytes4\" },\n    ],\n  },\n  { type: \"error\", name: \"CallReverted\", inputs: [] },\n  {\n    type: \"error\",\n    name: \"ConditionFailed\",\n    inputs: [\n      { name: \"param\", type: \"bytes32\", internalType: \"bytes32\" },\n      { name: \"refValue\", type: \"bytes32\", internalType: \"bytes32\" },\n      { name: \"condition\", type: \"uint8\", internalType: \"uint8\" },\n    ],\n  },\n  {\n    type: \"error\",\n    name: \"InvalidDataLength\",\n    inputs: [\n      { name: \"actualLength\", type: \"uint256\", internalType: \"uint256\" },\n      { name: \"expectedLength\", type: \"uint256\", internalType: \"uint256\" },\n    ],\n  },\n  {\n    type: \"error\",\n    name: \"InvalidSignature\",\n    inputs: [\n      { name: \"msgSender\", type: \"address\", internalType: \"address\" },\n      { name: \"thisAddress\", type: \"address\", internalType: \"address\" },\n    ],\n  },\n  {\n    type: \"error\",\n    name: \"LifetimeUsageExceeded\",\n    inputs: [\n      { name: \"lifetimeUsage\", type: \"uint256\", internalType: \"uint256\" },\n      { name: \"limit\", type: \"uint256\", internalType: \"uint256\" },\n    ],\n  },\n  {\n    type: \"error\",\n    name: \"MaxValueExceeded\",\n    inputs: [\n      { name: \"value\", type: \"uint256\", internalType: \"uint256\" },\n      { name: \"maxValuePerUse\", type: \"uint256\", internalType: \"uint256\" },\n    ],\n  },\n  { type: \"error\", name: \"NoCallsToExecute\", inputs: [] },\n  { type: \"error\", name: \"SessionExpired\", inputs: [] },\n  { type: \"error\", name: \"SessionExpiresTooSoon\", inputs: [] },\n  { type: \"error\", name: \"SessionZeroSigner\", inputs: [] },\n  {\n    type: \"error\",\n    name: \"TransferPolicyViolated\",\n    inputs: [{ name: \"target\", type: \"address\", internalType: \"address\" }],\n  },\n  { type: \"error\", name: \"UIDAlreadyProcessed\", inputs: [] },\n] as const;\n", "import { ethereum } from \"../../../../chains/chain-definitions/ethereum.js\";\nimport type { Chain } from \"../../../../chains/types.js\";\nimport type { ThirdwebClient } from \"../../../../client/client.js\";\nimport {\n  type SocialAuthOption,\n  socialAuthOptions,\n} from \"../../../../wallets/types.js\";\nimport type {\n  EcosystemWalletConnectionOptions,\n  EcosystemWalletCreationOptions,\n} from \"../../../ecosystem/types.js\";\nimport type { Account, Wallet } from \"../../../interfaces/wallet.js\";\nimport type { SmartWalletOptions } from \"../../../smart/types.js\";\nimport type {\n  CreateWalletArgs,\n  EcosystemWalletId,\n  WalletAutoConnectionOption,\n  WalletId,\n} from \"../../../wallet-types.js\";\nimport { create7702MinimalAccount } from \"../eip7702/minimal-account.js\";\nimport type { InAppConnector } from \"../interfaces/connector.js\";\nimport type {\n  ExecutionModeOptions,\n  InAppWalletConnectionOptions,\n  InAppWalletCreationOptions,\n} from \"./types.js\";\n\n/**\n * Checks if the provided wallet is an in-app wallet.\n *\n * @param wallet - The wallet to check.\n * @returns True if the wallet is an in-app wallet, false otherwise.\n */\nexport function isInAppWallet(\n  wallet: Wallet<WalletId>,\n): wallet is Wallet<\"inApp\" | \"embedded\"> {\n  return wallet.id === \"inApp\" || wallet.id === \"embedded\";\n}\n\n/**\n * @internal\n */\nexport async function connectInAppWallet(\n  options: InAppWalletConnectionOptions | EcosystemWalletConnectionOptions,\n  createOptions: InAppWalletCreationOptions | EcosystemWalletCreationOptions,\n  connector: InAppConnector,\n): Promise<{ account: Account; chain: Chain; adminAccount?: Account }> {\n  if (\n    // if auth mode is not specified, the default is popup\n    createOptions?.auth?.mode !== \"popup\" &&\n    createOptions?.auth?.mode !== undefined &&\n    connector.authenticateWithRedirect\n  ) {\n    const strategy = options.strategy;\n    if (socialAuthOptions.includes(strategy as SocialAuthOption)) {\n      await connector.authenticateWithRedirect(\n        strategy as SocialAuthOption,\n        createOptions?.auth?.mode,\n        createOptions?.auth?.redirectUrl,\n      );\n    }\n  }\n  // If we don't have authenticateWithRedirect then it's likely react native, so the default is to redirect and we can carry on\n  // IF WE EVER ADD MORE CONNECTOR TYPES, this could cause redirect to be ignored despite being specified\n  // TODO: In V6, make everything redirect auth\n\n  const authResult = await connector.connect(options);\n  const authAccount = authResult.user.account;\n\n  return createInAppAccount({\n    authAccount,\n    client: options.client,\n    createOptions,\n    desiredChain: options.chain,\n  });\n}\n\n/**\n * @internal\n */\nexport async function autoConnectInAppWallet(\n  options:\n    | WalletAutoConnectionOption<\"inApp\">\n    | WalletAutoConnectionOption<EcosystemWalletId>,\n  createOptions:\n    | CreateWalletArgs<\"inApp\">[1]\n    | CreateWalletArgs<EcosystemWalletId>[1],\n  connector: InAppConnector,\n): Promise<{ account: Account; chain: Chain; adminAccount?: Account }> {\n  if (options.authResult && connector.loginWithAuthToken) {\n    await connector.loginWithAuthToken(options.authResult);\n  }\n\n  const user = await getAuthenticatedUser(connector);\n  if (!user) {\n    throw new Error(\"Failed to authenticate user.\");\n  }\n\n  const authAccount = user.account;\n\n  return createInAppAccount({\n    authAccount,\n    client: options.client,\n    createOptions,\n    desiredChain: options.chain,\n  });\n}\n\nasync function convertToSmartAccount(options: {\n  client: ThirdwebClient;\n  authAccount: Account;\n  smartAccountOptions: CreateWalletArgs<\"smart\">[1];\n  chain?: Chain;\n}) {\n  const { connectSmartAccount } = await import(\"../../../smart/index.js\");\n\n  return connectSmartAccount(\n    {\n      chain: options.chain,\n      client: options.client,\n      personalAccount: options.authAccount,\n    },\n    options.smartAccountOptions,\n  );\n}\n\nasync function getAuthenticatedUser(connector: InAppConnector) {\n  const user = await connector.getUser();\n  switch (user.status) {\n    case \"Logged In, Wallet Initialized\": {\n      return user;\n    }\n  }\n  return undefined;\n}\n\nasync function createInAppAccount(options: {\n  client: ThirdwebClient;\n  authAccount: Account;\n  createOptions: InAppWalletCreationOptions | EcosystemWalletCreationOptions;\n  desiredChain?: Chain;\n}) {\n  const { createOptions, authAccount, desiredChain, client } = options;\n  let smartAccountOptions: SmartWalletOptions | undefined;\n  let eip7702: Extract<ExecutionModeOptions, { mode: \"EIP7702\" }> | undefined;\n  const executionMode =\n    createOptions && \"executionMode\" in createOptions\n      ? createOptions.executionMode\n      : undefined;\n\n  if (executionMode) {\n    if (executionMode.mode === \"EIP4337\") {\n      smartAccountOptions = executionMode.smartAccount;\n    } else if (executionMode.mode === \"EIP7702\") {\n      eip7702 = executionMode;\n    }\n  }\n\n  // backwards compatibility\n  if (\n    createOptions &&\n    \"smartAccount\" in createOptions &&\n    createOptions?.smartAccount\n  ) {\n    smartAccountOptions = createOptions.smartAccount;\n  }\n\n  if (smartAccountOptions) {\n    const [account, chain] = await convertToSmartAccount({\n      authAccount,\n      chain: desiredChain,\n      client,\n      smartAccountOptions,\n    });\n    return { account, adminAccount: authAccount, chain };\n  }\n\n  if (eip7702) {\n    const chain = desiredChain;\n    if (!chain) {\n      throw new Error(\n        \"Chain is required for EIP-7702 execution, pass a chain when connecting the inAppWallet.\",\n      );\n    }\n    const account = create7702MinimalAccount({\n      adminAccount: authAccount,\n      client,\n      sponsorGas: eip7702.sponsorGas,\n    });\n    return {\n      account,\n      adminAccount: authAccount,\n      chain,\n    };\n  }\n\n  return { account: authAccount, chain: desiredChain || ethereum } as const;\n}\n"],
  "mappings": "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",
  "names": ["client"]
}
