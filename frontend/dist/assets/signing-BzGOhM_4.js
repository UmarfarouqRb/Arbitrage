import{r as C,w as y,b5 as h,b6 as V,Q as c,b7 as w,b8 as P,b9 as _,ba as H,bb as $,aP as b,bc as A,G as T}from"./index-B3E2rKjL.js";import{concatHex as F}from"./concat-hex-CAYpxJVg.js";import{p as S}from"./index-CnxzGhSb.js";import"./send-eip712-transaction-CmsARbZ0.js";import"./eth_sendRawTransaction-DPdnXbFR.js";import"./sha256-CDD3E8SB.js";const O="0x1626ba7e",U=[{name:"hash",type:"bytes32"},{name:"signature",type:"bytes"}],L=[{type:"bytes4"}];async function B(t){return C({contract:t.contract,method:[O,U,L],params:[t.hash,t.signature]})}const N="0x6492649264926492649264926492649264926492649264926492649264926492";function E({address:t,data:r,signature:e}){return F([y([{type:"address"},{type:"bytes"},{type:"bytes"}],[t,r,e]),N])}const G="0x1626ba7e";async function v({hash:t,signature:r,contract:e}){try{return await B({contract:e,hash:t,signature:r})===G}catch(n){return console.error("Error verifying EIP-1271 signature",n),!1}}const k=`Ethereum Signed Message:
`;function R(t,r){const e=typeof t=="string"?h(t):t.raw instanceof Uint8Array?t.raw:V(t.raw),n=h(`${k}${e.length}`);return c(w(n,e),r)}function j(t){const{domain:r={},message:e,primaryType:n}=t,a={EIP712Domain:P(r),...t.types};_({domain:r,message:e,primaryType:n,types:a});const s=["0x1901"];if(r&&s.push(H({domain:r,types:a})),n!=="EIP712Domain"){const i=(()=>{const o=x({data:e,primaryType:n,types:a});return c(o)})();s.push(i)}return c(w(...s.map(i=>$(i))))}function x({data:t,primaryType:r,types:e}){const n=[{type:"bytes32"}],a=[z({primaryType:r,types:e})];if(!e[r])throw new Error("Invalid types");for(const s of e[r]){const[i,o]=M({name:s.name,type:s.type,types:e,value:t[s.name]});n.push(i),a.push(o)}return y(n,a)}function z({primaryType:t,types:r}){const e=b(Q({primaryType:t,types:r}));return c(e)}function Q({primaryType:t,types:r}){let e="";const n=D({primaryType:t,types:r});n.delete(t);const a=[t,...Array.from(n).sort()];for(const s of a){if(!r[s])throw new Error("Invalid types");e+=`${s}(${r[s].map(({name:i,type:o})=>`${o} ${i}`).join(",")})`}return e}function D({primaryType:t,types:r},e=new Set){const n=t.match(/^\w*/u),a=n==null?void 0:n[0];if(e.has(a)||r[a]===void 0)return e;e.add(a);for(const s of r[a])D({primaryType:s.type,types:r},e);return e}function M({types:t,name:r,type:e,value:n}){if(t[e]!==void 0)return[{type:"bytes32"},c(x({data:n,primaryType:e,types:t}))];if(e==="bytes")return n=`0x${(n.length%2?"0":"")+n.slice(2)}`,[{type:"bytes32"},c(n)];if(e==="string")return[{type:"bytes32"},c(b(n))];if(e.lastIndexOf("]")===e.length-1){const a=e.slice(0,e.lastIndexOf("[")),s=n.map(i=>M({name:r,type:a,types:t,value:i}));return[{type:"bytes32"},c(y(s.map(([i])=>i),s.map(([,i])=>i)))]}return[{type:e},n]}async function ee({accountContract:t,factoryContract:r,options:e,message:n}){var f,u;const a=R(n);let s;const i=y([{type:"bytes32"}],[a]);if(s=await e.personalAccount.signTypedData({domain:{chainId:e.chain.id,name:"Account",verifyingContract:t.address,version:"1"},message:{message:i},primaryType:"AccountMessage",types:{AccountMessage:[{name:"message",type:"bytes"}]}}),await A(t)){if(await v({contract:t,hash:a,signature:s}))return s;throw new Error("Failed to verify signature")}else{const d=S({accountSalt:(f=e.overrides)==null?void 0:f.accountSalt,adminAddress:e.personalAccount.address,createAccountOverride:(u=e.overrides)==null?void 0:u.createAccount,factoryContract:r});if(!d)throw new Error("Create account override not provided");const p=await T(d);return E({address:r.address,data:p,signature:s})}}async function te({accountContract:t,factoryContract:r,options:e,typedData:n}){var u,d,p,g,l;if(((d=(u=n.domain)==null?void 0:u.verifyingContract)==null?void 0:d.toLowerCase())===((p=t.address)==null?void 0:p.toLowerCase()))return e.personalAccount.signTypedData(n);const s=j(n);let i;const o=y([{type:"bytes32"}],[s]);if(i=await e.personalAccount.signTypedData({domain:{chainId:e.chain.id,name:"Account",verifyingContract:t.address,version:"1"},message:{message:o},primaryType:"AccountMessage",types:{AccountMessage:[{name:"message",type:"bytes"}]}}),await A(t)){if(await v({contract:t,hash:s,signature:i}))return i;throw new Error("Failed to verify signature")}else{const m=S({accountSalt:(g=e.overrides)==null?void 0:g.accountSalt,adminAddress:e.personalAccount.address,createAccountOverride:(l=e.overrides)==null?void 0:l.createAccount,factoryContract:r});if(!m)throw new Error("Create account override not provided");const I=await T(m);return E({address:r.address,data:I,signature:i})}}export{ee as smartAccountSignMessage,te as smartAccountSignTypedData};
